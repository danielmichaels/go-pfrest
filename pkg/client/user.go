// This file was auto-generated by Fern from our API Definition.

package pfclientapi

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/danielmichaels/go-pfrest/pkg/client/core"
)

type DeleteUserAuthServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteUserAuthServersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteUserEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteUserGroupEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteUserGroupsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteUsersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetUserAuthServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetUserAuthServersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetUserAuthServersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetUserAuthServersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetUserEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetUserGroupEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetUserGroupsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetUserGroupsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetUserGroupsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetUsersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetUsersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetUsersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type PatchUserAuthServerEndpointRequest struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchUserEndpointRequest struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchUserGroupEndpointRequest struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PostUserAuthServerEndpointRequest struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
}

type PostUserEndpointRequest struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
}

type PostUserGroupEndpointRequest struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
}

type AuthServer struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AuthServer) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthServer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthServer(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuthServer) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
type AuthServerLdapScope string

const (
	AuthServerLdapScopeOne     AuthServerLdapScope = "one"
	AuthServerLdapScopeSubtree AuthServerLdapScope = "subtree"
)

func NewAuthServerLdapScopeFromString(s string) (AuthServerLdapScope, error) {
	switch s {
	case "one":
		return AuthServerLdapScopeOne, nil
	case "subtree":
		return AuthServerLdapScopeSubtree, nil
	}
	var t AuthServerLdapScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthServerLdapScope) Ptr() *AuthServerLdapScope {
	return &a
}

// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
type AuthServerLdapUrltype string

const (
	AuthServerLdapUrltypeStandardTCP     AuthServerLdapUrltype = "Standard TCP"
	AuthServerLdapUrltypeStarttlsEncrypt AuthServerLdapUrltype = "STARTTLS Encrypt"
	AuthServerLdapUrltypeSslTLSEncrypted AuthServerLdapUrltype = "SSL/TLS Encrypted"
)

func NewAuthServerLdapUrltypeFromString(s string) (AuthServerLdapUrltype, error) {
	switch s {
	case "Standard TCP":
		return AuthServerLdapUrltypeStandardTCP, nil
	case "STARTTLS Encrypt":
		return AuthServerLdapUrltypeStarttlsEncrypt, nil
	case "SSL/TLS Encrypted":
		return AuthServerLdapUrltypeSslTLSEncrypted, nil
	}
	var t AuthServerLdapUrltype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthServerLdapUrltype) Ptr() *AuthServerLdapUrltype {
	return &a
}

// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
type AuthServerRadiusProtocol string

const (
	AuthServerRadiusProtocolMschaPv2 AuthServerRadiusProtocol = "MSCHAPv2"
	AuthServerRadiusProtocolMschaPv1 AuthServerRadiusProtocol = "MSCHAPv1"
	AuthServerRadiusProtocolChapMd5  AuthServerRadiusProtocol = "CHAP_MD5"
	AuthServerRadiusProtocolPap      AuthServerRadiusProtocol = "PAP"
)

func NewAuthServerRadiusProtocolFromString(s string) (AuthServerRadiusProtocol, error) {
	switch s {
	case "MSCHAPv2":
		return AuthServerRadiusProtocolMschaPv2, nil
	case "MSCHAPv1":
		return AuthServerRadiusProtocolMschaPv1, nil
	case "CHAP_MD5":
		return AuthServerRadiusProtocolChapMd5, nil
	case "PAP":
		return AuthServerRadiusProtocolPap, nil
	}
	var t AuthServerRadiusProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthServerRadiusProtocol) Ptr() *AuthServerRadiusProtocol {
	return &a
}

// The type of this authentication server.<br>
type AuthServerType string

const (
	AuthServerTypeLdap   AuthServerType = "ldap"
	AuthServerTypeRadius AuthServerType = "radius"
)

func NewAuthServerTypeFromString(s string) (AuthServerType, error) {
	switch s {
	case "ldap":
		return AuthServerTypeLdap, nil
	case "radius":
		return AuthServerTypeRadius, nil
	}
	var t AuthServerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthServerType) Ptr() *AuthServerType {
	return &a
}

type User struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`

	_rawJSON json.RawMessage
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserGroup struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler UserGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserGroup(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserGroup) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
type UserGroupScope string

const (
	UserGroupScopeLocal  UserGroupScope = "local"
	UserGroupScopeRemote UserGroupScope = "remote"
	UserGroupScopeSystem UserGroupScope = "system"
)

func NewUserGroupScopeFromString(s string) (UserGroupScope, error) {
	switch s {
	case "local":
		return UserGroupScopeLocal, nil
	case "remote":
		return UserGroupScopeRemote, nil
	case "system":
		return UserGroupScopeSystem, nil
	}
	var t UserGroupScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserGroupScope) Ptr() *UserGroupScope {
	return &u
}

type DeleteUserAuthServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteUserAuthServerEndpointRequestIDFromInteger(value int) *DeleteUserAuthServerEndpointRequestID {
	return &DeleteUserAuthServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteUserAuthServerEndpointRequestIDFromString(value string) *DeleteUserAuthServerEndpointRequestID {
	return &DeleteUserAuthServerEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteUserAuthServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteUserAuthServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteUserAuthServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteUserAuthServerEndpointRequestID) Accept(visitor DeleteUserAuthServerEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteUserAuthServerEndpointResponse struct {
	Data *DeleteUserAuthServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserAuthServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserAuthServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserAuthServerEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserAuthServerEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserAuthServerEndpointResponseData struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserAuthServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserAuthServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserAuthServerEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserAuthServerEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserAuthServersEndpointResponse struct {
	Data []*DeleteUserAuthServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserAuthServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserAuthServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserAuthServersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserAuthServersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserAuthServersEndpointResponseDataItem struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserAuthServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserAuthServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserAuthServersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserAuthServersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteUserEndpointRequestIDFromInteger(value int) *DeleteUserEndpointRequestID {
	return &DeleteUserEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteUserEndpointRequestIDFromString(value string) *DeleteUserEndpointRequestID {
	return &DeleteUserEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteUserEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteUserEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteUserEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteUserEndpointRequestID) Accept(visitor DeleteUserEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteUserEndpointResponse struct {
	Data *DeleteUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserEndpointResponseData struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserGroupEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteUserGroupEndpointRequestIDFromInteger(value int) *DeleteUserGroupEndpointRequestID {
	return &DeleteUserGroupEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteUserGroupEndpointRequestIDFromString(value string) *DeleteUserGroupEndpointRequestID {
	return &DeleteUserGroupEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteUserGroupEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteUserGroupEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteUserGroupEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteUserGroupEndpointRequestID) Accept(visitor DeleteUserGroupEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteUserGroupEndpointResponse struct {
	Data *DeleteUserGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserGroupEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserGroupEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserGroupEndpointResponseData struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserGroupEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserGroupEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserGroupsEndpointResponse struct {
	Data []*DeleteUserGroupsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserGroupsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserGroupsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserGroupsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserGroupsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUserGroupsEndpointResponseDataItem struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUserGroupsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUserGroupsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUserGroupsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUserGroupsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUsersEndpointResponse struct {
	Data []*DeleteUsersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUsersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUsersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUsersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUsersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteUsersEndpointResponseDataItem struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteUsersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteUsersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteUsersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteUsersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetUserAuthServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetUserAuthServerEndpointRequestIDFromInteger(value int) *GetUserAuthServerEndpointRequestID {
	return &GetUserAuthServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetUserAuthServerEndpointRequestIDFromString(value string) *GetUserAuthServerEndpointRequestID {
	return &GetUserAuthServerEndpointRequestID{typeName: "string", String: value}
}

func (g *GetUserAuthServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetUserAuthServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetUserAuthServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetUserAuthServerEndpointRequestID) Accept(visitor GetUserAuthServerEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetUserAuthServerEndpointResponse struct {
	Data *GetUserAuthServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserAuthServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserAuthServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserAuthServerEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserAuthServerEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserAuthServerEndpointResponseData struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserAuthServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserAuthServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserAuthServerEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserAuthServerEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserAuthServersEndpointRequestSortFlags string

const (
	GetUserAuthServersEndpointRequestSortFlagsSortRegular      GetUserAuthServersEndpointRequestSortFlags = "SORT_REGULAR"
	GetUserAuthServersEndpointRequestSortFlagsSortNumeric      GetUserAuthServersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetUserAuthServersEndpointRequestSortFlagsSortString       GetUserAuthServersEndpointRequestSortFlags = "SORT_STRING"
	GetUserAuthServersEndpointRequestSortFlagsSortLocaleString GetUserAuthServersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetUserAuthServersEndpointRequestSortFlagsSortNatural      GetUserAuthServersEndpointRequestSortFlags = "SORT_NATURAL"
	GetUserAuthServersEndpointRequestSortFlagsSortFlagCase     GetUserAuthServersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetUserAuthServersEndpointRequestSortFlagsFromString(s string) (GetUserAuthServersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetUserAuthServersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetUserAuthServersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetUserAuthServersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetUserAuthServersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetUserAuthServersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetUserAuthServersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetUserAuthServersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetUserAuthServersEndpointRequestSortFlags) Ptr() *GetUserAuthServersEndpointRequestSortFlags {
	return &g
}

type GetUserAuthServersEndpointRequestSortOrder string

const (
	GetUserAuthServersEndpointRequestSortOrderSortAsc  GetUserAuthServersEndpointRequestSortOrder = "SORT_ASC"
	GetUserAuthServersEndpointRequestSortOrderSortDesc GetUserAuthServersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetUserAuthServersEndpointRequestSortOrderFromString(s string) (GetUserAuthServersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetUserAuthServersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetUserAuthServersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetUserAuthServersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetUserAuthServersEndpointRequestSortOrder) Ptr() *GetUserAuthServersEndpointRequestSortOrder {
	return &g
}

type GetUserAuthServersEndpointResponse struct {
	Data []*GetUserAuthServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserAuthServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserAuthServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserAuthServersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserAuthServersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserAuthServersEndpointResponseDataItem struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserAuthServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserAuthServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserAuthServersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserAuthServersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetUserEndpointRequestIDFromInteger(value int) *GetUserEndpointRequestID {
	return &GetUserEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetUserEndpointRequestIDFromString(value string) *GetUserEndpointRequestID {
	return &GetUserEndpointRequestID{typeName: "string", String: value}
}

func (g *GetUserEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetUserEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetUserEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetUserEndpointRequestID) Accept(visitor GetUserEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetUserEndpointResponse struct {
	Data *GetUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserEndpointResponseData struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserGroupEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetUserGroupEndpointRequestIDFromInteger(value int) *GetUserGroupEndpointRequestID {
	return &GetUserGroupEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetUserGroupEndpointRequestIDFromString(value string) *GetUserGroupEndpointRequestID {
	return &GetUserGroupEndpointRequestID{typeName: "string", String: value}
}

func (g *GetUserGroupEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetUserGroupEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetUserGroupEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetUserGroupEndpointRequestID) Accept(visitor GetUserGroupEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetUserGroupEndpointResponse struct {
	Data *GetUserGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserGroupEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserGroupEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserGroupEndpointResponseData struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserGroupEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserGroupEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserGroupsEndpointRequestSortFlags string

const (
	GetUserGroupsEndpointRequestSortFlagsSortRegular      GetUserGroupsEndpointRequestSortFlags = "SORT_REGULAR"
	GetUserGroupsEndpointRequestSortFlagsSortNumeric      GetUserGroupsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetUserGroupsEndpointRequestSortFlagsSortString       GetUserGroupsEndpointRequestSortFlags = "SORT_STRING"
	GetUserGroupsEndpointRequestSortFlagsSortLocaleString GetUserGroupsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetUserGroupsEndpointRequestSortFlagsSortNatural      GetUserGroupsEndpointRequestSortFlags = "SORT_NATURAL"
	GetUserGroupsEndpointRequestSortFlagsSortFlagCase     GetUserGroupsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetUserGroupsEndpointRequestSortFlagsFromString(s string) (GetUserGroupsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetUserGroupsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetUserGroupsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetUserGroupsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetUserGroupsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetUserGroupsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetUserGroupsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetUserGroupsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetUserGroupsEndpointRequestSortFlags) Ptr() *GetUserGroupsEndpointRequestSortFlags {
	return &g
}

type GetUserGroupsEndpointRequestSortOrder string

const (
	GetUserGroupsEndpointRequestSortOrderSortAsc  GetUserGroupsEndpointRequestSortOrder = "SORT_ASC"
	GetUserGroupsEndpointRequestSortOrderSortDesc GetUserGroupsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetUserGroupsEndpointRequestSortOrderFromString(s string) (GetUserGroupsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetUserGroupsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetUserGroupsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetUserGroupsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetUserGroupsEndpointRequestSortOrder) Ptr() *GetUserGroupsEndpointRequestSortOrder {
	return &g
}

type GetUserGroupsEndpointResponse struct {
	Data []*GetUserGroupsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserGroupsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserGroupsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserGroupsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserGroupsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserGroupsEndpointResponseDataItem struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUserGroupsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserGroupsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserGroupsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUserGroupsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUsersEndpointRequestSortFlags string

const (
	GetUsersEndpointRequestSortFlagsSortRegular      GetUsersEndpointRequestSortFlags = "SORT_REGULAR"
	GetUsersEndpointRequestSortFlagsSortNumeric      GetUsersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetUsersEndpointRequestSortFlagsSortString       GetUsersEndpointRequestSortFlags = "SORT_STRING"
	GetUsersEndpointRequestSortFlagsSortLocaleString GetUsersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetUsersEndpointRequestSortFlagsSortNatural      GetUsersEndpointRequestSortFlags = "SORT_NATURAL"
	GetUsersEndpointRequestSortFlagsSortFlagCase     GetUsersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetUsersEndpointRequestSortFlagsFromString(s string) (GetUsersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetUsersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetUsersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetUsersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetUsersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetUsersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetUsersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetUsersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetUsersEndpointRequestSortFlags) Ptr() *GetUsersEndpointRequestSortFlags {
	return &g
}

type GetUsersEndpointRequestSortOrder string

const (
	GetUsersEndpointRequestSortOrderSortAsc  GetUsersEndpointRequestSortOrder = "SORT_ASC"
	GetUsersEndpointRequestSortOrderSortDesc GetUsersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetUsersEndpointRequestSortOrderFromString(s string) (GetUsersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetUsersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetUsersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetUsersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetUsersEndpointRequestSortOrder) Ptr() *GetUsersEndpointRequestSortOrder {
	return &g
}

type GetUsersEndpointResponse struct {
	Data []*GetUsersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUsersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUsersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUsersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUsersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUsersEndpointResponseDataItem struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetUsersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUsersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUsersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetUsersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PatchUserAuthServerEndpointResponse struct {
	Data *PatchUserAuthServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchUserAuthServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchUserAuthServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchUserAuthServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchUserAuthServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchUserAuthServerEndpointResponseData struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchUserAuthServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchUserAuthServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchUserAuthServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchUserAuthServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchUserEndpointResponse struct {
	Data *PatchUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchUserEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchUserEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchUserEndpointResponseData struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchUserEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchUserEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchUserGroupEndpointResponse struct {
	Data *PatchUserGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchUserGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchUserGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchUserGroupEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchUserGroupEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchUserGroupEndpointResponseData struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchUserGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchUserGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchUserGroupEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchUserGroupEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostUserAuthServerEndpointResponse struct {
	Data *PostUserAuthServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostUserAuthServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostUserAuthServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostUserAuthServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostUserAuthServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostUserAuthServerEndpointResponseData struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostUserAuthServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostUserAuthServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostUserAuthServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostUserAuthServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostUserEndpointResponse struct {
	Data *PostUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostUserEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostUserEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostUserEndpointResponseData struct {
	// The username of this local user.<br>
	Name *string `json:"name,omitempty"`
	// The password of this local user.<br>
	Password *string `json:"password,omitempty"`
	// The UID of this local user. This value is automatically assigned and cannot be changed.<br>
	UID *int `json:"uid,omitempty"`
	// The scope of this local user. This value is automatically assigned and cannot be changed.<br>
	Scope *string `json:"scope,omitempty"`
	// The privileges assigned to this local user.<br>
	Priv []string `json:"priv,omitempty"`
	// Disable this local user.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The full descriptive name for this local user.<br>
	Descr *string `json:"descr,omitempty"`
	// The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration<br>
	Expires *string `json:"expires,omitempty"`
	// The user certificates to assign this user. Items must be existing certificate `refid`s.<br>
	Cert []string `json:"cert,omitempty"`
	// The SSH authorized keys to assign this user.<br>
	Authorizedkeys *string `json:"authorizedkeys,omitempty"`
	// The IPsec pre-shared key to assign this user.<br>
	Ipsecpsk *string `json:"ipsecpsk,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostUserEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostUserEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostUserGroupEndpointResponse struct {
	Data *PostUserGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostUserGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostUserGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostUserGroupEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostUserGroupEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostUserGroupEndpointResponseData struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostUserGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostUserGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostUserGroupEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostUserGroupEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutUserAuthServersEndpointRequestItem struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutUserAuthServersEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserAuthServersEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserAuthServersEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserAuthServersEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutUserAuthServersEndpointResponse struct {
	Data []*PutUserAuthServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutUserAuthServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserAuthServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserAuthServersEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserAuthServersEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutUserAuthServersEndpointResponseDataItem struct {
	// The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of this authentication server.<br>
	Type *AuthServerType `json:"type,omitempty"`
	// The descriptive name for this authentication server.<br>
	Name *string `json:"name,omitempty"`
	// The remote IP address or hostname of the authentication server.<br>
	Host *string `json:"host,omitempty"`
	// The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPort *string `json:"ldap_port,omitempty"`
	// The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUrltype *AuthServerLdapUrltype `json:"ldap_urltype,omitempty"`
	// The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapProtver *int `json:"ldap_protver,omitempty"`
	// The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapTimeout *int `json:"ldap_timeout,omitempty"`
	// The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>
	LdapCaref *string `json:"ldap_caref,omitempty"`
	// The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapScope *AuthServerLdapScope `json:"ldap_scope,omitempty"`
	// The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBasedn *string `json:"ldap_basedn,omitempty"`
	// The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAuthcn *string `json:"ldap_authcn,omitempty"`
	// Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapExtendedEnabled *bool `json:"ldap_extended_enabled,omitempty"`
	// The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>
	LdapExtendedQuery *string `json:"ldap_extended_query,omitempty"`
	// The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapBinddn *string `json:"ldap_binddn,omitempty"`
	// The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>
	LdapBindpw *string `json:"ldap_bindpw,omitempty"`
	// The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrUser *string `json:"ldap_attr_user,omitempty"`
	// The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrGroup *string `json:"ldap_attr_group,omitempty"`
	// The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAttrMember *string `json:"ldap_attr_member,omitempty"`
	// Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapRfc2307 *bool `json:"ldap_rfc2307,omitempty"`
	// Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapRfc2307Userdn *bool `json:"ldap_rfc2307_userdn,omitempty"`
	// The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>
	LdapAttrGroupobj *string `json:"ldap_attr_groupobj,omitempty"`
	// The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapPamGroupdn *string `json:"ldap_pam_groupdn,omitempty"`
	// Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapUtf8 *bool `json:"ldap_utf8,omitempty"`
	// Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapNostripAt *bool `json:"ldap_nostrip_at,omitempty"`
	// Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>
	LdapAllowUnauthenticated *bool `json:"ldap_allow_unauthenticated,omitempty"`
	// The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusSecret *string `json:"radius_secret,omitempty"`
	// The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAuthPort *string `json:"radius_auth_port,omitempty"`
	// The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusAcctPort *string `json:"radius_acct_port,omitempty"`
	// The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusProtocol *AuthServerRadiusProtocol `json:"radius_protocol,omitempty"`
	// The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusTimeout *int `json:"radius_timeout,omitempty"`
	// The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>
	RadiusNasipAttribute *string `json:"radius_nasip_attribute,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutUserAuthServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserAuthServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserAuthServersEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserAuthServersEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutUserGroupsEndpointRequestItem struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutUserGroupsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserGroupsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserGroupsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserGroupsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutUserGroupsEndpointResponse struct {
	Data []*PutUserGroupsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutUserGroupsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserGroupsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserGroupsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserGroupsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutUserGroupsEndpointResponseDataItem struct {
	// The name for this user group.<br>
	Name *string `json:"name,omitempty"`
	// The GID of this user group. This value is automatically assigned and cannot be changed.<br>
	Gid *int `json:"gid,omitempty"`
	// The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually.<br>
	Scope *UserGroupScope `json:"scope,omitempty"`
	// The description to assign to this user group.<br>
	Description *string `json:"description,omitempty"`
	// The local user names to assign to this user group.<br>
	Member []string `json:"member,omitempty"`
	// The privileges to assign to this user group.<br>
	Priv []string `json:"priv,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutUserGroupsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutUserGroupsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutUserGroupsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutUserGroupsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
