// This file was auto-generated by Fern from our API Definition.

package pfclientapi

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/danielmichaels/go-pfrest/pkg/client/core"
)

type DeleteServicesAcmeAccountKeyEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesAcmeAccountKeysEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesAcmeCertificateActionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesAcmeCertificateDomainEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesAcmeCertificateEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesAcmeCertificatesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesBindAccessListEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesBindAccessListEntriesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesBindAccessListEntryEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesBindAccessListsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesBindSyncRemoteHostEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesBindSyncRemoteHostsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesBindViewEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesBindViewsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesBindZoneEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesBindZoneRecordEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesBindZonesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesCronJobEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesCronJobsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDhcpServerAddressPoolEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDhcpServerAddressPoolsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDhcpServerCustomOptionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDhcpServerCustomOptionsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDhcpServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDhcpServerStaticMappingEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDhcpServerStaticMappingsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDNSForwarderHostOverrideAliasEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDNSForwarderHostOverrideAliasesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDNSForwarderHostOverrideEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDNSForwarderHostOverridesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDNSResolverAccessListEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDNSResolverAccessListNetworkEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDNSResolverAccessListNetworksEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDNSResolverAccessListsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDNSResolverDomainOverrideEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDNSResolverDomainOverridesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDNSResolverHostOverrideAliasEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDNSResolverHostOverrideAliasesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesDNSResolverHostOverrideEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteServicesDNSResolverHostOverridesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesFreeRadiusClientEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesFreeRadiusClientsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesFreeRadiusInterfaceEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesFreeRadiusInterfacesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesFreeRadiusUserEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesFreeRadiusUsersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyBackendACLEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyBackendAcLsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyBackendActionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyBackendActionsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyBackendEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyBackendErrorFileEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyBackendErrorFilesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyBackendServerEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyBackendServersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyBackendsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyFileEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyFilesRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyFrontendACLEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyFrontendAcLsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyFrontendActionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyFrontendActionsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyFrontendAddressEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyFrontendAddressesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyFrontendCertificateEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyFrontendCertificatesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyFrontendEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyFrontendErrorFileEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxyFrontendErrorFilesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxyFrontendsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxySettingsDNSResolverEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxySettingsDNSResolversEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesHaProxySettingsEmailMailerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesHaProxySettingsEmailMailersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesNtpTimeServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesNtpTimeServersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteServicesServiceWatchdogEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteServicesServiceWatchdogsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesAcmeAccountKeyEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesAcmeAccountKeyRegistrationsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesAcmeAccountKeysEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesAcmeAccountKeysEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesAcmeAccountKeysEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesAcmeCertificateActionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesAcmeCertificateDomainEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesAcmeCertificateEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesAcmeCertificateIssuancesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesAcmeCertificateRenewalsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesAcmeCertificatesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesAcmeCertificatesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesAcmeCertificatesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesBindAccessListEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesBindAccessListEntriesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesBindAccessListEntriesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesBindAccessListEntriesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesBindAccessListEntryEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesBindAccessListsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesBindAccessListsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesBindAccessListsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesBindSyncRemoteHostEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesBindSyncRemoteHostsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesBindSyncRemoteHostsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesBindSyncRemoteHostsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesBindViewEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesBindViewsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesBindViewsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesBindViewsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesBindZoneEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesBindZoneRecordEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesBindZonesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesBindZonesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesBindZonesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesCronJobEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesCronJobsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesCronJobsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesCronJobsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDhcpServerAddressPoolEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDhcpServerAddressPoolsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDhcpServerCustomOptionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDhcpServerCustomOptionsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDhcpServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDhcpServerStaticMappingEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDhcpServerStaticMappingsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDhcpServersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDhcpServersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDhcpServersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDNSForwarderHostOverrideAliasEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDNSForwarderHostOverrideAliasesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDNSForwarderHostOverrideEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDNSForwarderHostOverridesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDNSResolverAccessListEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDNSResolverAccessListNetworkEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDNSResolverAccessListNetworksEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDNSResolverAccessListsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDNSResolverAccessListsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDNSResolverAccessListsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDNSResolverDomainOverrideEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDNSResolverDomainOverridesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDNSResolverHostOverrideAliasEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDNSResolverHostOverrideAliasesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesDNSResolverHostOverrideEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesDNSResolverHostOverridesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesDNSResolverHostOverridesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesDNSResolverHostOverridesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesFreeRadiusClientEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesFreeRadiusClientsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesFreeRadiusClientsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesFreeRadiusClientsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesFreeRadiusInterfaceEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesFreeRadiusInterfacesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesFreeRadiusInterfacesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesFreeRadiusInterfacesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesFreeRadiusUserEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesFreeRadiusUsersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesFreeRadiusUsersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesFreeRadiusUsersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyBackendACLEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyBackendAcLsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyBackendAcLsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyBackendAcLsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyBackendActionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyBackendActionsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyBackendActionsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyBackendActionsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyBackendEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyBackendErrorFileEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyBackendErrorFilesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyBackendServerEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyBackendServersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyBackendServersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyBackendServersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyBackendsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyBackendsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyBackendsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyFileEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyFilesRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyFilesRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyFilesRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyFrontendACLEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyFrontendAcLsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyFrontendActionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyFrontendActionsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyFrontendActionsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyFrontendActionsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyFrontendAddressEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyFrontendAddressesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyFrontendCertificateEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyFrontendCertificatesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyFrontendEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyFrontendErrorFileEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxyFrontendErrorFilesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxyFrontendsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxyFrontendsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxyFrontendsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxySettingsDNSResolverEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxySettingsDNSResolversEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesHaProxySettingsEmailMailerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesHaProxySettingsEmailMailersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesNtpTimeServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesNtpTimeServersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesNtpTimeServersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesNtpTimeServersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetServicesServiceWatchdogEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetServicesServiceWatchdogsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetServicesServiceWatchdogsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetServicesServiceWatchdogsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type PatchServicesAcmeAccountKeyEndpointRequest struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesAcmeCertificateActionEndpointRequest struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method *AcmeCertificateActionMethod `json:"method,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesAcmeCertificateDomainEndpointRequest struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesAcmeCertificateEndpointRequest struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesAcmeSettingsEndpointRequest struct {
	// Enables or disables the ACME renewal job.<br>
	Enable *bool `json:"enable,omitempty"`
	// Enables or disables the writing of certificates to /conf/acme/ in various formats for use by other scripts or daemons which do not integrate with the pfSense certificate manager.<br>
	Writecerts *bool `json:"writecerts,omitempty"`
}

type PatchServicesBindAccessListEndpointRequest struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesBindAccessListEntryEndpointRequest struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesBindSettingsEndpointRequest struct {
	// Enables the BIND service.<br>
	EnableBind *bool `json:"enable_bind,omitempty"`
	// The IP version to use for the BIND service. Leave empty to use both IPv4 and IPv6.<br>
	BindIPVersion *BindSettingsBindIPVersion `json:"bind_ip_version,omitempty"`
	// The interfaces to listen on for DNS requests.<br>
	Listenon []string `json:"listenon,omitempty"`
	// Notify slave server after any update on master.<br>
	BindNotify *bool `json:"bind_notify,omitempty"`
	// Hide the BIND version in responses.<br>
	BindHideVersion *bool `json:"bind_hide_version,omitempty"`
	// The maximum amount of RAM to use for the BIND service.<br>
	BindRAMLimit *string `json:"bind_ram_limit,omitempty"`
	// Enable logging for the BIND service.<br>
	BindLogging *bool `json:"bind_logging,omitempty"`
	// The minimum severity of events to log.<br>
	LogSeverity *BindSettingsLogSeverity `json:"log_severity,omitempty"`
	// The categories to log.<br>
	LogOptions []BindSettingsLogOptionsItem `json:"log_options,omitempty"`
	// Enable rate limiting for the BIND service.<br>
	RateEnabled *bool `json:"rate_enabled,omitempty"`
	// The maximum number of queries per second to allow.<br><br>This field is only available when the following conditions are met:<br>- `rate_enabled` must be equal to `true`<br>
	RateLimit *int `json:"rate_limit,omitempty"`
	// When rate limiting, only log that the query limit has been exceeded. If disabled, the query will be dropped instead.<br>
	LogOnly *bool `json:"log_only,omitempty"`
	// Enable forwarding queries to other DNS servers listed below rather than this server performing its own recursion.<br>
	BindForwarder *bool `json:"bind_forwarder,omitempty"`
	// The IP addresses of the DNS servers to forward queries to.<br><br>This field is only available when the following conditions are met:<br>- `bind_forwarder` must be equal to `true`<br>
	BindForwarderIps []string `json:"bind_forwarder_ips,omitempty"`
	// Enable DNSSEC validation when BIND is acting as a recursive resolver.<br>
	BindDnssecValidation *BindSettingsBindDnssecValidation `json:"bind_dnssec_validation,omitempty"`
	// The TCP and UDP port to listen on for DNS requests. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The TCP port to listen on for control requests (localhost only). Valid options are: a TCP/UDP port number<br>
	Controlport *string `json:"controlport,omitempty"`
	// Custom BIND options to include in the configuration file.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	// Global BIND settings to include in the configuration file.<br>
	BindGlobalSettings *string `json:"bind_global_settings,omitempty"`
}

type PatchServicesBindSyncRemoteHostEndpointRequest struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesBindSyncSettingsEndpointRequest struct {
	// The sync mode to use.<br>
	Synconchanges *BindSyncSettingsSynconchanges `json:"synconchanges,omitempty"`
	// The timeout for the sync process.<br>
	Synctimeout *int `json:"synctimeout,omitempty"`
	// The IP address of the master BIND server.<br>
	Masterip *string `json:"masterip,omitempty"`
}

type PatchServicesBindViewEndpointRequest struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesBindZoneEndpointRequest struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesBindZoneRecordEndpointRequest struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesCronJobEndpointRequest struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDhcpRelayEndpointRequest struct {
	// Enables or disables the DHCP relay.<br>
	Enable *bool `json:"enable,omitempty"`
	// The downstream interfaces to listen on for DHCP requests.<br>
	Interface []string `json:"interface,omitempty"`
	// Enables or disables appending the circuit ID (interface number) and the agent ID to the DHCP request.<br>
	Agentoption *bool `json:"agentoption,omitempty"`
	// DHCP Relay will be stopped when the chosen VIP is in BACKUP status, and started in MASTER status.<br>
	Carpstatusvip *string `json:"carpstatusvip,omitempty"`
	// The IPv4 addresses of the DHCP server to relay requests to.<br>
	Server []string `json:"server,omitempty"`
}

type PatchServicesDhcpServerAddressPoolEndpointRequest struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDhcpServerBackendEndpointRequest struct {
	// The backend DHCP server service to use. ISC DHCP is deprecate and will be removed in a future version of pfSense.<br>
	Dhcpbackend *DhcpServerBackendDhcpbackend `json:"dhcpbackend,omitempty"`
}

type PatchServicesDhcpServerCustomOptionEndpointRequest struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value *string `json:"value,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDhcpServerEndpointRequest struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDhcpServerStaticMappingEndpointRequest struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSForwarderHostOverrideAliasEndpointRequest struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSForwarderHostOverrideEndpointRequest struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSResolverAccessListEndpointRequest struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSResolverAccessListNetworkEndpointRequest struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSResolverDomainOverrideEndpointRequest struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSResolverHostOverrideAliasEndpointRequest struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSResolverHostOverrideEndpointRequest struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesDNSResolverSettingsEndpointRequest struct {
	// Enables or disables the DNS Resolver service.<br>
	Enable *bool `json:"enable,omitempty"`
	// The port on which the DNS Resolver service listens. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// Enables or disables SSL/TLS for the DNS Resolver service.<br>
	Enablessl *bool `json:"enablessl,omitempty"`
	// The SSL/TLS certificate to use for the DNS Resolver service.<br><br>This field is only available when the following conditions are met:<br>- `enablessl` must be equal to `true`<br>
	Sslcertref *string `json:"sslcertref,omitempty"`
	// The port on which the DNS Resolver service listens for SSL/TLS connections. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `enablessl` must be equal to `true`<br>
	Tlsport *string `json:"tlsport,omitempty"`
	// The interface on which the DNS Resolver service listens for DNS queries. Set empty value ".
	//
	//	"to listen on all interfaces.<br>
	ActiveInterface []string `json:"active_interface,omitempty"`
	// The interface on which the DNS Resolver service sends outgoing DNS queries. Set empty value ".
	//
	//	"to use any interface.<br>
	OutgoingInterface []string `json:"outgoing_interface,omitempty"`
	// Enables or disables sending recursive queries if none of the selected Outgoing Network ".
	//
	//	"Interfaces are available.<br>
	Strictout *bool `json:"strictout,omitempty"`
	// The type of local zone used for the system domain.<br>
	SystemDomainLocalZoneType *DNSResolverSettingsSystemDomainLocalZoneType `json:"system_domain_local_zone_type,omitempty"`
	// Enables or disables DNSSEC validation.<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enables or disables the Python module.<br>
	Python *bool `json:"python,omitempty"`
	// The order in which the Python module is loaded.<br><br>This field is only available when the following conditions are met:<br>- `python` must be equal to `true`<br>
	PythonOrder *DNSResolverSettingsPythonOrder `json:"python_order,omitempty"`
	// The Python module to utilize.<br><br>This field is only available when the following conditions are met:<br>- `python` must be equal to `true`<br>
	PythonScript *string `json:"python_script,omitempty"`
	// Enables or disables DNS Resolver forwarding mode.<br>
	Forwarding *bool `json:"forwarding,omitempty"`
	// Enables or disables registering DHCP leases in the DNS Resolver service.<br>
	Regdhcp *bool `json:"regdhcp,omitempty"`
	// Enables or disables registering static DHCP mappings in the DNS Resolver service.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Enables or disables registering OpenVPN clients in the DNS Resolver service.<br>
	Regovpnclients *bool `json:"regovpnclients,omitempty"`
	// Custom options to add to the DNS Resolver configuration.<br>
	CustomOptions *string `json:"custom_options,omitempty"`
}

type PatchServicesFreeRadiusClientEndpointRequest struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesFreeRadiusInterfaceEndpointRequest struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesFreeRadiusUserEndpointRequest struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyBackendACLEndpointRequest struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyBackendActionEndpointRequest struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyBackendEndpointRequest struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyBackendErrorFileEndpointRequest struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyBackendServerEndpointRequest struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyFileEndpointRequest struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyFrontendACLEndpointRequest struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyFrontendActionEndpointRequest struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyFrontendAddressEndpointRequest struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyFrontendCertificateEndpointRequest struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyFrontendEndpointRequest struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxyFrontendErrorFileEndpointRequest struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxySettingsDNSResolverEndpointRequest struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxySettingsEmailMailerEndpointRequest struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesHaProxySettingsEndpointRequest struct {
	// Enables or disable HAProxy on the system.<br>
	Enable *bool `json:"enable,omitempty"`
	// The maximum per-process number of concurrent connections<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// The number of threads to start per process. This setting is experimental.<br>
	Nbthread *int `json:"nbthread,omitempty"`
	// Enables or disables an immediate stop of old process on reload. (closes existing connections)<br>
	TerminateOnReload *bool `json:"terminate_on_reload,omitempty"`
	// The maximum time allowed to perform a clean soft-stop. This can be represented as different time values such as 30s, 15m, 3h or 1d.<br>
	HardStopAfter *string `json:"hard_stop_after,omitempty"`
	// The CARP interface IP to monitor. HAProxy will only run on the firewall whose interface is MASTER.<br>
	Carpdev *string `json:"carpdev,omitempty"`
	// The internal port to be used for the stats tab. Set to null to disable local stats. Valid options are: a TCP/UDP port number<br>
	Localstatsport *string `json:"localstatsport,omitempty"`
	// The internal (in seconds) in which local stats will be refreshed.<br>
	LocalstatsRefreshtime *int `json:"localstats_refreshtime,omitempty"`
	// The internal (in seconds) in which the sticktable stats will be refreshed.<br>
	LocalstatsSticktableRefreshtime *int `json:"localstats_sticktable_refreshtime,omitempty"`
	// The IP address or hostname of the remote syslog server to send logs to. Use `/var/run/log` to to log to the local pfSense system log.<br>
	Remotesyslog *string `json:"remotesyslog,omitempty"`
	// The logging facility to log to.<br>
	Logfacility *HaProxySettingsLogfacility `json:"logfacility,omitempty"`
	// The log level to begin logging events. Only events of this level or higher will be logged.<br>
	Loglevel *HaProxySettingsLoglevel `json:"loglevel,omitempty"`
	// The hostname field to include in the syslog header. Leave empty to use the system hostname.<br>
	LogSendHostname *string `json:"log_send_hostname,omitempty"`
	// The DNS resolvers HAProxy will use for DNS queries.<br>
	DNSResolvers []*HaProxySettingsDNSResolversItem `json:"dns_resolvers,omitempty"`
	// The number of queries to send to resolve a server name before giving up.<br>
	ResolverRetries *int `json:"resolver_retries,omitempty"`
	// The time between two DNS queries, when no response have been received.<br>
	ResolverTimeoutretry *string `json:"resolver_timeoutretry,omitempty"`
	// The interval between two successive name resolution when the last answer was valid.<br>
	ResolverHoldvalid *string `json:"resolver_holdvalid,omitempty"`
	// The email servers HAProxy will use to send SMTP alerts.<br>
	EmailMailers []*HaProxySettingsEmailMailersItem `json:"email_mailers,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts.<br>
	EmailLevel *HaProxySettingsEmailLevel `json:"email_level,omitempty"`
	// The hostname to use as the origin of the email.<br>
	EmailMyhostname *string `json:"email_myhostname,omitempty"`
	// The email address to be used as the sender of the emails.<br>
	EmailFrom *string `json:"email_from,omitempty"`
	// The email address to send emails to.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// The SSL/TLS compatibility mode which determines the cipher suites and TLS versions supported.<br>
	Sslcompatibilitymode *HaProxySettingsSslcompatibilitymode `json:"sslcompatibilitymode,omitempty"`
	// The maximum size of the Diffie-Hellman parameters used for generating the ephemeral/temporary Diffie-Hellman key in case of DHE key exchange<br>
	Ssldefaultdhparam *int `json:"ssldefaultdhparam,omitempty"`
	// Additional HAProxy options to include in the global settings area.<br>
	Advanced *string `json:"advanced,omitempty"`
	// Enables or disables including HAProxy configurations in HA sync if configured.<br>
	Enablesync *bool `json:"enablesync,omitempty"`
}

type PatchServicesNtpSettingsEndpointRequest struct {
	// Enables or disabled the NTP server.<br>
	Enable *bool `json:"enable,omitempty"`
	// The interfaces the NTP server will listen on.<br>
	Interface []string `json:"interface,omitempty"`
	// The maximum number of candidate peers in the NTP pool.<br>
	Ntpmaxpeers *int `json:"ntpmaxpeers,omitempty"`
	// The orphan mode stratum to set. Orphan mode allows the system clock to be used when no other clocks are available. The number here specifies the stratum reported during orphan mode and should normally be set to a number high enough to ensure that any other servers available to clients are preferred over this server<br>
	Orphan *int `json:"orphan,omitempty"`
	// The minimum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value.<br>
	Ntpminpoll *NtpSettingsNtpminpoll `json:"ntpminpoll,omitempty"`
	// The maximum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value. This value must be greater than the `ntpminpoll`.<br>
	Ntpmaxpoll *NtpSettingsNtpmaxpoll `json:"ntpmaxpoll,omitempty"`
	// The IP protocol peers are forced to use for DNS resolution.<br>
	Dnsresolv *NtpSettingsDnsresolv `json:"dnsresolv,omitempty"`
	// Enable or disable logging peer messages.<br>
	Logpeer *bool `json:"logpeer,omitempty"`
	// Enable or disable logging system messages.<br>
	Logsys *bool `json:"logsys,omitempty"`
	// Enable or disable logging reference clock statistics.<br>
	Clockstats *bool `json:"clockstats,omitempty"`
	// Enable or disable logging clock discipline statistics.<br>
	Loopstats *bool `json:"loopstats,omitempty"`
	// Enable or disable logging peer statistics.<br>
	Peerstats *bool `json:"peerstats,omitempty"`
	// Enable or disable RRD graphs for NTP statistics.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// The Leap second configuration as text.<br>
	Leapsec *string `json:"leapsec,omitempty"`
	// Enable or disable NTPv3 server authentication. (RFC 1305)<br>
	Serverauth *bool `json:"serverauth,omitempty"`
	// The NTP server authentication key.<br><br>This field is only available when the following conditions are met:<br>- `serverauth` must be equal to `true`<br>
	Serverauthkey *string `json:"serverauthkey,omitempty"`
	// The digest algorithm for the server authentication key.<br>
	Serverauthalgo *NtpSettingsServerauthalgo `json:"serverauthalgo,omitempty"`
}

type PatchServicesNtpTimeServerEndpointRequest struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchServicesSSHEndpointRequest struct {
	// Enable the SSH server on this system.<br>
	Enable *bool `json:"enable,omitempty"`
	// The TCP port the SSH server will listen on. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The SSH authentication mode to use. Use `enabled` to require public key authentication, use both to require both a public key AND a password, or use `null` to allow a password OR a public key.<br>
	Sshdkeyonly *SSHSshdkeyonly `json:"sshdkeyonly,omitempty"`
	// Enable support for ssh-agent forwarding.<br>
	Sshdagentforwarding *bool `json:"sshdagentforwarding,omitempty"`
}

type PatchServicesServiceWatchdogEndpointRequest struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PostServicesAcmeAccountKeyEndpointRequest struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
}

type PostServicesAcmeAccountKeyRegisterEndpointRequest struct {
	// The name of the ACME account key to register.<br>
	Name *string `json:"name,omitempty"`
	// The registration status of the ACME account key. This will show 'pending' if the registration process is still running, 'registered' if the registration was successful, 'failed' if the registration failed, and 'unknown' if the registration status is not known. Note: This status can only be determined for registrations initiated through the REST API.<br>
	Status *string `json:"status,omitempty"`
}

type PostServicesAcmeCertificateActionEndpointRequest struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method *AcmeCertificateActionMethod `json:"method,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesAcmeCertificateDomainEndpointRequest struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesAcmeCertificateEndpointRequest struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
}

type PostServicesAcmeCertificateIssueEndpointRequest struct {
	// The name of the ACME certificate to be issued.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate issue process. This will show 'pending' if the issue process is still running or 'completed' if the issue process has finished. This status only indicates whether the issue process has completed, not whether it was successful. You will needto refer to the result log for that information.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate issue status last changed.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh issue command.<br>
	ResultLog *string `json:"result_log,omitempty"`
}

type PostServicesAcmeCertificateRenewEndpointRequest struct {
	// The name of the ACME certificate to be renewed.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate renew process. This will show 'pending' if the renew process is still running or 'completed' if the renew process has finished. This status only indicates whether the renew process has completed, not whether it was successful. You will needto refer to the result log for that information. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate renew status last changed. Note: This timestamp is only updated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh renew command. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	ResultLog *string `json:"result_log,omitempty"`
}

type PostServicesBindAccessListEndpointRequest struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
}

type PostServicesBindAccessListEntryEndpointRequest struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesBindSyncRemoteHostEndpointRequest struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
}

type PostServicesBindViewEndpointRequest struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
}

type PostServicesBindZoneEndpointRequest struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
}

type PostServicesBindZoneRecordEndpointRequest struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesCronJobEndpointRequest struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
}

type PostServicesDhcpServerAddressPoolEndpointRequest struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesDhcpServerApplyEndpointRequest struct {
	// Displays `true` if all DHCP server changes are applied and there are no pending changes left.Displays `false` when there are pending DHCP server changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
}

type PostServicesDhcpServerCustomOptionEndpointRequest struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value *string `json:"value,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesDhcpServerEndpointRequest struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
}

type PostServicesDhcpServerStaticMappingEndpointRequest struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesDNSForwarderApplyEndpointRequest struct {
	// Displays `true` when all DNS Forwarder changes are applied and there are no pending changes left.Displays `false` when there are pending DNS Forwarder changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
}

type PostServicesDNSForwarderHostOverrideAliasEndpointRequest struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesDNSForwarderHostOverrideEndpointRequest struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
}

type PostServicesDNSResolverAccessListEndpointRequest struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
}

type PostServicesDNSResolverAccessListNetworkEndpointRequest struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesDNSResolverApplyEndpointRequest struct {
	// Displays `true` when all DNS Resolver changes are applied and there are no pending changes left.Displays `false` when there are pending DNS Resolver changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
}

type PostServicesDNSResolverDomainOverrideEndpointRequest struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
}

type PostServicesDNSResolverHostOverrideAliasEndpointRequest struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesDNSResolverHostOverrideEndpointRequest struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
}

type PostServicesFreeRadiusClientEndpointRequest struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
}

type PostServicesFreeRadiusInterfaceEndpointRequest struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
}

type PostServicesFreeRadiusUserEndpointRequest struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
}

type PostServicesHaProxyApplyEndpointRequest struct {
	// Indicates whether all HAProxy configuration changes have been applied.<br>
	Applied *bool `json:"applied,omitempty"`
}

type PostServicesHaProxyBackendACLEndpointRequest struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyBackendActionEndpointRequest struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyBackendEndpointRequest struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
}

type PostServicesHaProxyBackendErrorFileEndpointRequest struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyBackendServerEndpointRequest struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyFileEndpointRequest struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
}

type PostServicesHaProxyFrontendACLEndpointRequest struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyFrontendActionEndpointRequest struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyFrontendAddressEndpointRequest struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyFrontendCertificateEndpointRequest struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxyFrontendEndpointRequest struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
}

type PostServicesHaProxyFrontendErrorFileEndpointRequest struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostServicesHaProxySettingsDNSResolverEndpointRequest struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
}

type PostServicesHaProxySettingsEmailMailerEndpointRequest struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
}

type PostServicesNtpTimeServerEndpointRequest struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
}

type PostServicesServiceWatchdogEndpointRequest struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
}

type PostServicesWakeOnLanSendEndpointRequest struct {
	// The interface the host to be woken up is connected to.<br>
	Interface *string `json:"interface,omitempty"`
	// The MAC address of the host to be awoken.<br>
	MacAddr *string `json:"mac_addr,omitempty"`
}

type AcmeAccountKey struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeAccountKey) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeAccountKey
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeAccountKey(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeAccountKey) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcmeAccountKeyRegister struct {
	// The name of the ACME account key to register.<br>
	Name *string `json:"name,omitempty"`
	// The registration status of the ACME account key. This will show 'pending' if the registration process is still running, 'registered' if the registration was successful, 'failed' if the registration failed, and 'unknown' if the registration status is not known. Note: This status can only be determined for registrations initiated through the REST API.<br>
	Status *string `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeAccountKeyRegister) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeAccountKeyRegister
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeAccountKeyRegister(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeAccountKeyRegister) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcmeCertificate struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeCertificate) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeCertificate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeCertificate(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeCertificate) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcmeCertificateAActionlistItem struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method *AcmeCertificateActionMethod `json:"method,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeCertificateAActionlistItem) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeCertificateAActionlistItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeCertificateAActionlistItem(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeCertificateAActionlistItem) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcmeCertificateADomainlistItem struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeCertificateADomainlistItem) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeCertificateADomainlistItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeCertificateADomainlistItem(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeCertificateADomainlistItem) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcmeCertificateAction struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method *AcmeCertificateActionMethod `json:"method,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeCertificateAction) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeCertificateAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeCertificateAction(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeCertificateAction) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The action method that should be used to run the command.<br>
type AcmeCertificateActionMethod string

const (
	AcmeCertificateActionMethodShellcommand         AcmeCertificateActionMethod = "shellcommand"
	AcmeCertificateActionMethodPhpCommand           AcmeCertificateActionMethod = "php_command"
	AcmeCertificateActionMethodServicerestart       AcmeCertificateActionMethod = "servicerestart"
	AcmeCertificateActionMethodXmlrpcservicerestart AcmeCertificateActionMethod = "xmlrpcservicerestart"
)

func NewAcmeCertificateActionMethodFromString(s string) (AcmeCertificateActionMethod, error) {
	switch s {
	case "shellcommand":
		return AcmeCertificateActionMethodShellcommand, nil
	case "php_command":
		return AcmeCertificateActionMethodPhpCommand, nil
	case "servicerestart":
		return AcmeCertificateActionMethodServicerestart, nil
	case "xmlrpcservicerestart":
		return AcmeCertificateActionMethodXmlrpcservicerestart, nil
	}
	var t AcmeCertificateActionMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateActionMethod) Ptr() *AcmeCertificateActionMethod {
	return &a
}

// The activation status of the ACME certificate.<br>
type AcmeCertificateActionStatus string

const (
	AcmeCertificateActionStatusActive   AcmeCertificateActionStatus = "active"
	AcmeCertificateActionStatusDisabled AcmeCertificateActionStatus = "disabled"
)

func NewAcmeCertificateActionStatusFromString(s string) (AcmeCertificateActionStatus, error) {
	switch s {
	case "active":
		return AcmeCertificateActionStatusActive, nil
	case "disabled":
		return AcmeCertificateActionStatusDisabled, nil
	}
	var t AcmeCertificateActionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateActionStatus) Ptr() *AcmeCertificateActionStatus {
	return &a
}

type AcmeCertificateDomain struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeCertificateDomain) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeCertificateDomain
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeCertificateDomain(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeCertificateDomain) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
type AcmeCertificateDomainNsupdateKeyalgo string

const (
	AcmeCertificateDomainNsupdateKeyalgoEmptyValue0 AcmeCertificateDomainNsupdateKeyalgo = "empty_value_0"
	AcmeCertificateDomainNsupdateKeyalgoValue157    AcmeCertificateDomainNsupdateKeyalgo = "value_157"
	AcmeCertificateDomainNsupdateKeyalgoValue165    AcmeCertificateDomainNsupdateKeyalgo = "value_165"
	AcmeCertificateDomainNsupdateKeyalgoValue164    AcmeCertificateDomainNsupdateKeyalgo = "value_164"
	AcmeCertificateDomainNsupdateKeyalgoValue163    AcmeCertificateDomainNsupdateKeyalgo = "value_163"
	AcmeCertificateDomainNsupdateKeyalgoValue162    AcmeCertificateDomainNsupdateKeyalgo = "value_162"
	AcmeCertificateDomainNsupdateKeyalgoValue161    AcmeCertificateDomainNsupdateKeyalgo = "value_161"
)

func NewAcmeCertificateDomainNsupdateKeyalgoFromString(s string) (AcmeCertificateDomainNsupdateKeyalgo, error) {
	switch s {
	case "empty_value_0":
		return AcmeCertificateDomainNsupdateKeyalgoEmptyValue0, nil
	case "value_157":
		return AcmeCertificateDomainNsupdateKeyalgoValue157, nil
	case "value_165":
		return AcmeCertificateDomainNsupdateKeyalgoValue165, nil
	case "value_164":
		return AcmeCertificateDomainNsupdateKeyalgoValue164, nil
	case "value_163":
		return AcmeCertificateDomainNsupdateKeyalgoValue163, nil
	case "value_162":
		return AcmeCertificateDomainNsupdateKeyalgoValue162, nil
	case "value_161":
		return AcmeCertificateDomainNsupdateKeyalgoValue161, nil
	}
	var t AcmeCertificateDomainNsupdateKeyalgo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateDomainNsupdateKeyalgo) Ptr() *AcmeCertificateDomainNsupdateKeyalgo {
	return &a
}

// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
type AcmeCertificateDomainNwAPIEndpoint string

const (
	AcmeCertificateDomainNwAPIEndpointEmptyValue0             AcmeCertificateDomainNwAPIEndpoint = "empty_value_0"
	AcmeCertificateDomainNwAPIEndpointHTTPSPortalNexcessNet   AcmeCertificateDomainNwAPIEndpoint = "https://portal.nexcess.net"
	AcmeCertificateDomainNwAPIEndpointHTTPSCoreThermoIo       AcmeCertificateDomainNwAPIEndpoint = "https://core.thermo.io"
	AcmeCertificateDomainNwAPIEndpointHTTPSMyFuturehostingCom AcmeCertificateDomainNwAPIEndpoint = "https://my.futurehosting.com"
)

func NewAcmeCertificateDomainNwAPIEndpointFromString(s string) (AcmeCertificateDomainNwAPIEndpoint, error) {
	switch s {
	case "empty_value_0":
		return AcmeCertificateDomainNwAPIEndpointEmptyValue0, nil
	case "https://portal.nexcess.net":
		return AcmeCertificateDomainNwAPIEndpointHTTPSPortalNexcessNet, nil
	case "https://core.thermo.io":
		return AcmeCertificateDomainNwAPIEndpointHTTPSCoreThermoIo, nil
	case "https://my.futurehosting.com":
		return AcmeCertificateDomainNwAPIEndpointHTTPSMyFuturehostingCom, nil
	}
	var t AcmeCertificateDomainNwAPIEndpoint
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateDomainNwAPIEndpoint) Ptr() *AcmeCertificateDomainNwAPIEndpoint {
	return &a
}

// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
type AcmeCertificateDomainOvhEndPoint string

const (
	AcmeCertificateDomainOvhEndPointEmptyValue0  AcmeCertificateDomainOvhEndPoint = "empty_value_0"
	AcmeCertificateDomainOvhEndPointOvhEu        AcmeCertificateDomainOvhEndPoint = "ovh-eu"
	AcmeCertificateDomainOvhEndPointOvhCa        AcmeCertificateDomainOvhEndPoint = "ovh-ca"
	AcmeCertificateDomainOvhEndPointKimsufiEu    AcmeCertificateDomainOvhEndPoint = "kimsufi-eu"
	AcmeCertificateDomainOvhEndPointKimsufiCa    AcmeCertificateDomainOvhEndPoint = "kimsufi-ca"
	AcmeCertificateDomainOvhEndPointSoyoustartEu AcmeCertificateDomainOvhEndPoint = "soyoustart-eu"
	AcmeCertificateDomainOvhEndPointSoyoustartCa AcmeCertificateDomainOvhEndPoint = "soyoustart-ca"
	AcmeCertificateDomainOvhEndPointRunaboveCa   AcmeCertificateDomainOvhEndPoint = "runabove-ca"
)

func NewAcmeCertificateDomainOvhEndPointFromString(s string) (AcmeCertificateDomainOvhEndPoint, error) {
	switch s {
	case "empty_value_0":
		return AcmeCertificateDomainOvhEndPointEmptyValue0, nil
	case "ovh-eu":
		return AcmeCertificateDomainOvhEndPointOvhEu, nil
	case "ovh-ca":
		return AcmeCertificateDomainOvhEndPointOvhCa, nil
	case "kimsufi-eu":
		return AcmeCertificateDomainOvhEndPointKimsufiEu, nil
	case "kimsufi-ca":
		return AcmeCertificateDomainOvhEndPointKimsufiCa, nil
	case "soyoustart-eu":
		return AcmeCertificateDomainOvhEndPointSoyoustartEu, nil
	case "soyoustart-ca":
		return AcmeCertificateDomainOvhEndPointSoyoustartCa, nil
	case "runabove-ca":
		return AcmeCertificateDomainOvhEndPointRunaboveCa, nil
	}
	var t AcmeCertificateDomainOvhEndPoint
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateDomainOvhEndPoint) Ptr() *AcmeCertificateDomainOvhEndPoint {
	return &a
}

// The activation status of the ACME certificate.<br>
type AcmeCertificateDomainStatus string

const (
	AcmeCertificateDomainStatusEnable  AcmeCertificateDomainStatus = "enable"
	AcmeCertificateDomainStatusDisable AcmeCertificateDomainStatus = "disable"
)

func NewAcmeCertificateDomainStatusFromString(s string) (AcmeCertificateDomainStatus, error) {
	switch s {
	case "enable":
		return AcmeCertificateDomainStatusEnable, nil
	case "disable":
		return AcmeCertificateDomainStatusDisable, nil
	}
	var t AcmeCertificateDomainStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateDomainStatus) Ptr() *AcmeCertificateDomainStatus {
	return &a
}

type AcmeCertificateIssue struct {
	// The name of the ACME certificate to be issued.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate issue process. This will show 'pending' if the issue process is still running or 'completed' if the issue process has finished. This status only indicates whether the issue process has completed, not whether it was successful. You will needto refer to the result log for that information.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate issue status last changed.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh issue command.<br>
	ResultLog *string `json:"result_log,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeCertificateIssue) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeCertificateIssue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeCertificateIssue(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeCertificateIssue) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The length of the private key to use for the ACME certificate.<br>
type AcmeCertificateKeylength string

const (
	AcmeCertificateKeylengthValue2048 AcmeCertificateKeylength = "value_2048"
	AcmeCertificateKeylengthValue3072 AcmeCertificateKeylength = "value_3072"
	AcmeCertificateKeylengthValue4096 AcmeCertificateKeylength = "value_4096"
	AcmeCertificateKeylengthEc256     AcmeCertificateKeylength = "ec-256"
	AcmeCertificateKeylengthEc384     AcmeCertificateKeylength = "ec-384"
	AcmeCertificateKeylengthCustom    AcmeCertificateKeylength = "custom"
)

func NewAcmeCertificateKeylengthFromString(s string) (AcmeCertificateKeylength, error) {
	switch s {
	case "value_2048":
		return AcmeCertificateKeylengthValue2048, nil
	case "value_3072":
		return AcmeCertificateKeylengthValue3072, nil
	case "value_4096":
		return AcmeCertificateKeylengthValue4096, nil
	case "ec-256":
		return AcmeCertificateKeylengthEc256, nil
	case "ec-384":
		return AcmeCertificateKeylengthEc384, nil
	case "custom":
		return AcmeCertificateKeylengthCustom, nil
	}
	var t AcmeCertificateKeylength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateKeylength) Ptr() *AcmeCertificateKeylength {
	return &a
}

type AcmeCertificateRenew struct {
	// The name of the ACME certificate to be renewed.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate renew process. This will show 'pending' if the renew process is still running or 'completed' if the renew process has finished. This status only indicates whether the renew process has completed, not whether it was successful. You will needto refer to the result log for that information. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate renew status last changed. Note: This timestamp is only updated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh renew command. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	ResultLog *string `json:"result_log,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeCertificateRenew) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeCertificateRenew
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeCertificateRenew(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeCertificateRenew) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The activation status of the ACME certificate.<br>
type AcmeCertificateStatus string

const (
	AcmeCertificateStatusActive   AcmeCertificateStatus = "active"
	AcmeCertificateStatusDisabled AcmeCertificateStatus = "disabled"
)

func NewAcmeCertificateStatusFromString(s string) (AcmeCertificateStatus, error) {
	switch s {
	case "active":
		return AcmeCertificateStatusActive, nil
	case "disabled":
		return AcmeCertificateStatusDisabled, nil
	}
	var t AcmeCertificateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AcmeCertificateStatus) Ptr() *AcmeCertificateStatus {
	return &a
}

type AcmeSettings struct {
	// Enables or disables the ACME renewal job.<br>
	Enable *bool `json:"enable,omitempty"`
	// Enables or disables the writing of certificates to /conf/acme/ in various formats for use by other scripts or daemons which do not integrate with the pfSense certificate manager.<br>
	Writecerts *bool `json:"writecerts,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AcmeSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler AcmeSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcmeSettings(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcmeSettings) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BindAccessList struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindAccessList) UnmarshalJSON(data []byte) error {
	type unmarshaler BindAccessList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindAccessList(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindAccessList) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BindAccessListEntriesItem struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindAccessListEntriesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BindAccessListEntriesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindAccessListEntriesItem(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindAccessListEntriesItem) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BindAccessListEntry struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindAccessListEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler BindAccessListEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindAccessListEntry(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindAccessListEntry) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BindSettings struct {
	// Enables the BIND service.<br>
	EnableBind *bool `json:"enable_bind,omitempty"`
	// The IP version to use for the BIND service. Leave empty to use both IPv4 and IPv6.<br>
	BindIPVersion *BindSettingsBindIPVersion `json:"bind_ip_version,omitempty"`
	// The interfaces to listen on for DNS requests.<br>
	Listenon []string `json:"listenon,omitempty"`
	// Notify slave server after any update on master.<br>
	BindNotify *bool `json:"bind_notify,omitempty"`
	// Hide the BIND version in responses.<br>
	BindHideVersion *bool `json:"bind_hide_version,omitempty"`
	// The maximum amount of RAM to use for the BIND service.<br>
	BindRAMLimit *string `json:"bind_ram_limit,omitempty"`
	// Enable logging for the BIND service.<br>
	BindLogging *bool `json:"bind_logging,omitempty"`
	// The minimum severity of events to log.<br>
	LogSeverity *BindSettingsLogSeverity `json:"log_severity,omitempty"`
	// The categories to log.<br>
	LogOptions []BindSettingsLogOptionsItem `json:"log_options,omitempty"`
	// Enable rate limiting for the BIND service.<br>
	RateEnabled *bool `json:"rate_enabled,omitempty"`
	// The maximum number of queries per second to allow.<br><br>This field is only available when the following conditions are met:<br>- `rate_enabled` must be equal to `true`<br>
	RateLimit *int `json:"rate_limit,omitempty"`
	// When rate limiting, only log that the query limit has been exceeded. If disabled, the query will be dropped instead.<br>
	LogOnly *bool `json:"log_only,omitempty"`
	// Enable forwarding queries to other DNS servers listed below rather than this server performing its own recursion.<br>
	BindForwarder *bool `json:"bind_forwarder,omitempty"`
	// The IP addresses of the DNS servers to forward queries to.<br><br>This field is only available when the following conditions are met:<br>- `bind_forwarder` must be equal to `true`<br>
	BindForwarderIps []string `json:"bind_forwarder_ips,omitempty"`
	// Enable DNSSEC validation when BIND is acting as a recursive resolver.<br>
	BindDnssecValidation *BindSettingsBindDnssecValidation `json:"bind_dnssec_validation,omitempty"`
	// The TCP and UDP port to listen on for DNS requests. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The TCP port to listen on for control requests (localhost only). Valid options are: a TCP/UDP port number<br>
	Controlport *string `json:"controlport,omitempty"`
	// Custom BIND options to include in the configuration file.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	// Global BIND settings to include in the configuration file.<br>
	BindGlobalSettings *string `json:"bind_global_settings,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler BindSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindSettings(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindSettings) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Enable DNSSEC validation when BIND is acting as a recursive resolver.<br>
type BindSettingsBindDnssecValidation string

const (
	BindSettingsBindDnssecValidationAuto BindSettingsBindDnssecValidation = "auto"
	BindSettingsBindDnssecValidationOn   BindSettingsBindDnssecValidation = "on"
	BindSettingsBindDnssecValidationOff  BindSettingsBindDnssecValidation = "off"
)

func NewBindSettingsBindDnssecValidationFromString(s string) (BindSettingsBindDnssecValidation, error) {
	switch s {
	case "auto":
		return BindSettingsBindDnssecValidationAuto, nil
	case "on":
		return BindSettingsBindDnssecValidationOn, nil
	case "off":
		return BindSettingsBindDnssecValidationOff, nil
	}
	var t BindSettingsBindDnssecValidation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindSettingsBindDnssecValidation) Ptr() *BindSettingsBindDnssecValidation {
	return &b
}

// The IP version to use for the BIND service. Leave empty to use both IPv4 and IPv6.<br>
type BindSettingsBindIPVersion string

const (
	BindSettingsBindIPVersionEmptyValue0 BindSettingsBindIPVersion = "empty_value_0"
	BindSettingsBindIPVersionNegative4   BindSettingsBindIPVersion = "negative_4"
	BindSettingsBindIPVersionNegative6   BindSettingsBindIPVersion = "negative_6"
)

func NewBindSettingsBindIPVersionFromString(s string) (BindSettingsBindIPVersion, error) {
	switch s {
	case "empty_value_0":
		return BindSettingsBindIPVersionEmptyValue0, nil
	case "negative_4":
		return BindSettingsBindIPVersionNegative4, nil
	case "negative_6":
		return BindSettingsBindIPVersionNegative6, nil
	}
	var t BindSettingsBindIPVersion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindSettingsBindIPVersion) Ptr() *BindSettingsBindIPVersion {
	return &b
}

type BindSettingsLogOptionsItem string

const (
	BindSettingsLogOptionsItemDefault     BindSettingsLogOptionsItem = "default"
	BindSettingsLogOptionsItemGeneral     BindSettingsLogOptionsItem = "general"
	BindSettingsLogOptionsItemDatabase    BindSettingsLogOptionsItem = "database"
	BindSettingsLogOptionsItemSecurity    BindSettingsLogOptionsItem = "security"
	BindSettingsLogOptionsItemConfig      BindSettingsLogOptionsItem = "config"
	BindSettingsLogOptionsItemResolver    BindSettingsLogOptionsItem = "resolver"
	BindSettingsLogOptionsItemXferIn      BindSettingsLogOptionsItem = "xfer-in"
	BindSettingsLogOptionsItemXferOut     BindSettingsLogOptionsItem = "xfer-out"
	BindSettingsLogOptionsItemNotify      BindSettingsLogOptionsItem = "notify"
	BindSettingsLogOptionsItemClient      BindSettingsLogOptionsItem = "client"
	BindSettingsLogOptionsItemUnmatched   BindSettingsLogOptionsItem = "unmatched"
	BindSettingsLogOptionsItemQueries     BindSettingsLogOptionsItem = "queries"
	BindSettingsLogOptionsItemNetwork     BindSettingsLogOptionsItem = "network"
	BindSettingsLogOptionsItemUpdate      BindSettingsLogOptionsItem = "update"
	BindSettingsLogOptionsItemDispatch    BindSettingsLogOptionsItem = "dispatch"
	BindSettingsLogOptionsItemDnssec      BindSettingsLogOptionsItem = "dnssec"
	BindSettingsLogOptionsItemLameServers BindSettingsLogOptionsItem = "lame-servers"
)

func NewBindSettingsLogOptionsItemFromString(s string) (BindSettingsLogOptionsItem, error) {
	switch s {
	case "default":
		return BindSettingsLogOptionsItemDefault, nil
	case "general":
		return BindSettingsLogOptionsItemGeneral, nil
	case "database":
		return BindSettingsLogOptionsItemDatabase, nil
	case "security":
		return BindSettingsLogOptionsItemSecurity, nil
	case "config":
		return BindSettingsLogOptionsItemConfig, nil
	case "resolver":
		return BindSettingsLogOptionsItemResolver, nil
	case "xfer-in":
		return BindSettingsLogOptionsItemXferIn, nil
	case "xfer-out":
		return BindSettingsLogOptionsItemXferOut, nil
	case "notify":
		return BindSettingsLogOptionsItemNotify, nil
	case "client":
		return BindSettingsLogOptionsItemClient, nil
	case "unmatched":
		return BindSettingsLogOptionsItemUnmatched, nil
	case "queries":
		return BindSettingsLogOptionsItemQueries, nil
	case "network":
		return BindSettingsLogOptionsItemNetwork, nil
	case "update":
		return BindSettingsLogOptionsItemUpdate, nil
	case "dispatch":
		return BindSettingsLogOptionsItemDispatch, nil
	case "dnssec":
		return BindSettingsLogOptionsItemDnssec, nil
	case "lame-servers":
		return BindSettingsLogOptionsItemLameServers, nil
	}
	var t BindSettingsLogOptionsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindSettingsLogOptionsItem) Ptr() *BindSettingsLogOptionsItem {
	return &b
}

// The minimum severity of events to log.<br>
type BindSettingsLogSeverity string

const (
	BindSettingsLogSeverityCritical BindSettingsLogSeverity = "critical"
	BindSettingsLogSeverityError    BindSettingsLogSeverity = "error"
	BindSettingsLogSeverityWarning  BindSettingsLogSeverity = "warning"
	BindSettingsLogSeverityNotice   BindSettingsLogSeverity = "notice"
	BindSettingsLogSeverityInfo     BindSettingsLogSeverity = "info"
	BindSettingsLogSeverityDebug1   BindSettingsLogSeverity = "debug 1"
	BindSettingsLogSeverityDebug3   BindSettingsLogSeverity = "debug 3"
	BindSettingsLogSeverityDebug5   BindSettingsLogSeverity = "debug 5"
	BindSettingsLogSeverityDynamic  BindSettingsLogSeverity = "dynamic"
)

func NewBindSettingsLogSeverityFromString(s string) (BindSettingsLogSeverity, error) {
	switch s {
	case "critical":
		return BindSettingsLogSeverityCritical, nil
	case "error":
		return BindSettingsLogSeverityError, nil
	case "warning":
		return BindSettingsLogSeverityWarning, nil
	case "notice":
		return BindSettingsLogSeverityNotice, nil
	case "info":
		return BindSettingsLogSeverityInfo, nil
	case "debug 1":
		return BindSettingsLogSeverityDebug1, nil
	case "debug 3":
		return BindSettingsLogSeverityDebug3, nil
	case "debug 5":
		return BindSettingsLogSeverityDebug5, nil
	case "dynamic":
		return BindSettingsLogSeverityDynamic, nil
	}
	var t BindSettingsLogSeverity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindSettingsLogSeverity) Ptr() *BindSettingsLogSeverity {
	return &b
}

type BindSyncRemoteHost struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindSyncRemoteHost) UnmarshalJSON(data []byte) error {
	type unmarshaler BindSyncRemoteHost
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindSyncRemoteHost(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindSyncRemoteHost) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The protocol to use for syncing.<br>
type BindSyncRemoteHostSyncprotocol string

const (
	BindSyncRemoteHostSyncprotocolHTTP  BindSyncRemoteHostSyncprotocol = "http"
	BindSyncRemoteHostSyncprotocolHTTPS BindSyncRemoteHostSyncprotocol = "https"
)

func NewBindSyncRemoteHostSyncprotocolFromString(s string) (BindSyncRemoteHostSyncprotocol, error) {
	switch s {
	case "http":
		return BindSyncRemoteHostSyncprotocolHTTP, nil
	case "https":
		return BindSyncRemoteHostSyncprotocolHTTPS, nil
	}
	var t BindSyncRemoteHostSyncprotocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindSyncRemoteHostSyncprotocol) Ptr() *BindSyncRemoteHostSyncprotocol {
	return &b
}

type BindSyncSettings struct {
	// The sync mode to use.<br>
	Synconchanges *BindSyncSettingsSynconchanges `json:"synconchanges,omitempty"`
	// The timeout for the sync process.<br>
	Synctimeout *int `json:"synctimeout,omitempty"`
	// The IP address of the master BIND server.<br>
	Masterip *string `json:"masterip,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindSyncSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler BindSyncSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindSyncSettings(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindSyncSettings) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The sync mode to use.<br>
type BindSyncSettingsSynconchanges string

const (
	BindSyncSettingsSynconchangesDisabled BindSyncSettingsSynconchanges = "disabled"
	BindSyncSettingsSynconchangesManual   BindSyncSettingsSynconchanges = "manual"
	BindSyncSettingsSynconchangesAuto     BindSyncSettingsSynconchanges = "auto"
)

func NewBindSyncSettingsSynconchangesFromString(s string) (BindSyncSettingsSynconchanges, error) {
	switch s {
	case "disabled":
		return BindSyncSettingsSynconchangesDisabled, nil
	case "manual":
		return BindSyncSettingsSynconchangesManual, nil
	case "auto":
		return BindSyncSettingsSynconchangesAuto, nil
	}
	var t BindSyncSettingsSynconchanges
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindSyncSettingsSynconchanges) Ptr() *BindSyncSettingsSynconchanges {
	return &b
}

type BindView struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindView) UnmarshalJSON(data []byte) error {
	type unmarshaler BindView
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindView(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindView) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BindZone struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindZone) UnmarshalJSON(data []byte) error {
	type unmarshaler BindZone
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindZone(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindZone) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BindZoneRecord struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindZoneRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler BindZoneRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindZoneRecord(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindZoneRecord) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The type of record.<br>
type BindZoneRecordType string

const (
	BindZoneRecordTypeA     BindZoneRecordType = "A"
	BindZoneRecordTypeAaaa  BindZoneRecordType = "AAAA"
	BindZoneRecordTypeCname BindZoneRecordType = "CNAME"
	BindZoneRecordTypeMx    BindZoneRecordType = "MX"
	BindZoneRecordTypeNs    BindZoneRecordType = "NS"
	BindZoneRecordTypeLoc   BindZoneRecordType = "LOC"
	BindZoneRecordTypePtr   BindZoneRecordType = "PTR"
	BindZoneRecordTypeSrv   BindZoneRecordType = "SRV"
	BindZoneRecordTypeTxt   BindZoneRecordType = "TXT"
	BindZoneRecordTypeSpf   BindZoneRecordType = "SPF"
)

func NewBindZoneRecordTypeFromString(s string) (BindZoneRecordType, error) {
	switch s {
	case "A":
		return BindZoneRecordTypeA, nil
	case "AAAA":
		return BindZoneRecordTypeAaaa, nil
	case "CNAME":
		return BindZoneRecordTypeCname, nil
	case "MX":
		return BindZoneRecordTypeMx, nil
	case "NS":
		return BindZoneRecordTypeNs, nil
	case "LOC":
		return BindZoneRecordTypeLoc, nil
	case "PTR":
		return BindZoneRecordTypePtr, nil
	case "SRV":
		return BindZoneRecordTypeSrv, nil
	case "TXT":
		return BindZoneRecordTypeTxt, nil
	case "SPF":
		return BindZoneRecordTypeSpf, nil
	}
	var t BindZoneRecordType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindZoneRecordType) Ptr() *BindZoneRecordType {
	return &b
}

type BindZoneRecordsItem struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BindZoneRecordsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BindZoneRecordsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BindZoneRecordsItem(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BindZoneRecordsItem) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The type of this BIND zone.<br>
type BindZoneType string

const (
	BindZoneTypeMaster   BindZoneType = "master"
	BindZoneTypeSlave    BindZoneType = "slave"
	BindZoneTypeForward  BindZoneType = "forward"
	BindZoneTypeRedirect BindZoneType = "redirect"
)

func NewBindZoneTypeFromString(s string) (BindZoneType, error) {
	switch s {
	case "master":
		return BindZoneTypeMaster, nil
	case "slave":
		return BindZoneTypeSlave, nil
	case "forward":
		return BindZoneTypeForward, nil
	case "redirect":
		return BindZoneTypeRedirect, nil
	}
	var t BindZoneType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BindZoneType) Ptr() *BindZoneType {
	return &b
}

type CronJob struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CronJob) UnmarshalJSON(data []byte) error {
	type unmarshaler CronJob
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CronJob(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CronJob) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DhcpRelay struct {
	// Enables or disables the DHCP relay.<br>
	Enable *bool `json:"enable,omitempty"`
	// The downstream interfaces to listen on for DHCP requests.<br>
	Interface []string `json:"interface,omitempty"`
	// Enables or disables appending the circuit ID (interface number) and the agent ID to the DHCP request.<br>
	Agentoption *bool `json:"agentoption,omitempty"`
	// DHCP Relay will be stopped when the chosen VIP is in BACKUP status, and started in MASTER status.<br>
	Carpstatusvip *string `json:"carpstatusvip,omitempty"`
	// The IPv4 addresses of the DHCP server to relay requests to.<br>
	Server []string `json:"server,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpRelay) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpRelay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpRelay(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpRelay) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DhcpServer struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServer) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServer(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServer) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DhcpServerAddressPool struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerAddressPool) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerAddressPool
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerAddressPool(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerAddressPool) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
type DhcpServerAddressPoolDenyunknown string

const (
	DhcpServerAddressPoolDenyunknownEnabled DhcpServerAddressPoolDenyunknown = "enabled"
	DhcpServerAddressPoolDenyunknownClass   DhcpServerAddressPoolDenyunknown = "class"
)

func NewDhcpServerAddressPoolDenyunknownFromString(s string) (DhcpServerAddressPoolDenyunknown, error) {
	switch s {
	case "enabled":
		return DhcpServerAddressPoolDenyunknownEnabled, nil
	case "class":
		return DhcpServerAddressPoolDenyunknownClass, nil
	}
	var t DhcpServerAddressPoolDenyunknown
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DhcpServerAddressPoolDenyunknown) Ptr() *DhcpServerAddressPoolDenyunknown {
	return &d
}

type DhcpServerApply struct {
	// Displays `true` if all DHCP server changes are applied and there are no pending changes left.Displays `false` when there are pending DHCP server changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerApply) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerApply(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerApply) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DhcpServerBackend struct {
	// The backend DHCP server service to use. ISC DHCP is deprecate and will be removed in a future version of pfSense.<br>
	Dhcpbackend *DhcpServerBackendDhcpbackend `json:"dhcpbackend,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerBackend) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerBackend
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerBackend(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerBackend) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The backend DHCP server service to use. ISC DHCP is deprecate and will be removed in a future version of pfSense.<br>
type DhcpServerBackendDhcpbackend string

const (
	DhcpServerBackendDhcpbackendIsc DhcpServerBackendDhcpbackend = "isc"
	DhcpServerBackendDhcpbackendKea DhcpServerBackendDhcpbackend = "kea"
)

func NewDhcpServerBackendDhcpbackendFromString(s string) (DhcpServerBackendDhcpbackend, error) {
	switch s {
	case "isc":
		return DhcpServerBackendDhcpbackendIsc, nil
	case "kea":
		return DhcpServerBackendDhcpbackendKea, nil
	}
	var t DhcpServerBackendDhcpbackend
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DhcpServerBackendDhcpbackend) Ptr() *DhcpServerBackendDhcpbackend {
	return &d
}

type DhcpServerCustomOption struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value *string `json:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerCustomOption) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerCustomOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerCustomOption(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerCustomOption) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of value to configure for the option.<br>
type DhcpServerCustomOptionType string

const (
	DhcpServerCustomOptionTypeText              DhcpServerCustomOptionType = "text"
	DhcpServerCustomOptionTypeString            DhcpServerCustomOptionType = "string"
	DhcpServerCustomOptionTypeBoolean           DhcpServerCustomOptionType = "boolean"
	DhcpServerCustomOptionTypeUnsignedInteger8  DhcpServerCustomOptionType = "unsigned integer 8"
	DhcpServerCustomOptionTypeUnsignedInteger16 DhcpServerCustomOptionType = "unsigned integer 16"
	DhcpServerCustomOptionTypeUnsignedInteger32 DhcpServerCustomOptionType = "unsigned integer 32"
	DhcpServerCustomOptionTypeSignedInteger8    DhcpServerCustomOptionType = "signed integer 8"
	DhcpServerCustomOptionTypeSignedInteger16   DhcpServerCustomOptionType = "signed integer 16"
	DhcpServerCustomOptionTypeSignedInteger32   DhcpServerCustomOptionType = "signed integer 32"
	DhcpServerCustomOptionTypeIPAddress         DhcpServerCustomOptionType = "ip-address"
)

func NewDhcpServerCustomOptionTypeFromString(s string) (DhcpServerCustomOptionType, error) {
	switch s {
	case "text":
		return DhcpServerCustomOptionTypeText, nil
	case "string":
		return DhcpServerCustomOptionTypeString, nil
	case "boolean":
		return DhcpServerCustomOptionTypeBoolean, nil
	case "unsigned integer 8":
		return DhcpServerCustomOptionTypeUnsignedInteger8, nil
	case "unsigned integer 16":
		return DhcpServerCustomOptionTypeUnsignedInteger16, nil
	case "unsigned integer 32":
		return DhcpServerCustomOptionTypeUnsignedInteger32, nil
	case "signed integer 8":
		return DhcpServerCustomOptionTypeSignedInteger8, nil
	case "signed integer 16":
		return DhcpServerCustomOptionTypeSignedInteger16, nil
	case "signed integer 32":
		return DhcpServerCustomOptionTypeSignedInteger32, nil
	case "ip-address":
		return DhcpServerCustomOptionTypeIPAddress, nil
	}
	var t DhcpServerCustomOptionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DhcpServerCustomOptionType) Ptr() *DhcpServerCustomOptionType {
	return &d
}

// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
type DhcpServerDenyunknown string

const (
	DhcpServerDenyunknownEnabled DhcpServerDenyunknown = "enabled"
	DhcpServerDenyunknownClass   DhcpServerDenyunknown = "class"
)

func NewDhcpServerDenyunknownFromString(s string) (DhcpServerDenyunknown, error) {
	switch s {
	case "enabled":
		return DhcpServerDenyunknownEnabled, nil
	case "class":
		return DhcpServerDenyunknownClass, nil
	}
	var t DhcpServerDenyunknown
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DhcpServerDenyunknown) Ptr() *DhcpServerDenyunknown {
	return &d
}

type DhcpServerNumberoptionsItem struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value *string `json:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerNumberoptionsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerNumberoptionsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerNumberoptionsItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerNumberoptionsItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DhcpServerPoolItem struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerPoolItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerPoolItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerPoolItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerPoolItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DhcpServerStaticMapping struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerStaticMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerStaticMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerStaticMapping(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerStaticMapping) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DhcpServerStaticmapItem struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DhcpServerStaticmapItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DhcpServerStaticmapItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DhcpServerStaticmapItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DhcpServerStaticmapItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSForwarderApply struct {
	// Displays `true` when all DNS Forwarder changes are applied and there are no pending changes left.Displays `false` when there are pending DNS Forwarder changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSForwarderApply) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSForwarderApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSForwarderApply(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSForwarderApply) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSForwarderHostOverride struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSForwarderHostOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSForwarderHostOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSForwarderHostOverride(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSForwarderHostOverride) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSForwarderHostOverrideAlias struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSForwarderHostOverrideAlias) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSForwarderHostOverrideAlias
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSForwarderHostOverrideAlias(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSForwarderHostOverrideAlias) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSForwarderHostOverrideAliasesItem struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSForwarderHostOverrideAliasesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSForwarderHostOverrideAliasesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSForwarderHostOverrideAliasesItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSForwarderHostOverrideAliasesItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverAccessList struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverAccessList) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverAccessList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverAccessList(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverAccessList) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The action to take when an access list match is found.<br>
type DNSResolverAccessListAction string

const (
	DNSResolverAccessListActionAllow          DNSResolverAccessListAction = "allow"
	DNSResolverAccessListActionDeny           DNSResolverAccessListAction = "deny"
	DNSResolverAccessListActionRefuse         DNSResolverAccessListAction = "refuse"
	DNSResolverAccessListActionAllowSnoop     DNSResolverAccessListAction = "allow snoop"
	DNSResolverAccessListActionDenyNonlocal   DNSResolverAccessListAction = "deny nonlocal"
	DNSResolverAccessListActionRefuseNonlocal DNSResolverAccessListAction = "refuse nonlocal"
)

func NewDNSResolverAccessListActionFromString(s string) (DNSResolverAccessListAction, error) {
	switch s {
	case "allow":
		return DNSResolverAccessListActionAllow, nil
	case "deny":
		return DNSResolverAccessListActionDeny, nil
	case "refuse":
		return DNSResolverAccessListActionRefuse, nil
	case "allow snoop":
		return DNSResolverAccessListActionAllowSnoop, nil
	case "deny nonlocal":
		return DNSResolverAccessListActionDenyNonlocal, nil
	case "refuse nonlocal":
		return DNSResolverAccessListActionRefuseNonlocal, nil
	}
	var t DNSResolverAccessListAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DNSResolverAccessListAction) Ptr() *DNSResolverAccessListAction {
	return &d
}

type DNSResolverAccessListNetwork struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverAccessListNetwork) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverAccessListNetwork
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverAccessListNetwork(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverAccessListNetwork) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverAccessListNetworksItem struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverAccessListNetworksItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverAccessListNetworksItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverAccessListNetworksItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverAccessListNetworksItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverApply struct {
	// Displays `true` when all DNS Resolver changes are applied and there are no pending changes left.Displays `false` when there are pending DNS Resolver changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverApply) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverApply(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverApply) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverDomainOverride struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverDomainOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverDomainOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverDomainOverride(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverDomainOverride) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverHostOverride struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverHostOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverHostOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverHostOverride(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverHostOverride) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverHostOverrideAlias struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverHostOverrideAlias) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverHostOverrideAlias
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverHostOverrideAlias(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverHostOverrideAlias) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverHostOverrideAliasesItem struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverHostOverrideAliasesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverHostOverrideAliasesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverHostOverrideAliasesItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverHostOverrideAliasesItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DNSResolverSettings struct {
	// Enables or disables the DNS Resolver service.<br>
	Enable *bool `json:"enable,omitempty"`
	// The port on which the DNS Resolver service listens. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// Enables or disables SSL/TLS for the DNS Resolver service.<br>
	Enablessl *bool `json:"enablessl,omitempty"`
	// The SSL/TLS certificate to use for the DNS Resolver service.<br><br>This field is only available when the following conditions are met:<br>- `enablessl` must be equal to `true`<br>
	Sslcertref *string `json:"sslcertref,omitempty"`
	// The port on which the DNS Resolver service listens for SSL/TLS connections. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `enablessl` must be equal to `true`<br>
	Tlsport *string `json:"tlsport,omitempty"`
	// The interface on which the DNS Resolver service listens for DNS queries. Set empty value ".
	//
	//	"to listen on all interfaces.<br>
	ActiveInterface []string `json:"active_interface,omitempty"`
	// The interface on which the DNS Resolver service sends outgoing DNS queries. Set empty value ".
	//
	//	"to use any interface.<br>
	OutgoingInterface []string `json:"outgoing_interface,omitempty"`
	// Enables or disables sending recursive queries if none of the selected Outgoing Network ".
	//
	//	"Interfaces are available.<br>
	Strictout *bool `json:"strictout,omitempty"`
	// The type of local zone used for the system domain.<br>
	SystemDomainLocalZoneType *DNSResolverSettingsSystemDomainLocalZoneType `json:"system_domain_local_zone_type,omitempty"`
	// Enables or disables DNSSEC validation.<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enables or disables the Python module.<br>
	Python *bool `json:"python,omitempty"`
	// The order in which the Python module is loaded.<br><br>This field is only available when the following conditions are met:<br>- `python` must be equal to `true`<br>
	PythonOrder *DNSResolverSettingsPythonOrder `json:"python_order,omitempty"`
	// The Python module to utilize.<br><br>This field is only available when the following conditions are met:<br>- `python` must be equal to `true`<br>
	PythonScript *string `json:"python_script,omitempty"`
	// Enables or disables DNS Resolver forwarding mode.<br>
	Forwarding *bool `json:"forwarding,omitempty"`
	// Enables or disables registering DHCP leases in the DNS Resolver service.<br>
	Regdhcp *bool `json:"regdhcp,omitempty"`
	// Enables or disables registering static DHCP mappings in the DNS Resolver service.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Enables or disables registering OpenVPN clients in the DNS Resolver service.<br>
	Regovpnclients *bool `json:"regovpnclients,omitempty"`
	// Custom options to add to the DNS Resolver configuration.<br>
	CustomOptions *string `json:"custom_options,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DNSResolverSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler DNSResolverSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DNSResolverSettings(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DNSResolverSettings) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The order in which the Python module is loaded.<br><br>This field is only available when the following conditions are met:<br>- `python` must be equal to `true`<br>
type DNSResolverSettingsPythonOrder string

const (
	DNSResolverSettingsPythonOrderPreValidator  DNSResolverSettingsPythonOrder = "pre_validator"
	DNSResolverSettingsPythonOrderPostValidator DNSResolverSettingsPythonOrder = "post_validator"
)

func NewDNSResolverSettingsPythonOrderFromString(s string) (DNSResolverSettingsPythonOrder, error) {
	switch s {
	case "pre_validator":
		return DNSResolverSettingsPythonOrderPreValidator, nil
	case "post_validator":
		return DNSResolverSettingsPythonOrderPostValidator, nil
	}
	var t DNSResolverSettingsPythonOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DNSResolverSettingsPythonOrder) Ptr() *DNSResolverSettingsPythonOrder {
	return &d
}

// The type of local zone used for the system domain.<br>
type DNSResolverSettingsSystemDomainLocalZoneType string

const (
	DNSResolverSettingsSystemDomainLocalZoneTypeDeny            DNSResolverSettingsSystemDomainLocalZoneType = "deny"
	DNSResolverSettingsSystemDomainLocalZoneTypeRefuse          DNSResolverSettingsSystemDomainLocalZoneType = "refuse"
	DNSResolverSettingsSystemDomainLocalZoneTypeStatic          DNSResolverSettingsSystemDomainLocalZoneType = "static"
	DNSResolverSettingsSystemDomainLocalZoneTypeTransparent     DNSResolverSettingsSystemDomainLocalZoneType = "transparent"
	DNSResolverSettingsSystemDomainLocalZoneTypeTypetransparent DNSResolverSettingsSystemDomainLocalZoneType = "typetransparent"
	DNSResolverSettingsSystemDomainLocalZoneTypeRedirect        DNSResolverSettingsSystemDomainLocalZoneType = "redirect"
	DNSResolverSettingsSystemDomainLocalZoneTypeInform          DNSResolverSettingsSystemDomainLocalZoneType = "inform"
	DNSResolverSettingsSystemDomainLocalZoneTypeInformDeny      DNSResolverSettingsSystemDomainLocalZoneType = "inform_deny"
	DNSResolverSettingsSystemDomainLocalZoneTypeNodefault       DNSResolverSettingsSystemDomainLocalZoneType = "nodefault"
)

func NewDNSResolverSettingsSystemDomainLocalZoneTypeFromString(s string) (DNSResolverSettingsSystemDomainLocalZoneType, error) {
	switch s {
	case "deny":
		return DNSResolverSettingsSystemDomainLocalZoneTypeDeny, nil
	case "refuse":
		return DNSResolverSettingsSystemDomainLocalZoneTypeRefuse, nil
	case "static":
		return DNSResolverSettingsSystemDomainLocalZoneTypeStatic, nil
	case "transparent":
		return DNSResolverSettingsSystemDomainLocalZoneTypeTransparent, nil
	case "typetransparent":
		return DNSResolverSettingsSystemDomainLocalZoneTypeTypetransparent, nil
	case "redirect":
		return DNSResolverSettingsSystemDomainLocalZoneTypeRedirect, nil
	case "inform":
		return DNSResolverSettingsSystemDomainLocalZoneTypeInform, nil
	case "inform_deny":
		return DNSResolverSettingsSystemDomainLocalZoneTypeInformDeny, nil
	case "nodefault":
		return DNSResolverSettingsSystemDomainLocalZoneTypeNodefault, nil
	}
	var t DNSResolverSettingsSystemDomainLocalZoneType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DNSResolverSettingsSystemDomainLocalZoneType) Ptr() *DNSResolverSettingsSystemDomainLocalZoneType {
	return &d
}

type FreeRadiusClient struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FreeRadiusClient) UnmarshalJSON(data []byte) error {
	type unmarshaler FreeRadiusClient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FreeRadiusClient(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FreeRadiusClient) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The IP version of the this Client.<br>
type FreeRadiusClientIPVersion string

const (
	FreeRadiusClientIPVersionIpaddr   FreeRadiusClientIPVersion = "ipaddr"
	FreeRadiusClientIPVersionIpv6Addr FreeRadiusClientIPVersion = "ipv6addr"
)

func NewFreeRadiusClientIPVersionFromString(s string) (FreeRadiusClientIPVersion, error) {
	switch s {
	case "ipaddr":
		return FreeRadiusClientIPVersionIpaddr, nil
	case "ipv6addr":
		return FreeRadiusClientIPVersionIpv6Addr, nil
	}
	var t FreeRadiusClientIPVersion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FreeRadiusClientIPVersion) Ptr() *FreeRadiusClientIPVersion {
	return &f
}

// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
type FreeRadiusClientNastype string

const (
	FreeRadiusClientNastypeCisco        FreeRadiusClientNastype = "cisco"
	FreeRadiusClientNastypeCvx          FreeRadiusClientNastype = "cvx"
	FreeRadiusClientNastypeComputone    FreeRadiusClientNastype = "computone"
	FreeRadiusClientNastypeDigitro      FreeRadiusClientNastype = "digitro"
	FreeRadiusClientNastypeLivingston   FreeRadiusClientNastype = "livingston"
	FreeRadiusClientNastypeJuniper      FreeRadiusClientNastype = "juniper"
	FreeRadiusClientNastypeMax40Xx      FreeRadiusClientNastype = "max40xx"
	FreeRadiusClientNastypeMikrotik     FreeRadiusClientNastype = "mikrotik"
	FreeRadiusClientNastypeMikrotikSnmp FreeRadiusClientNastype = "mikrotik_snmp"
	FreeRadiusClientNastypeDot1X        FreeRadiusClientNastype = "dot1x"
	FreeRadiusClientNastypeOther        FreeRadiusClientNastype = "other"
)

func NewFreeRadiusClientNastypeFromString(s string) (FreeRadiusClientNastype, error) {
	switch s {
	case "cisco":
		return FreeRadiusClientNastypeCisco, nil
	case "cvx":
		return FreeRadiusClientNastypeCvx, nil
	case "computone":
		return FreeRadiusClientNastypeComputone, nil
	case "digitro":
		return FreeRadiusClientNastypeDigitro, nil
	case "livingston":
		return FreeRadiusClientNastypeLivingston, nil
	case "juniper":
		return FreeRadiusClientNastypeJuniper, nil
	case "max40xx":
		return FreeRadiusClientNastypeMax40Xx, nil
	case "mikrotik":
		return FreeRadiusClientNastypeMikrotik, nil
	case "mikrotik_snmp":
		return FreeRadiusClientNastypeMikrotikSnmp, nil
	case "dot1x":
		return FreeRadiusClientNastypeDot1X, nil
	case "other":
		return FreeRadiusClientNastypeOther, nil
	}
	var t FreeRadiusClientNastype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FreeRadiusClientNastype) Ptr() *FreeRadiusClientNastype {
	return &f
}

// The protocol the client uses.<br>
type FreeRadiusClientProto string

const (
	FreeRadiusClientProtoUDP FreeRadiusClientProto = "udp"
	FreeRadiusClientProtoTCP FreeRadiusClientProto = "tcp"
)

func NewFreeRadiusClientProtoFromString(s string) (FreeRadiusClientProto, error) {
	switch s {
	case "udp":
		return FreeRadiusClientProtoUDP, nil
	case "tcp":
		return FreeRadiusClientProtoTCP, nil
	}
	var t FreeRadiusClientProto
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FreeRadiusClientProto) Ptr() *FreeRadiusClientProto {
	return &f
}

type FreeRadiusInterface struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FreeRadiusInterface) UnmarshalJSON(data []byte) error {
	type unmarshaler FreeRadiusInterface
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FreeRadiusInterface(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FreeRadiusInterface) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The IP version of the listening interface.<br>
type FreeRadiusInterfaceIPVersion string

const (
	FreeRadiusInterfaceIPVersionIpaddr   FreeRadiusInterfaceIPVersion = "ipaddr"
	FreeRadiusInterfaceIPVersionIpv6Addr FreeRadiusInterfaceIPVersion = "ipv6addr"
)

func NewFreeRadiusInterfaceIPVersionFromString(s string) (FreeRadiusInterfaceIPVersion, error) {
	switch s {
	case "ipaddr":
		return FreeRadiusInterfaceIPVersionIpaddr, nil
	case "ipv6addr":
		return FreeRadiusInterfaceIPVersionIpv6Addr, nil
	}
	var t FreeRadiusInterfaceIPVersion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FreeRadiusInterfaceIPVersion) Ptr() *FreeRadiusInterfaceIPVersion {
	return &f
}

// The type of the listening interface: Authentication/Accounting.<br>
type FreeRadiusInterfaceType string

const (
	FreeRadiusInterfaceTypeAuth   FreeRadiusInterfaceType = "auth"
	FreeRadiusInterfaceTypeAcct   FreeRadiusInterfaceType = "acct"
	FreeRadiusInterfaceTypeProxy  FreeRadiusInterfaceType = "proxy"
	FreeRadiusInterfaceTypeDetail FreeRadiusInterfaceType = "detail"
	FreeRadiusInterfaceTypeStatus FreeRadiusInterfaceType = "status"
	FreeRadiusInterfaceTypeCoa    FreeRadiusInterfaceType = "coa"
)

func NewFreeRadiusInterfaceTypeFromString(s string) (FreeRadiusInterfaceType, error) {
	switch s {
	case "auth":
		return FreeRadiusInterfaceTypeAuth, nil
	case "acct":
		return FreeRadiusInterfaceTypeAcct, nil
	case "proxy":
		return FreeRadiusInterfaceTypeProxy, nil
	case "detail":
		return FreeRadiusInterfaceTypeDetail, nil
	case "status":
		return FreeRadiusInterfaceTypeStatus, nil
	case "coa":
		return FreeRadiusInterfaceTypeCoa, nil
	}
	var t FreeRadiusInterfaceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FreeRadiusInterfaceType) Ptr() *FreeRadiusInterfaceType {
	return &f
}

type FreeRadiusUser struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FreeRadiusUser) UnmarshalJSON(data []byte) error {
	type unmarshaler FreeRadiusUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FreeRadiusUser(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FreeRadiusUser) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
type FreeRadiusUserMotpAuthmethod string

const (
	FreeRadiusUserMotpAuthmethodMotp       FreeRadiusUserMotpAuthmethod = "motp"
	FreeRadiusUserMotpAuthmethodGoogleauth FreeRadiusUserMotpAuthmethod = "googleauth"
)

func NewFreeRadiusUserMotpAuthmethodFromString(s string) (FreeRadiusUserMotpAuthmethod, error) {
	switch s {
	case "motp":
		return FreeRadiusUserMotpAuthmethodMotp, nil
	case "googleauth":
		return FreeRadiusUserMotpAuthmethodGoogleauth, nil
	}
	var t FreeRadiusUserMotpAuthmethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FreeRadiusUserMotpAuthmethod) Ptr() *FreeRadiusUserMotpAuthmethod {
	return &f
}

// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
type FreeRadiusUserPasswordEncryption string

const (
	FreeRadiusUserPasswordEncryptionCleartextPassword FreeRadiusUserPasswordEncryption = "Cleartext-Password"
	FreeRadiusUserPasswordEncryptionMd5Password       FreeRadiusUserPasswordEncryption = "MD5-Password"
	FreeRadiusUserPasswordEncryptionMd5PasswordHashed FreeRadiusUserPasswordEncryption = "MD5-Password-hashed"
	FreeRadiusUserPasswordEncryptionNtPasswordHashed  FreeRadiusUserPasswordEncryption = "NT-Password-hashed"
)

func NewFreeRadiusUserPasswordEncryptionFromString(s string) (FreeRadiusUserPasswordEncryption, error) {
	switch s {
	case "Cleartext-Password":
		return FreeRadiusUserPasswordEncryptionCleartextPassword, nil
	case "MD5-Password":
		return FreeRadiusUserPasswordEncryptionMd5Password, nil
	case "MD5-Password-hashed":
		return FreeRadiusUserPasswordEncryptionMd5PasswordHashed, nil
	case "NT-Password-hashed":
		return FreeRadiusUserPasswordEncryptionNtPasswordHashed, nil
	}
	var t FreeRadiusUserPasswordEncryption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FreeRadiusUserPasswordEncryption) Ptr() *FreeRadiusUserPasswordEncryption {
	return &f
}

type HaProxyApply struct {
	// Indicates whether all HAProxy configuration changes have been applied.<br>
	Applied *bool `json:"applied,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyApply) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyApply(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyApply) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyBackend struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackend) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackend
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackend(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackend) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyBackendACL struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendACL) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendACL
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendACL(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendACL) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The expression to use to determine the match for this ACL.<br>
type HaProxyBackendACLExpression string

const (
	HaProxyBackendACLExpressionHostStartsWith     HaProxyBackendACLExpression = "host_starts_with"
	HaProxyBackendACLExpressionHostEndsWith       HaProxyBackendACLExpression = "host_ends_with"
	HaProxyBackendACLExpressionHostMatches        HaProxyBackendACLExpression = "host_matches"
	HaProxyBackendACLExpressionHostRegex          HaProxyBackendACLExpression = "host_regex"
	HaProxyBackendACLExpressionHostContains       HaProxyBackendACLExpression = "host_contains"
	HaProxyBackendACLExpressionPathStartsWith     HaProxyBackendACLExpression = "path_starts_with"
	HaProxyBackendACLExpressionPathEndsWith       HaProxyBackendACLExpression = "path_ends_with"
	HaProxyBackendACLExpressionPathMatches        HaProxyBackendACLExpression = "path_matches"
	HaProxyBackendACLExpressionPathRegex          HaProxyBackendACLExpression = "path_regex"
	HaProxyBackendACLExpressionPathContains       HaProxyBackendACLExpression = "path_contains"
	HaProxyBackendACLExpressionPathDir            HaProxyBackendACLExpression = "path_dir"
	HaProxyBackendACLExpressionURLParameter       HaProxyBackendACLExpression = "url_parameter"
	HaProxyBackendACLExpressionSslCVerifyCode     HaProxyBackendACLExpression = "ssl_c_verify_code"
	HaProxyBackendACLExpressionSslCVerify         HaProxyBackendACLExpression = "ssl_c_verify"
	HaProxyBackendACLExpressionSslCCaCommonname   HaProxyBackendACLExpression = "ssl_c_ca_commonname"
	HaProxyBackendACLExpressionSourceIP           HaProxyBackendACLExpression = "source_ip"
	HaProxyBackendACLExpressionBackendservercount HaProxyBackendACLExpression = "backendservercount"
	HaProxyBackendACLExpressionTrafficIsHTTP      HaProxyBackendACLExpression = "traffic_is_http"
	HaProxyBackendACLExpressionTrafficIsSsl       HaProxyBackendACLExpression = "traffic_is_ssl"
	HaProxyBackendACLExpressionSslSniMatches      HaProxyBackendACLExpression = "ssl_sni_matches"
	HaProxyBackendACLExpressionSslSniContains     HaProxyBackendACLExpression = "ssl_sni_contains"
	HaProxyBackendACLExpressionSslSniStartsWith   HaProxyBackendACLExpression = "ssl_sni_starts_with"
	HaProxyBackendACLExpressionSslSniEndsWith     HaProxyBackendACLExpression = "ssl_sni_ends_with"
	HaProxyBackendACLExpressionSslSniRegex        HaProxyBackendACLExpression = "ssl_sni_regex"
	HaProxyBackendACLExpressionCustom             HaProxyBackendACLExpression = "custom"
)

func NewHaProxyBackendACLExpressionFromString(s string) (HaProxyBackendACLExpression, error) {
	switch s {
	case "host_starts_with":
		return HaProxyBackendACLExpressionHostStartsWith, nil
	case "host_ends_with":
		return HaProxyBackendACLExpressionHostEndsWith, nil
	case "host_matches":
		return HaProxyBackendACLExpressionHostMatches, nil
	case "host_regex":
		return HaProxyBackendACLExpressionHostRegex, nil
	case "host_contains":
		return HaProxyBackendACLExpressionHostContains, nil
	case "path_starts_with":
		return HaProxyBackendACLExpressionPathStartsWith, nil
	case "path_ends_with":
		return HaProxyBackendACLExpressionPathEndsWith, nil
	case "path_matches":
		return HaProxyBackendACLExpressionPathMatches, nil
	case "path_regex":
		return HaProxyBackendACLExpressionPathRegex, nil
	case "path_contains":
		return HaProxyBackendACLExpressionPathContains, nil
	case "path_dir":
		return HaProxyBackendACLExpressionPathDir, nil
	case "url_parameter":
		return HaProxyBackendACLExpressionURLParameter, nil
	case "ssl_c_verify_code":
		return HaProxyBackendACLExpressionSslCVerifyCode, nil
	case "ssl_c_verify":
		return HaProxyBackendACLExpressionSslCVerify, nil
	case "ssl_c_ca_commonname":
		return HaProxyBackendACLExpressionSslCCaCommonname, nil
	case "source_ip":
		return HaProxyBackendACLExpressionSourceIP, nil
	case "backendservercount":
		return HaProxyBackendACLExpressionBackendservercount, nil
	case "traffic_is_http":
		return HaProxyBackendACLExpressionTrafficIsHTTP, nil
	case "traffic_is_ssl":
		return HaProxyBackendACLExpressionTrafficIsSsl, nil
	case "ssl_sni_matches":
		return HaProxyBackendACLExpressionSslSniMatches, nil
	case "ssl_sni_contains":
		return HaProxyBackendACLExpressionSslSniContains, nil
	case "ssl_sni_starts_with":
		return HaProxyBackendACLExpressionSslSniStartsWith, nil
	case "ssl_sni_ends_with":
		return HaProxyBackendACLExpressionSslSniEndsWith, nil
	case "ssl_sni_regex":
		return HaProxyBackendACLExpressionSslSniRegex, nil
	case "custom":
		return HaProxyBackendACLExpressionCustom, nil
	}
	var t HaProxyBackendACLExpression
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendACLExpression) Ptr() *HaProxyBackendACLExpression {
	return &h
}

type HaProxyBackendACLsItem struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendACLsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendACLsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendACLsItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendACLsItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyBackendAction struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendAction) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendAction(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendAction) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The action to take when an ACL match is found.<br>
type HaProxyBackendActionAction string

const (
	HaProxyBackendActionActionUseServer                      HaProxyBackendActionAction = "use_server"
	HaProxyBackendActionActionCustom                         HaProxyBackendActionAction = "custom"
	HaProxyBackendActionActionHTTPRequestAllow               HaProxyBackendActionAction = "http-request_allow"
	HaProxyBackendActionActionHTTPRequestDeny                HaProxyBackendActionAction = "http-request_deny"
	HaProxyBackendActionActionHTTPRequestTarpit              HaProxyBackendActionAction = "http-request_tarpit"
	HaProxyBackendActionActionHTTPRequestAuth                HaProxyBackendActionAction = "http-request_auth"
	HaProxyBackendActionActionHTTPRequestRedirect            HaProxyBackendActionAction = "http-request_redirect"
	HaProxyBackendActionActionHTTPRequestLua                 HaProxyBackendActionAction = "http-request_lua"
	HaProxyBackendActionActionHTTPRequestUseService          HaProxyBackendActionAction = "http-request_use-service"
	HaProxyBackendActionActionHTTPRequestAddHeader           HaProxyBackendActionAction = "http-request_add-header"
	HaProxyBackendActionActionHTTPRequestSetHeader           HaProxyBackendActionAction = "http-request_set-header"
	HaProxyBackendActionActionHTTPRequestDelHeader           HaProxyBackendActionAction = "http-request_del-header"
	HaProxyBackendActionActionHTTPRequestReplaceHeader       HaProxyBackendActionAction = "http-request_replace-header"
	HaProxyBackendActionActionHTTPRequestReplacePath         HaProxyBackendActionAction = "http-request_replace-path"
	HaProxyBackendActionActionHTTPRequestReplaceValue        HaProxyBackendActionAction = "http-request_replace-value"
	HaProxyBackendActionActionHTTPRequestSetMethod           HaProxyBackendActionAction = "http-request_set-method"
	HaProxyBackendActionActionHTTPRequestSetPath             HaProxyBackendActionAction = "http-request_set-path"
	HaProxyBackendActionActionHTTPRequestSetQuery            HaProxyBackendActionAction = "http-request_set-query"
	HaProxyBackendActionActionHTTPRequestSetURI              HaProxyBackendActionAction = "http-request_set-uri"
	HaProxyBackendActionActionHTTPResponseAllow              HaProxyBackendActionAction = "http-response_allow"
	HaProxyBackendActionActionHTTPResponseDeny               HaProxyBackendActionAction = "http-response_deny"
	HaProxyBackendActionActionHTTPResponseLua                HaProxyBackendActionAction = "http-response_lua"
	HaProxyBackendActionActionHTTPResponseAddHeader          HaProxyBackendActionAction = "http-response_add-header"
	HaProxyBackendActionActionHTTPResponseSetHeader          HaProxyBackendActionAction = "http-response_set-header"
	HaProxyBackendActionActionHTTPResponseDelHeader          HaProxyBackendActionAction = "http-response_del-header"
	HaProxyBackendActionActionHTTPResponseReplaceHeader      HaProxyBackendActionAction = "http-response_replace-header"
	HaProxyBackendActionActionHTTPResponseReplaceValue       HaProxyBackendActionAction = "http-response_replace-value"
	HaProxyBackendActionActionHTTPResponseSetStatus          HaProxyBackendActionAction = "http-response_set-status"
	HaProxyBackendActionActionHTTPAfterResponseAddHeader     HaProxyBackendActionAction = "http-after-response_add-header"
	HaProxyBackendActionActionHTTPAfterResponseSetHeader     HaProxyBackendActionAction = "http-after-response_set-header"
	HaProxyBackendActionActionHTTPAfterResponseDelHeader     HaProxyBackendActionAction = "http-after-response_del-header"
	HaProxyBackendActionActionHTTPAfterResponseReplaceHeader HaProxyBackendActionAction = "http-after-response_replace-header"
	HaProxyBackendActionActionHTTPAfterResponseReplaceValue  HaProxyBackendActionAction = "http-after-response_replace-value"
	HaProxyBackendActionActionHTTPAfterResponseSetStatus     HaProxyBackendActionAction = "http-after-response_set-status"
	HaProxyBackendActionActionTCPRequestConnectionAccept     HaProxyBackendActionAction = "tcp-request_connection_accept"
	HaProxyBackendActionActionTCPRequestConnectionReject     HaProxyBackendActionAction = "tcp-request_connection_reject"
	HaProxyBackendActionActionTCPRequestContentAccept        HaProxyBackendActionAction = "tcp-request_content_accept"
	HaProxyBackendActionActionTCPRequestContentReject        HaProxyBackendActionAction = "tcp-request_content_reject"
	HaProxyBackendActionActionTCPRequestContentLua           HaProxyBackendActionAction = "tcp-request_content_lua"
	HaProxyBackendActionActionTCPRequestContentUseService    HaProxyBackendActionAction = "tcp-request_content_use-service"
	HaProxyBackendActionActionTCPResponseContentAccept       HaProxyBackendActionAction = "tcp-response_content_accept"
	HaProxyBackendActionActionTCPResponseContentClose        HaProxyBackendActionAction = "tcp-response_content_close"
	HaProxyBackendActionActionTCPResponseContentReject       HaProxyBackendActionAction = "tcp-response_content_reject"
	HaProxyBackendActionActionTCPResponseContentLua          HaProxyBackendActionAction = "tcp-response_content_lua"
)

func NewHaProxyBackendActionActionFromString(s string) (HaProxyBackendActionAction, error) {
	switch s {
	case "use_server":
		return HaProxyBackendActionActionUseServer, nil
	case "custom":
		return HaProxyBackendActionActionCustom, nil
	case "http-request_allow":
		return HaProxyBackendActionActionHTTPRequestAllow, nil
	case "http-request_deny":
		return HaProxyBackendActionActionHTTPRequestDeny, nil
	case "http-request_tarpit":
		return HaProxyBackendActionActionHTTPRequestTarpit, nil
	case "http-request_auth":
		return HaProxyBackendActionActionHTTPRequestAuth, nil
	case "http-request_redirect":
		return HaProxyBackendActionActionHTTPRequestRedirect, nil
	case "http-request_lua":
		return HaProxyBackendActionActionHTTPRequestLua, nil
	case "http-request_use-service":
		return HaProxyBackendActionActionHTTPRequestUseService, nil
	case "http-request_add-header":
		return HaProxyBackendActionActionHTTPRequestAddHeader, nil
	case "http-request_set-header":
		return HaProxyBackendActionActionHTTPRequestSetHeader, nil
	case "http-request_del-header":
		return HaProxyBackendActionActionHTTPRequestDelHeader, nil
	case "http-request_replace-header":
		return HaProxyBackendActionActionHTTPRequestReplaceHeader, nil
	case "http-request_replace-path":
		return HaProxyBackendActionActionHTTPRequestReplacePath, nil
	case "http-request_replace-value":
		return HaProxyBackendActionActionHTTPRequestReplaceValue, nil
	case "http-request_set-method":
		return HaProxyBackendActionActionHTTPRequestSetMethod, nil
	case "http-request_set-path":
		return HaProxyBackendActionActionHTTPRequestSetPath, nil
	case "http-request_set-query":
		return HaProxyBackendActionActionHTTPRequestSetQuery, nil
	case "http-request_set-uri":
		return HaProxyBackendActionActionHTTPRequestSetURI, nil
	case "http-response_allow":
		return HaProxyBackendActionActionHTTPResponseAllow, nil
	case "http-response_deny":
		return HaProxyBackendActionActionHTTPResponseDeny, nil
	case "http-response_lua":
		return HaProxyBackendActionActionHTTPResponseLua, nil
	case "http-response_add-header":
		return HaProxyBackendActionActionHTTPResponseAddHeader, nil
	case "http-response_set-header":
		return HaProxyBackendActionActionHTTPResponseSetHeader, nil
	case "http-response_del-header":
		return HaProxyBackendActionActionHTTPResponseDelHeader, nil
	case "http-response_replace-header":
		return HaProxyBackendActionActionHTTPResponseReplaceHeader, nil
	case "http-response_replace-value":
		return HaProxyBackendActionActionHTTPResponseReplaceValue, nil
	case "http-response_set-status":
		return HaProxyBackendActionActionHTTPResponseSetStatus, nil
	case "http-after-response_add-header":
		return HaProxyBackendActionActionHTTPAfterResponseAddHeader, nil
	case "http-after-response_set-header":
		return HaProxyBackendActionActionHTTPAfterResponseSetHeader, nil
	case "http-after-response_del-header":
		return HaProxyBackendActionActionHTTPAfterResponseDelHeader, nil
	case "http-after-response_replace-header":
		return HaProxyBackendActionActionHTTPAfterResponseReplaceHeader, nil
	case "http-after-response_replace-value":
		return HaProxyBackendActionActionHTTPAfterResponseReplaceValue, nil
	case "http-after-response_set-status":
		return HaProxyBackendActionActionHTTPAfterResponseSetStatus, nil
	case "tcp-request_connection_accept":
		return HaProxyBackendActionActionTCPRequestConnectionAccept, nil
	case "tcp-request_connection_reject":
		return HaProxyBackendActionActionTCPRequestConnectionReject, nil
	case "tcp-request_content_accept":
		return HaProxyBackendActionActionTCPRequestContentAccept, nil
	case "tcp-request_content_reject":
		return HaProxyBackendActionActionTCPRequestContentReject, nil
	case "tcp-request_content_lua":
		return HaProxyBackendActionActionTCPRequestContentLua, nil
	case "tcp-request_content_use-service":
		return HaProxyBackendActionActionTCPRequestContentUseService, nil
	case "tcp-response_content_accept":
		return HaProxyBackendActionActionTCPResponseContentAccept, nil
	case "tcp-response_content_close":
		return HaProxyBackendActionActionTCPResponseContentClose, nil
	case "tcp-response_content_reject":
		return HaProxyBackendActionActionTCPResponseContentReject, nil
	case "tcp-response_content_lua":
		return HaProxyBackendActionActionTCPResponseContentLua, nil
	}
	var t HaProxyBackendActionAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendActionAction) Ptr() *HaProxyBackendActionAction {
	return &h
}

type HaProxyBackendActionsItem struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendActionsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendActionsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendActionsItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendActionsItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The load balancing option to use for servers assigned to this backend.<br>
type HaProxyBackendBalance string

const (
	HaProxyBackendBalanceEmptyValue0 HaProxyBackendBalance = "empty_value_0"
	HaProxyBackendBalanceRoundrobin  HaProxyBackendBalance = "roundrobin"
	HaProxyBackendBalanceStaticRr    HaProxyBackendBalance = "static-rr"
	HaProxyBackendBalanceLeastconn   HaProxyBackendBalance = "leastconn"
	HaProxyBackendBalanceSource      HaProxyBackendBalance = "source"
	HaProxyBackendBalanceURI         HaProxyBackendBalance = "uri"
)

func NewHaProxyBackendBalanceFromString(s string) (HaProxyBackendBalance, error) {
	switch s {
	case "empty_value_0":
		return HaProxyBackendBalanceEmptyValue0, nil
	case "roundrobin":
		return HaProxyBackendBalanceRoundrobin, nil
	case "static-rr":
		return HaProxyBackendBalanceStaticRr, nil
	case "leastconn":
		return HaProxyBackendBalanceLeastconn, nil
	case "source":
		return HaProxyBackendBalanceSource, nil
	case "uri":
		return HaProxyBackendBalanceURI, nil
	}
	var t HaProxyBackendBalance
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendBalance) Ptr() *HaProxyBackendBalance {
	return &h
}

// The health check method to use when checking the health of backend servers.<br>
type HaProxyBackendCheckType string

const (
	HaProxyBackendCheckTypeNone       HaProxyBackendCheckType = "none"
	HaProxyBackendCheckTypeBasic      HaProxyBackendCheckType = "Basic"
	HaProxyBackendCheckTypeHTTP       HaProxyBackendCheckType = "HTTP"
	HaProxyBackendCheckTypeLdap       HaProxyBackendCheckType = "LDAP"
	HaProxyBackendCheckTypeMySQL      HaProxyBackendCheckType = "MySQL"
	HaProxyBackendCheckTypePostgreSQL HaProxyBackendCheckType = "PostgreSQL"
	HaProxyBackendCheckTypeRedis      HaProxyBackendCheckType = "Redis"
	HaProxyBackendCheckTypeSMTP       HaProxyBackendCheckType = "SMTP"
	HaProxyBackendCheckTypeEsmtp      HaProxyBackendCheckType = "ESMTP"
	HaProxyBackendCheckTypeSsl        HaProxyBackendCheckType = "SSL"
)

func NewHaProxyBackendCheckTypeFromString(s string) (HaProxyBackendCheckType, error) {
	switch s {
	case "none":
		return HaProxyBackendCheckTypeNone, nil
	case "Basic":
		return HaProxyBackendCheckTypeBasic, nil
	case "HTTP":
		return HaProxyBackendCheckTypeHTTP, nil
	case "LDAP":
		return HaProxyBackendCheckTypeLdap, nil
	case "MySQL":
		return HaProxyBackendCheckTypeMySQL, nil
	case "PostgreSQL":
		return HaProxyBackendCheckTypePostgreSQL, nil
	case "Redis":
		return HaProxyBackendCheckTypeRedis, nil
	case "SMTP":
		return HaProxyBackendCheckTypeSMTP, nil
	case "ESMTP":
		return HaProxyBackendCheckTypeEsmtp, nil
	case "SSL":
		return HaProxyBackendCheckTypeSsl, nil
	}
	var t HaProxyBackendCheckType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendCheckType) Ptr() *HaProxyBackendCheckType {
	return &h
}

// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
type HaProxyBackendEmailLevel string

const (
	HaProxyBackendEmailLevelEmptyValue0 HaProxyBackendEmailLevel = "empty_value_0"
	HaProxyBackendEmailLevelDontlog     HaProxyBackendEmailLevel = "dontlog"
	HaProxyBackendEmailLevelEmerg       HaProxyBackendEmailLevel = "emerg"
	HaProxyBackendEmailLevelAlert       HaProxyBackendEmailLevel = "alert"
	HaProxyBackendEmailLevelCrit        HaProxyBackendEmailLevel = "crit"
	HaProxyBackendEmailLevelErr         HaProxyBackendEmailLevel = "err"
	HaProxyBackendEmailLevelWarning     HaProxyBackendEmailLevel = "warning"
	HaProxyBackendEmailLevelNotice      HaProxyBackendEmailLevel = "notice"
	HaProxyBackendEmailLevelInfo        HaProxyBackendEmailLevel = "info"
	HaProxyBackendEmailLevelDebug       HaProxyBackendEmailLevel = "debug"
)

func NewHaProxyBackendEmailLevelFromString(s string) (HaProxyBackendEmailLevel, error) {
	switch s {
	case "empty_value_0":
		return HaProxyBackendEmailLevelEmptyValue0, nil
	case "dontlog":
		return HaProxyBackendEmailLevelDontlog, nil
	case "emerg":
		return HaProxyBackendEmailLevelEmerg, nil
	case "alert":
		return HaProxyBackendEmailLevelAlert, nil
	case "crit":
		return HaProxyBackendEmailLevelCrit, nil
	case "err":
		return HaProxyBackendEmailLevelErr, nil
	case "warning":
		return HaProxyBackendEmailLevelWarning, nil
	case "notice":
		return HaProxyBackendEmailLevelNotice, nil
	case "info":
		return HaProxyBackendEmailLevelInfo, nil
	case "debug":
		return HaProxyBackendEmailLevelDebug, nil
	}
	var t HaProxyBackendEmailLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendEmailLevel) Ptr() *HaProxyBackendEmailLevel {
	return &h
}

type HaProxyBackendErrorFile struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendErrorFile) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendErrorFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendErrorFile(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendErrorFile) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyBackendErrorfilesItem struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendErrorfilesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendErrorfilesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendErrorfilesItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendErrorfilesItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
type HaProxyBackendHttpcheckMethod string

const (
	HaProxyBackendHttpcheckMethodOptions HaProxyBackendHttpcheckMethod = "OPTIONS"
	HaProxyBackendHttpcheckMethodHead    HaProxyBackendHttpcheckMethod = "HEAD"
	HaProxyBackendHttpcheckMethodGet     HaProxyBackendHttpcheckMethod = "GET"
	HaProxyBackendHttpcheckMethodPost    HaProxyBackendHttpcheckMethod = "POST"
	HaProxyBackendHttpcheckMethodPut     HaProxyBackendHttpcheckMethod = "PUT"
	HaProxyBackendHttpcheckMethodDelete  HaProxyBackendHttpcheckMethod = "DELETE"
	HaProxyBackendHttpcheckMethodTrace   HaProxyBackendHttpcheckMethod = "TRACE"
)

func NewHaProxyBackendHttpcheckMethodFromString(s string) (HaProxyBackendHttpcheckMethod, error) {
	switch s {
	case "OPTIONS":
		return HaProxyBackendHttpcheckMethodOptions, nil
	case "HEAD":
		return HaProxyBackendHttpcheckMethodHead, nil
	case "GET":
		return HaProxyBackendHttpcheckMethodGet, nil
	case "POST":
		return HaProxyBackendHttpcheckMethodPost, nil
	case "PUT":
		return HaProxyBackendHttpcheckMethodPut, nil
	case "DELETE":
		return HaProxyBackendHttpcheckMethodDelete, nil
	case "TRACE":
		return HaProxyBackendHttpcheckMethodTrace, nil
	}
	var t HaProxyBackendHttpcheckMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendHttpcheckMethod) Ptr() *HaProxyBackendHttpcheckMethod {
	return &h
}

// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
type HaProxyBackendPersistCookieMode string

const (
	HaProxyBackendPersistCookieModePassive              HaProxyBackendPersistCookieMode = "passive"
	HaProxyBackendPersistCookieModePassiveSilent        HaProxyBackendPersistCookieMode = "passive-silent"
	HaProxyBackendPersistCookieModeReset                HaProxyBackendPersistCookieMode = "reset"
	HaProxyBackendPersistCookieModeSet                  HaProxyBackendPersistCookieMode = "set"
	HaProxyBackendPersistCookieModeSetSilent            HaProxyBackendPersistCookieMode = "set-silent"
	HaProxyBackendPersistCookieModeInsertOnly           HaProxyBackendPersistCookieMode = "insert-only"
	HaProxyBackendPersistCookieModeInsertOnlySilent     HaProxyBackendPersistCookieMode = "insert-only-silent"
	HaProxyBackendPersistCookieModeSessionPrefix        HaProxyBackendPersistCookieMode = "session-prefix"
	HaProxyBackendPersistCookieModePassiveSessionPrefix HaProxyBackendPersistCookieMode = "passive-session-prefix"
)

func NewHaProxyBackendPersistCookieModeFromString(s string) (HaProxyBackendPersistCookieMode, error) {
	switch s {
	case "passive":
		return HaProxyBackendPersistCookieModePassive, nil
	case "passive-silent":
		return HaProxyBackendPersistCookieModePassiveSilent, nil
	case "reset":
		return HaProxyBackendPersistCookieModeReset, nil
	case "set":
		return HaProxyBackendPersistCookieModeSet, nil
	case "set-silent":
		return HaProxyBackendPersistCookieModeSetSilent, nil
	case "insert-only":
		return HaProxyBackendPersistCookieModeInsertOnly, nil
	case "insert-only-silent":
		return HaProxyBackendPersistCookieModeInsertOnlySilent, nil
	case "session-prefix":
		return HaProxyBackendPersistCookieModeSessionPrefix, nil
	case "passive-session-prefix":
		return HaProxyBackendPersistCookieModePassiveSessionPrefix, nil
	}
	var t HaProxyBackendPersistCookieMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendPersistCookieMode) Ptr() *HaProxyBackendPersistCookieMode {
	return &h
}

// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
type HaProxyBackendPersistStickyType string

const (
	HaProxyBackendPersistStickyTypeNone              HaProxyBackendPersistStickyType = "none"
	HaProxyBackendPersistStickyTypeStickSslsessionid HaProxyBackendPersistStickyType = "stick_sslsessionid"
	HaProxyBackendPersistStickyTypeStickSourceipv4   HaProxyBackendPersistStickyType = "stick_sourceipv4"
	HaProxyBackendPersistStickyTypeStickSourceipv6   HaProxyBackendPersistStickyType = "stick_sourceipv6"
	HaProxyBackendPersistStickyTypeStickCookieValue  HaProxyBackendPersistStickyType = "stick_cookie_value"
	HaProxyBackendPersistStickyTypeStickRdpCookie    HaProxyBackendPersistStickyType = "stick_rdp_cookie"
)

func NewHaProxyBackendPersistStickyTypeFromString(s string) (HaProxyBackendPersistStickyType, error) {
	switch s {
	case "none":
		return HaProxyBackendPersistStickyTypeNone, nil
	case "stick_sslsessionid":
		return HaProxyBackendPersistStickyTypeStickSslsessionid, nil
	case "stick_sourceipv4":
		return HaProxyBackendPersistStickyTypeStickSourceipv4, nil
	case "stick_sourceipv6":
		return HaProxyBackendPersistStickyTypeStickSourceipv6, nil
	case "stick_cookie_value":
		return HaProxyBackendPersistStickyTypeStickCookieValue, nil
	case "stick_rdp_cookie":
		return HaProxyBackendPersistStickyTypeStickRdpCookie, nil
	}
	var t HaProxyBackendPersistStickyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendPersistStickyType) Ptr() *HaProxyBackendPersistStickyType {
	return &h
}

type HaProxyBackendServer struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendServer) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendServer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendServer(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendServer) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The eligibility status for this backend server.<br>
type HaProxyBackendServerStatus string

const (
	HaProxyBackendServerStatusActive   HaProxyBackendServerStatus = "active"
	HaProxyBackendServerStatusBackup   HaProxyBackendServerStatus = "backup"
	HaProxyBackendServerStatusDisabled HaProxyBackendServerStatus = "disabled"
	HaProxyBackendServerStatusInactive HaProxyBackendServerStatus = "inactive"
)

func NewHaProxyBackendServerStatusFromString(s string) (HaProxyBackendServerStatus, error) {
	switch s {
	case "active":
		return HaProxyBackendServerStatusActive, nil
	case "backup":
		return HaProxyBackendServerStatusBackup, nil
	case "disabled":
		return HaProxyBackendServerStatusDisabled, nil
	case "inactive":
		return HaProxyBackendServerStatusInactive, nil
	}
	var t HaProxyBackendServerStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyBackendServerStatus) Ptr() *HaProxyBackendServerStatus {
	return &h
}

type HaProxyBackendServersItem struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyBackendServersItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyBackendServersItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyBackendServersItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyBackendServersItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyDNSResolver struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyDNSResolver) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyDNSResolver
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyDNSResolver(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyDNSResolver) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyEmailMailer struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyEmailMailer) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyEmailMailer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyEmailMailer(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyEmailMailer) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFile struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFile) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFile(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFile) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The type of file. Use `null` to assume an Errorfile.<br>
type HaProxyFileType string

const (
	HaProxyFileTypeLuascript   HaProxyFileType = "luascript"
	HaProxyFileTypeWritetodisk HaProxyFileType = "writetodisk"
)

func NewHaProxyFileTypeFromString(s string) (HaProxyFileType, error) {
	switch s {
	case "luascript":
		return HaProxyFileTypeLuascript, nil
	case "writetodisk":
		return HaProxyFileTypeWritetodisk, nil
	}
	var t HaProxyFileType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyFileType) Ptr() *HaProxyFileType {
	return &h
}

type HaProxyFrontend struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontend) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontend
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontend(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontend) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFrontendAActionitemsItem struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendAActionitemsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendAActionitemsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendAActionitemsItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendAActionitemsItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFrontendAErrorfilesItem struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendAErrorfilesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendAErrorfilesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendAErrorfilesItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendAErrorfilesItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFrontendAExtaddrItem struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendAExtaddrItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendAExtaddrItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendAExtaddrItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendAExtaddrItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFrontendACL struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendACL) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendACL
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendACL(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendACL) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The expression to use to determine the match for this ACL.<br>
type HaProxyFrontendACLExpression string

const (
	HaProxyFrontendACLExpressionHostStartsWith     HaProxyFrontendACLExpression = "host_starts_with"
	HaProxyFrontendACLExpressionHostEndsWith       HaProxyFrontendACLExpression = "host_ends_with"
	HaProxyFrontendACLExpressionHostMatches        HaProxyFrontendACLExpression = "host_matches"
	HaProxyFrontendACLExpressionHostRegex          HaProxyFrontendACLExpression = "host_regex"
	HaProxyFrontendACLExpressionHostContains       HaProxyFrontendACLExpression = "host_contains"
	HaProxyFrontendACLExpressionPathStartsWith     HaProxyFrontendACLExpression = "path_starts_with"
	HaProxyFrontendACLExpressionPathEndsWith       HaProxyFrontendACLExpression = "path_ends_with"
	HaProxyFrontendACLExpressionPathMatches        HaProxyFrontendACLExpression = "path_matches"
	HaProxyFrontendACLExpressionPathRegex          HaProxyFrontendACLExpression = "path_regex"
	HaProxyFrontendACLExpressionPathContains       HaProxyFrontendACLExpression = "path_contains"
	HaProxyFrontendACLExpressionPathDir            HaProxyFrontendACLExpression = "path_dir"
	HaProxyFrontendACLExpressionURLParameter       HaProxyFrontendACLExpression = "url_parameter"
	HaProxyFrontendACLExpressionSslCVerifyCode     HaProxyFrontendACLExpression = "ssl_c_verify_code"
	HaProxyFrontendACLExpressionSslCVerify         HaProxyFrontendACLExpression = "ssl_c_verify"
	HaProxyFrontendACLExpressionSslCCaCommonname   HaProxyFrontendACLExpression = "ssl_c_ca_commonname"
	HaProxyFrontendACLExpressionSourceIP           HaProxyFrontendACLExpression = "source_ip"
	HaProxyFrontendACLExpressionBackendservercount HaProxyFrontendACLExpression = "backendservercount"
	HaProxyFrontendACLExpressionTrafficIsHTTP      HaProxyFrontendACLExpression = "traffic_is_http"
	HaProxyFrontendACLExpressionTrafficIsSsl       HaProxyFrontendACLExpression = "traffic_is_ssl"
	HaProxyFrontendACLExpressionSslSniMatches      HaProxyFrontendACLExpression = "ssl_sni_matches"
	HaProxyFrontendACLExpressionSslSniContains     HaProxyFrontendACLExpression = "ssl_sni_contains"
	HaProxyFrontendACLExpressionSslSniStartsWith   HaProxyFrontendACLExpression = "ssl_sni_starts_with"
	HaProxyFrontendACLExpressionSslSniEndsWith     HaProxyFrontendACLExpression = "ssl_sni_ends_with"
	HaProxyFrontendACLExpressionSslSniRegex        HaProxyFrontendACLExpression = "ssl_sni_regex"
	HaProxyFrontendACLExpressionCustom             HaProxyFrontendACLExpression = "custom"
)

func NewHaProxyFrontendACLExpressionFromString(s string) (HaProxyFrontendACLExpression, error) {
	switch s {
	case "host_starts_with":
		return HaProxyFrontendACLExpressionHostStartsWith, nil
	case "host_ends_with":
		return HaProxyFrontendACLExpressionHostEndsWith, nil
	case "host_matches":
		return HaProxyFrontendACLExpressionHostMatches, nil
	case "host_regex":
		return HaProxyFrontendACLExpressionHostRegex, nil
	case "host_contains":
		return HaProxyFrontendACLExpressionHostContains, nil
	case "path_starts_with":
		return HaProxyFrontendACLExpressionPathStartsWith, nil
	case "path_ends_with":
		return HaProxyFrontendACLExpressionPathEndsWith, nil
	case "path_matches":
		return HaProxyFrontendACLExpressionPathMatches, nil
	case "path_regex":
		return HaProxyFrontendACLExpressionPathRegex, nil
	case "path_contains":
		return HaProxyFrontendACLExpressionPathContains, nil
	case "path_dir":
		return HaProxyFrontendACLExpressionPathDir, nil
	case "url_parameter":
		return HaProxyFrontendACLExpressionURLParameter, nil
	case "ssl_c_verify_code":
		return HaProxyFrontendACLExpressionSslCVerifyCode, nil
	case "ssl_c_verify":
		return HaProxyFrontendACLExpressionSslCVerify, nil
	case "ssl_c_ca_commonname":
		return HaProxyFrontendACLExpressionSslCCaCommonname, nil
	case "source_ip":
		return HaProxyFrontendACLExpressionSourceIP, nil
	case "backendservercount":
		return HaProxyFrontendACLExpressionBackendservercount, nil
	case "traffic_is_http":
		return HaProxyFrontendACLExpressionTrafficIsHTTP, nil
	case "traffic_is_ssl":
		return HaProxyFrontendACLExpressionTrafficIsSsl, nil
	case "ssl_sni_matches":
		return HaProxyFrontendACLExpressionSslSniMatches, nil
	case "ssl_sni_contains":
		return HaProxyFrontendACLExpressionSslSniContains, nil
	case "ssl_sni_starts_with":
		return HaProxyFrontendACLExpressionSslSniStartsWith, nil
	case "ssl_sni_ends_with":
		return HaProxyFrontendACLExpressionSslSniEndsWith, nil
	case "ssl_sni_regex":
		return HaProxyFrontendACLExpressionSslSniRegex, nil
	case "custom":
		return HaProxyFrontendACLExpressionCustom, nil
	}
	var t HaProxyFrontendACLExpression
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyFrontendACLExpression) Ptr() *HaProxyFrontendACLExpression {
	return &h
}

type HaProxyFrontendAction struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason *string `json:"reason,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendAction) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendAction(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendAction) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The action to take when an ACL match is found.<br>
type HaProxyFrontendActionAction string

const (
	HaProxyFrontendActionActionUseBackend                     HaProxyFrontendActionAction = "use_backend"
	HaProxyFrontendActionActionCustom                         HaProxyFrontendActionAction = "custom"
	HaProxyFrontendActionActionHTTPRequestAllow               HaProxyFrontendActionAction = "http-request_allow"
	HaProxyFrontendActionActionHTTPRequestDeny                HaProxyFrontendActionAction = "http-request_deny"
	HaProxyFrontendActionActionHTTPRequestTarpit              HaProxyFrontendActionAction = "http-request_tarpit"
	HaProxyFrontendActionActionHTTPRequestAuth                HaProxyFrontendActionAction = "http-request_auth"
	HaProxyFrontendActionActionHTTPRequestRedirect            HaProxyFrontendActionAction = "http-request_redirect"
	HaProxyFrontendActionActionHTTPRequestLua                 HaProxyFrontendActionAction = "http-request_lua"
	HaProxyFrontendActionActionHTTPRequestUseService          HaProxyFrontendActionAction = "http-request_use-service"
	HaProxyFrontendActionActionHTTPRequestAddHeader           HaProxyFrontendActionAction = "http-request_add-header"
	HaProxyFrontendActionActionHTTPRequestSetHeader           HaProxyFrontendActionAction = "http-request_set-header"
	HaProxyFrontendActionActionHTTPRequestDelHeader           HaProxyFrontendActionAction = "http-request_del-header"
	HaProxyFrontendActionActionHTTPRequestReplaceHeader       HaProxyFrontendActionAction = "http-request_replace-header"
	HaProxyFrontendActionActionHTTPRequestReplacePath         HaProxyFrontendActionAction = "http-request_replace-path"
	HaProxyFrontendActionActionHTTPRequestReplaceValue        HaProxyFrontendActionAction = "http-request_replace-value"
	HaProxyFrontendActionActionHTTPRequestSetMethod           HaProxyFrontendActionAction = "http-request_set-method"
	HaProxyFrontendActionActionHTTPRequestSetPath             HaProxyFrontendActionAction = "http-request_set-path"
	HaProxyFrontendActionActionHTTPRequestSetQuery            HaProxyFrontendActionAction = "http-request_set-query"
	HaProxyFrontendActionActionHTTPRequestSetURI              HaProxyFrontendActionAction = "http-request_set-uri"
	HaProxyFrontendActionActionHTTPResponseAllow              HaProxyFrontendActionAction = "http-response_allow"
	HaProxyFrontendActionActionHTTPResponseDeny               HaProxyFrontendActionAction = "http-response_deny"
	HaProxyFrontendActionActionHTTPResponseLua                HaProxyFrontendActionAction = "http-response_lua"
	HaProxyFrontendActionActionHTTPResponseAddHeader          HaProxyFrontendActionAction = "http-response_add-header"
	HaProxyFrontendActionActionHTTPResponseSetHeader          HaProxyFrontendActionAction = "http-response_set-header"
	HaProxyFrontendActionActionHTTPResponseDelHeader          HaProxyFrontendActionAction = "http-response_del-header"
	HaProxyFrontendActionActionHTTPResponseReplaceHeader      HaProxyFrontendActionAction = "http-response_replace-header"
	HaProxyFrontendActionActionHTTPResponseReplaceValue       HaProxyFrontendActionAction = "http-response_replace-value"
	HaProxyFrontendActionActionHTTPResponseSetStatus          HaProxyFrontendActionAction = "http-response_set-status"
	HaProxyFrontendActionActionHTTPAfterResponseAddHeader     HaProxyFrontendActionAction = "http-after-response_add-header"
	HaProxyFrontendActionActionHTTPAfterResponseSetHeader     HaProxyFrontendActionAction = "http-after-response_set-header"
	HaProxyFrontendActionActionHTTPAfterResponseDelHeader     HaProxyFrontendActionAction = "http-after-response_del-header"
	HaProxyFrontendActionActionHTTPAfterResponseReplaceHeader HaProxyFrontendActionAction = "http-after-response_replace-header"
	HaProxyFrontendActionActionHTTPAfterResponseReplaceValue  HaProxyFrontendActionAction = "http-after-response_replace-value"
	HaProxyFrontendActionActionHTTPAfterResponseSetStatus     HaProxyFrontendActionAction = "http-after-response_set-status"
	HaProxyFrontendActionActionTCPRequestConnectionAccept     HaProxyFrontendActionAction = "tcp-request_connection_accept"
	HaProxyFrontendActionActionTCPRequestConnectionReject     HaProxyFrontendActionAction = "tcp-request_connection_reject"
	HaProxyFrontendActionActionTCPRequestContentAccept        HaProxyFrontendActionAction = "tcp-request_content_accept"
	HaProxyFrontendActionActionTCPRequestContentReject        HaProxyFrontendActionAction = "tcp-request_content_reject"
	HaProxyFrontendActionActionTCPRequestContentLua           HaProxyFrontendActionAction = "tcp-request_content_lua"
	HaProxyFrontendActionActionTCPRequestContentUseService    HaProxyFrontendActionAction = "tcp-request_content_use-service"
	HaProxyFrontendActionActionTCPResponseContentAccept       HaProxyFrontendActionAction = "tcp-response_content_accept"
	HaProxyFrontendActionActionTCPResponseContentClose        HaProxyFrontendActionAction = "tcp-response_content_close"
	HaProxyFrontendActionActionTCPResponseContentReject       HaProxyFrontendActionAction = "tcp-response_content_reject"
	HaProxyFrontendActionActionTCPResponseContentLua          HaProxyFrontendActionAction = "tcp-response_content_lua"
)

func NewHaProxyFrontendActionActionFromString(s string) (HaProxyFrontendActionAction, error) {
	switch s {
	case "use_backend":
		return HaProxyFrontendActionActionUseBackend, nil
	case "custom":
		return HaProxyFrontendActionActionCustom, nil
	case "http-request_allow":
		return HaProxyFrontendActionActionHTTPRequestAllow, nil
	case "http-request_deny":
		return HaProxyFrontendActionActionHTTPRequestDeny, nil
	case "http-request_tarpit":
		return HaProxyFrontendActionActionHTTPRequestTarpit, nil
	case "http-request_auth":
		return HaProxyFrontendActionActionHTTPRequestAuth, nil
	case "http-request_redirect":
		return HaProxyFrontendActionActionHTTPRequestRedirect, nil
	case "http-request_lua":
		return HaProxyFrontendActionActionHTTPRequestLua, nil
	case "http-request_use-service":
		return HaProxyFrontendActionActionHTTPRequestUseService, nil
	case "http-request_add-header":
		return HaProxyFrontendActionActionHTTPRequestAddHeader, nil
	case "http-request_set-header":
		return HaProxyFrontendActionActionHTTPRequestSetHeader, nil
	case "http-request_del-header":
		return HaProxyFrontendActionActionHTTPRequestDelHeader, nil
	case "http-request_replace-header":
		return HaProxyFrontendActionActionHTTPRequestReplaceHeader, nil
	case "http-request_replace-path":
		return HaProxyFrontendActionActionHTTPRequestReplacePath, nil
	case "http-request_replace-value":
		return HaProxyFrontendActionActionHTTPRequestReplaceValue, nil
	case "http-request_set-method":
		return HaProxyFrontendActionActionHTTPRequestSetMethod, nil
	case "http-request_set-path":
		return HaProxyFrontendActionActionHTTPRequestSetPath, nil
	case "http-request_set-query":
		return HaProxyFrontendActionActionHTTPRequestSetQuery, nil
	case "http-request_set-uri":
		return HaProxyFrontendActionActionHTTPRequestSetURI, nil
	case "http-response_allow":
		return HaProxyFrontendActionActionHTTPResponseAllow, nil
	case "http-response_deny":
		return HaProxyFrontendActionActionHTTPResponseDeny, nil
	case "http-response_lua":
		return HaProxyFrontendActionActionHTTPResponseLua, nil
	case "http-response_add-header":
		return HaProxyFrontendActionActionHTTPResponseAddHeader, nil
	case "http-response_set-header":
		return HaProxyFrontendActionActionHTTPResponseSetHeader, nil
	case "http-response_del-header":
		return HaProxyFrontendActionActionHTTPResponseDelHeader, nil
	case "http-response_replace-header":
		return HaProxyFrontendActionActionHTTPResponseReplaceHeader, nil
	case "http-response_replace-value":
		return HaProxyFrontendActionActionHTTPResponseReplaceValue, nil
	case "http-response_set-status":
		return HaProxyFrontendActionActionHTTPResponseSetStatus, nil
	case "http-after-response_add-header":
		return HaProxyFrontendActionActionHTTPAfterResponseAddHeader, nil
	case "http-after-response_set-header":
		return HaProxyFrontendActionActionHTTPAfterResponseSetHeader, nil
	case "http-after-response_del-header":
		return HaProxyFrontendActionActionHTTPAfterResponseDelHeader, nil
	case "http-after-response_replace-header":
		return HaProxyFrontendActionActionHTTPAfterResponseReplaceHeader, nil
	case "http-after-response_replace-value":
		return HaProxyFrontendActionActionHTTPAfterResponseReplaceValue, nil
	case "http-after-response_set-status":
		return HaProxyFrontendActionActionHTTPAfterResponseSetStatus, nil
	case "tcp-request_connection_accept":
		return HaProxyFrontendActionActionTCPRequestConnectionAccept, nil
	case "tcp-request_connection_reject":
		return HaProxyFrontendActionActionTCPRequestConnectionReject, nil
	case "tcp-request_content_accept":
		return HaProxyFrontendActionActionTCPRequestContentAccept, nil
	case "tcp-request_content_reject":
		return HaProxyFrontendActionActionTCPRequestContentReject, nil
	case "tcp-request_content_lua":
		return HaProxyFrontendActionActionTCPRequestContentLua, nil
	case "tcp-request_content_use-service":
		return HaProxyFrontendActionActionTCPRequestContentUseService, nil
	case "tcp-response_content_accept":
		return HaProxyFrontendActionActionTCPResponseContentAccept, nil
	case "tcp-response_content_close":
		return HaProxyFrontendActionActionTCPResponseContentClose, nil
	case "tcp-response_content_reject":
		return HaProxyFrontendActionActionTCPResponseContentReject, nil
	case "tcp-response_content_lua":
		return HaProxyFrontendActionActionTCPResponseContentLua, nil
	}
	var t HaProxyFrontendActionAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyFrontendActionAction) Ptr() *HaProxyFrontendActionAction {
	return &h
}

type HaProxyFrontendAddress struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendAddress(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendAddress) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The external address to use.<br>
type HaProxyFrontendAddressExtaddr string

const (
	HaProxyFrontendAddressExtaddrCustom        HaProxyFrontendAddressExtaddr = "custom"
	HaProxyFrontendAddressExtaddrAnyIpv4       HaProxyFrontendAddressExtaddr = "any_ipv4"
	HaProxyFrontendAddressExtaddrAnyIpv6       HaProxyFrontendAddressExtaddr = "any_ipv6"
	HaProxyFrontendAddressExtaddrLocalhostIpv4 HaProxyFrontendAddressExtaddr = "localhost_ipv4"
	HaProxyFrontendAddressExtaddrLocalhostIpv6 HaProxyFrontendAddressExtaddr = "localhost_ipv6"
)

func NewHaProxyFrontendAddressExtaddrFromString(s string) (HaProxyFrontendAddressExtaddr, error) {
	switch s {
	case "custom":
		return HaProxyFrontendAddressExtaddrCustom, nil
	case "any_ipv4":
		return HaProxyFrontendAddressExtaddrAnyIpv4, nil
	case "any_ipv6":
		return HaProxyFrontendAddressExtaddrAnyIpv6, nil
	case "localhost_ipv4":
		return HaProxyFrontendAddressExtaddrLocalhostIpv4, nil
	case "localhost_ipv6":
		return HaProxyFrontendAddressExtaddrLocalhostIpv6, nil
	}
	var t HaProxyFrontendAddressExtaddr
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyFrontendAddressExtaddr) Ptr() *HaProxyFrontendAddressExtaddr {
	return &h
}

type HaProxyFrontendCertificate struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendCertificate) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendCertificate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendCertificate(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendCertificate) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFrontendErrorFile struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendErrorFile) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendErrorFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendErrorFile(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendErrorFile) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFrontendHaACLsItem struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not *bool `json:"not,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendHaACLsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendHaACLsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendHaACLsItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendHaACLsItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxyFrontendHaCertificatesItem struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxyFrontendHaCertificatesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxyFrontendHaCertificatesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxyFrontendHaCertificatesItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxyFrontendHaCertificatesItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The `httpclose` option this frontend will operate.<br>
type HaProxyFrontendHttpclose string

const (
	HaProxyFrontendHttpcloseHTTPKeepAlive   HaProxyFrontendHttpclose = "http-keep-alive"
	HaProxyFrontendHttpcloseHTTPTunnel      HaProxyFrontendHttpclose = "http-tunnel"
	HaProxyFrontendHttpcloseHttpclose       HaProxyFrontendHttpclose = "httpclose"
	HaProxyFrontendHttpcloseHTTPServerClose HaProxyFrontendHttpclose = "http-server-close"
	HaProxyFrontendHttpcloseForceclose      HaProxyFrontendHttpclose = "forceclose"
)

func NewHaProxyFrontendHttpcloseFromString(s string) (HaProxyFrontendHttpclose, error) {
	switch s {
	case "http-keep-alive":
		return HaProxyFrontendHttpcloseHTTPKeepAlive, nil
	case "http-tunnel":
		return HaProxyFrontendHttpcloseHTTPTunnel, nil
	case "httpclose":
		return HaProxyFrontendHttpcloseHttpclose, nil
	case "http-server-close":
		return HaProxyFrontendHttpcloseHTTPServerClose, nil
	case "forceclose":
		return HaProxyFrontendHttpcloseForceclose, nil
	}
	var t HaProxyFrontendHttpclose
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyFrontendHttpclose) Ptr() *HaProxyFrontendHttpclose {
	return &h
}

// The activation status for this HAProxy frontend.<br>
type HaProxyFrontendStatus string

const (
	HaProxyFrontendStatusActive   HaProxyFrontendStatus = "active"
	HaProxyFrontendStatusDisabled HaProxyFrontendStatus = "disabled"
)

func NewHaProxyFrontendStatusFromString(s string) (HaProxyFrontendStatus, error) {
	switch s {
	case "active":
		return HaProxyFrontendStatusActive, nil
	case "disabled":
		return HaProxyFrontendStatusDisabled, nil
	}
	var t HaProxyFrontendStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyFrontendStatus) Ptr() *HaProxyFrontendStatus {
	return &h
}

// The processing type for this frontend.<br>
type HaProxyFrontendType string

const (
	HaProxyFrontendTypeHTTP  HaProxyFrontendType = "http"
	HaProxyFrontendTypeHTTPS HaProxyFrontendType = "https"
	HaProxyFrontendTypeTCP   HaProxyFrontendType = "tcp"
)

func NewHaProxyFrontendTypeFromString(s string) (HaProxyFrontendType, error) {
	switch s {
	case "http":
		return HaProxyFrontendTypeHTTP, nil
	case "https":
		return HaProxyFrontendTypeHTTPS, nil
	case "tcp":
		return HaProxyFrontendTypeTCP, nil
	}
	var t HaProxyFrontendType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxyFrontendType) Ptr() *HaProxyFrontendType {
	return &h
}

type HaProxySettings struct {
	// Enables or disable HAProxy on the system.<br>
	Enable *bool `json:"enable,omitempty"`
	// The maximum per-process number of concurrent connections<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// The number of threads to start per process. This setting is experimental.<br>
	Nbthread *int `json:"nbthread,omitempty"`
	// Enables or disables an immediate stop of old process on reload. (closes existing connections)<br>
	TerminateOnReload *bool `json:"terminate_on_reload,omitempty"`
	// The maximum time allowed to perform a clean soft-stop. This can be represented as different time values such as 30s, 15m, 3h or 1d.<br>
	HardStopAfter *string `json:"hard_stop_after,omitempty"`
	// The CARP interface IP to monitor. HAProxy will only run on the firewall whose interface is MASTER.<br>
	Carpdev *string `json:"carpdev,omitempty"`
	// The internal port to be used for the stats tab. Set to null to disable local stats. Valid options are: a TCP/UDP port number<br>
	Localstatsport *string `json:"localstatsport,omitempty"`
	// The internal (in seconds) in which local stats will be refreshed.<br>
	LocalstatsRefreshtime *int `json:"localstats_refreshtime,omitempty"`
	// The internal (in seconds) in which the sticktable stats will be refreshed.<br>
	LocalstatsSticktableRefreshtime *int `json:"localstats_sticktable_refreshtime,omitempty"`
	// The IP address or hostname of the remote syslog server to send logs to. Use `/var/run/log` to to log to the local pfSense system log.<br>
	Remotesyslog *string `json:"remotesyslog,omitempty"`
	// The logging facility to log to.<br>
	Logfacility *HaProxySettingsLogfacility `json:"logfacility,omitempty"`
	// The log level to begin logging events. Only events of this level or higher will be logged.<br>
	Loglevel *HaProxySettingsLoglevel `json:"loglevel,omitempty"`
	// The hostname field to include in the syslog header. Leave empty to use the system hostname.<br>
	LogSendHostname *string `json:"log_send_hostname,omitempty"`
	// The DNS resolvers HAProxy will use for DNS queries.<br>
	DNSResolvers []*HaProxySettingsDNSResolversItem `json:"dns_resolvers,omitempty"`
	// The number of queries to send to resolve a server name before giving up.<br>
	ResolverRetries *int `json:"resolver_retries,omitempty"`
	// The time between two DNS queries, when no response have been received.<br>
	ResolverTimeoutretry *string `json:"resolver_timeoutretry,omitempty"`
	// The interval between two successive name resolution when the last answer was valid.<br>
	ResolverHoldvalid *string `json:"resolver_holdvalid,omitempty"`
	// The email servers HAProxy will use to send SMTP alerts.<br>
	EmailMailers []*HaProxySettingsEmailMailersItem `json:"email_mailers,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts.<br>
	EmailLevel *HaProxySettingsEmailLevel `json:"email_level,omitempty"`
	// The hostname to use as the origin of the email.<br>
	EmailMyhostname *string `json:"email_myhostname,omitempty"`
	// The email address to be used as the sender of the emails.<br>
	EmailFrom *string `json:"email_from,omitempty"`
	// The email address to send emails to.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// The SSL/TLS compatibility mode which determines the cipher suites and TLS versions supported.<br>
	Sslcompatibilitymode *HaProxySettingsSslcompatibilitymode `json:"sslcompatibilitymode,omitempty"`
	// The maximum size of the Diffie-Hellman parameters used for generating the ephemeral/temporary Diffie-Hellman key in case of DHE key exchange<br>
	Ssldefaultdhparam *int `json:"ssldefaultdhparam,omitempty"`
	// Additional HAProxy options to include in the global settings area.<br>
	Advanced *string `json:"advanced,omitempty"`
	// Enables or disables including HAProxy configurations in HA sync if configured.<br>
	Enablesync *bool `json:"enablesync,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxySettings) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxySettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxySettings(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxySettings) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type HaProxySettingsDNSResolversItem struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxySettingsDNSResolversItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxySettingsDNSResolversItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxySettingsDNSResolversItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxySettingsDNSResolversItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The maximum log level to send emails for. Leave empty to disable sending email alerts.<br>
type HaProxySettingsEmailLevel string

const (
	HaProxySettingsEmailLevelEmptyValue0 HaProxySettingsEmailLevel = "empty_value_0"
	HaProxySettingsEmailLevelEmerg       HaProxySettingsEmailLevel = "emerg"
	HaProxySettingsEmailLevelAlert       HaProxySettingsEmailLevel = "alert"
	HaProxySettingsEmailLevelCrit        HaProxySettingsEmailLevel = "crit"
	HaProxySettingsEmailLevelErr         HaProxySettingsEmailLevel = "err"
	HaProxySettingsEmailLevelWarning     HaProxySettingsEmailLevel = "warning"
	HaProxySettingsEmailLevelNotice      HaProxySettingsEmailLevel = "notice"
	HaProxySettingsEmailLevelInfo        HaProxySettingsEmailLevel = "info"
	HaProxySettingsEmailLevelDebug       HaProxySettingsEmailLevel = "debug"
)

func NewHaProxySettingsEmailLevelFromString(s string) (HaProxySettingsEmailLevel, error) {
	switch s {
	case "empty_value_0":
		return HaProxySettingsEmailLevelEmptyValue0, nil
	case "emerg":
		return HaProxySettingsEmailLevelEmerg, nil
	case "alert":
		return HaProxySettingsEmailLevelAlert, nil
	case "crit":
		return HaProxySettingsEmailLevelCrit, nil
	case "err":
		return HaProxySettingsEmailLevelErr, nil
	case "warning":
		return HaProxySettingsEmailLevelWarning, nil
	case "notice":
		return HaProxySettingsEmailLevelNotice, nil
	case "info":
		return HaProxySettingsEmailLevelInfo, nil
	case "debug":
		return HaProxySettingsEmailLevelDebug, nil
	}
	var t HaProxySettingsEmailLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxySettingsEmailLevel) Ptr() *HaProxySettingsEmailLevel {
	return &h
}

type HaProxySettingsEmailMailersItem struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HaProxySettingsEmailMailersItem) UnmarshalJSON(data []byte) error {
	type unmarshaler HaProxySettingsEmailMailersItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HaProxySettingsEmailMailersItem(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HaProxySettingsEmailMailersItem) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The logging facility to log to.<br>
type HaProxySettingsLogfacility string

const (
	HaProxySettingsLogfacilityKern   HaProxySettingsLogfacility = "kern"
	HaProxySettingsLogfacilityUser   HaProxySettingsLogfacility = "user"
	HaProxySettingsLogfacilityMail   HaProxySettingsLogfacility = "mail"
	HaProxySettingsLogfacilityDaemon HaProxySettingsLogfacility = "daemon"
	HaProxySettingsLogfacilityAuth   HaProxySettingsLogfacility = "auth"
	HaProxySettingsLogfacilitySyslog HaProxySettingsLogfacility = "syslog"
	HaProxySettingsLogfacilityLpr    HaProxySettingsLogfacility = "lpr"
	HaProxySettingsLogfacilityNews   HaProxySettingsLogfacility = "news"
	HaProxySettingsLogfacilityUucp   HaProxySettingsLogfacility = "uucp"
	HaProxySettingsLogfacilityCron   HaProxySettingsLogfacility = "cron"
	HaProxySettingsLogfacilityAuth2  HaProxySettingsLogfacility = "auth2"
	HaProxySettingsLogfacilityFtp    HaProxySettingsLogfacility = "ftp"
	HaProxySettingsLogfacilityNtp    HaProxySettingsLogfacility = "ntp"
	HaProxySettingsLogfacilityAudit  HaProxySettingsLogfacility = "audit"
	HaProxySettingsLogfacilityCron2  HaProxySettingsLogfacility = "cron2"
	HaProxySettingsLogfacilityLocal0 HaProxySettingsLogfacility = "local0"
	HaProxySettingsLogfacilityLocal1 HaProxySettingsLogfacility = "local1"
	HaProxySettingsLogfacilityLocal2 HaProxySettingsLogfacility = "local2"
	HaProxySettingsLogfacilityLocal3 HaProxySettingsLogfacility = "local3"
	HaProxySettingsLogfacilityLocal4 HaProxySettingsLogfacility = "local4"
	HaProxySettingsLogfacilityLocal5 HaProxySettingsLogfacility = "local5"
	HaProxySettingsLogfacilityLocal6 HaProxySettingsLogfacility = "local6"
	HaProxySettingsLogfacilityLocal7 HaProxySettingsLogfacility = "local7"
)

func NewHaProxySettingsLogfacilityFromString(s string) (HaProxySettingsLogfacility, error) {
	switch s {
	case "kern":
		return HaProxySettingsLogfacilityKern, nil
	case "user":
		return HaProxySettingsLogfacilityUser, nil
	case "mail":
		return HaProxySettingsLogfacilityMail, nil
	case "daemon":
		return HaProxySettingsLogfacilityDaemon, nil
	case "auth":
		return HaProxySettingsLogfacilityAuth, nil
	case "syslog":
		return HaProxySettingsLogfacilitySyslog, nil
	case "lpr":
		return HaProxySettingsLogfacilityLpr, nil
	case "news":
		return HaProxySettingsLogfacilityNews, nil
	case "uucp":
		return HaProxySettingsLogfacilityUucp, nil
	case "cron":
		return HaProxySettingsLogfacilityCron, nil
	case "auth2":
		return HaProxySettingsLogfacilityAuth2, nil
	case "ftp":
		return HaProxySettingsLogfacilityFtp, nil
	case "ntp":
		return HaProxySettingsLogfacilityNtp, nil
	case "audit":
		return HaProxySettingsLogfacilityAudit, nil
	case "cron2":
		return HaProxySettingsLogfacilityCron2, nil
	case "local0":
		return HaProxySettingsLogfacilityLocal0, nil
	case "local1":
		return HaProxySettingsLogfacilityLocal1, nil
	case "local2":
		return HaProxySettingsLogfacilityLocal2, nil
	case "local3":
		return HaProxySettingsLogfacilityLocal3, nil
	case "local4":
		return HaProxySettingsLogfacilityLocal4, nil
	case "local5":
		return HaProxySettingsLogfacilityLocal5, nil
	case "local6":
		return HaProxySettingsLogfacilityLocal6, nil
	case "local7":
		return HaProxySettingsLogfacilityLocal7, nil
	}
	var t HaProxySettingsLogfacility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxySettingsLogfacility) Ptr() *HaProxySettingsLogfacility {
	return &h
}

// The log level to begin logging events. Only events of this level or higher will be logged.<br>
type HaProxySettingsLoglevel string

const (
	HaProxySettingsLoglevelEmerg   HaProxySettingsLoglevel = "emerg"
	HaProxySettingsLoglevelAlert   HaProxySettingsLoglevel = "alert"
	HaProxySettingsLoglevelCrit    HaProxySettingsLoglevel = "crit"
	HaProxySettingsLoglevelErr     HaProxySettingsLoglevel = "err"
	HaProxySettingsLoglevelWarning HaProxySettingsLoglevel = "warning"
	HaProxySettingsLoglevelNotice  HaProxySettingsLoglevel = "notice"
	HaProxySettingsLoglevelInfo    HaProxySettingsLoglevel = "info"
	HaProxySettingsLoglevelDebug   HaProxySettingsLoglevel = "debug"
)

func NewHaProxySettingsLoglevelFromString(s string) (HaProxySettingsLoglevel, error) {
	switch s {
	case "emerg":
		return HaProxySettingsLoglevelEmerg, nil
	case "alert":
		return HaProxySettingsLoglevelAlert, nil
	case "crit":
		return HaProxySettingsLoglevelCrit, nil
	case "err":
		return HaProxySettingsLoglevelErr, nil
	case "warning":
		return HaProxySettingsLoglevelWarning, nil
	case "notice":
		return HaProxySettingsLoglevelNotice, nil
	case "info":
		return HaProxySettingsLoglevelInfo, nil
	case "debug":
		return HaProxySettingsLoglevelDebug, nil
	}
	var t HaProxySettingsLoglevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxySettingsLoglevel) Ptr() *HaProxySettingsLoglevel {
	return &h
}

// The SSL/TLS compatibility mode which determines the cipher suites and TLS versions supported.<br>
type HaProxySettingsSslcompatibilitymode string

const (
	HaProxySettingsSslcompatibilitymodeAuto         HaProxySettingsSslcompatibilitymode = "auto"
	HaProxySettingsSslcompatibilitymodeModern       HaProxySettingsSslcompatibilitymode = "modern"
	HaProxySettingsSslcompatibilitymodeIntermediate HaProxySettingsSslcompatibilitymode = "intermediate"
	HaProxySettingsSslcompatibilitymodeOld          HaProxySettingsSslcompatibilitymode = "old"
)

func NewHaProxySettingsSslcompatibilitymodeFromString(s string) (HaProxySettingsSslcompatibilitymode, error) {
	switch s {
	case "auto":
		return HaProxySettingsSslcompatibilitymodeAuto, nil
	case "modern":
		return HaProxySettingsSslcompatibilitymodeModern, nil
	case "intermediate":
		return HaProxySettingsSslcompatibilitymodeIntermediate, nil
	case "old":
		return HaProxySettingsSslcompatibilitymodeOld, nil
	}
	var t HaProxySettingsSslcompatibilitymode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HaProxySettingsSslcompatibilitymode) Ptr() *HaProxySettingsSslcompatibilitymode {
	return &h
}

type NtpSettings struct {
	// Enables or disabled the NTP server.<br>
	Enable *bool `json:"enable,omitempty"`
	// The interfaces the NTP server will listen on.<br>
	Interface []string `json:"interface,omitempty"`
	// The maximum number of candidate peers in the NTP pool.<br>
	Ntpmaxpeers *int `json:"ntpmaxpeers,omitempty"`
	// The orphan mode stratum to set. Orphan mode allows the system clock to be used when no other clocks are available. The number here specifies the stratum reported during orphan mode and should normally be set to a number high enough to ensure that any other servers available to clients are preferred over this server<br>
	Orphan *int `json:"orphan,omitempty"`
	// The minimum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value.<br>
	Ntpminpoll *NtpSettingsNtpminpoll `json:"ntpminpoll,omitempty"`
	// The maximum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value. This value must be greater than the `ntpminpoll`.<br>
	Ntpmaxpoll *NtpSettingsNtpmaxpoll `json:"ntpmaxpoll,omitempty"`
	// The IP protocol peers are forced to use for DNS resolution.<br>
	Dnsresolv *NtpSettingsDnsresolv `json:"dnsresolv,omitempty"`
	// Enable or disable logging peer messages.<br>
	Logpeer *bool `json:"logpeer,omitempty"`
	// Enable or disable logging system messages.<br>
	Logsys *bool `json:"logsys,omitempty"`
	// Enable or disable logging reference clock statistics.<br>
	Clockstats *bool `json:"clockstats,omitempty"`
	// Enable or disable logging clock discipline statistics.<br>
	Loopstats *bool `json:"loopstats,omitempty"`
	// Enable or disable logging peer statistics.<br>
	Peerstats *bool `json:"peerstats,omitempty"`
	// Enable or disable RRD graphs for NTP statistics.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// The Leap second configuration as text.<br>
	Leapsec *string `json:"leapsec,omitempty"`
	// Enable or disable NTPv3 server authentication. (RFC 1305)<br>
	Serverauth *bool `json:"serverauth,omitempty"`
	// The NTP server authentication key.<br><br>This field is only available when the following conditions are met:<br>- `serverauth` must be equal to `true`<br>
	Serverauthkey *string `json:"serverauthkey,omitempty"`
	// The digest algorithm for the server authentication key.<br>
	Serverauthalgo *NtpSettingsServerauthalgo `json:"serverauthalgo,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NtpSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler NtpSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NtpSettings(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NtpSettings) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// The IP protocol peers are forced to use for DNS resolution.<br>
type NtpSettingsDnsresolv string

const (
	NtpSettingsDnsresolvAuto  NtpSettingsDnsresolv = "auto"
	NtpSettingsDnsresolvInet  NtpSettingsDnsresolv = "inet"
	NtpSettingsDnsresolvInet6 NtpSettingsDnsresolv = "inet6"
)

func NewNtpSettingsDnsresolvFromString(s string) (NtpSettingsDnsresolv, error) {
	switch s {
	case "auto":
		return NtpSettingsDnsresolvAuto, nil
	case "inet":
		return NtpSettingsDnsresolvInet, nil
	case "inet6":
		return NtpSettingsDnsresolvInet6, nil
	}
	var t NtpSettingsDnsresolv
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NtpSettingsDnsresolv) Ptr() *NtpSettingsDnsresolv {
	return &n
}

// The maximum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value. This value must be greater than the `ntpminpoll`.<br>
type NtpSettingsNtpmaxpoll string

const (
	NtpSettingsNtpmaxpollEmptyValue0 NtpSettingsNtpmaxpoll = "empty_value_0"
	NtpSettingsNtpmaxpollValue3      NtpSettingsNtpmaxpoll = "value_3"
	NtpSettingsNtpmaxpollValue4      NtpSettingsNtpmaxpoll = "value_4"
	NtpSettingsNtpmaxpollValue5      NtpSettingsNtpmaxpoll = "value_5"
	NtpSettingsNtpmaxpollValue6      NtpSettingsNtpmaxpoll = "value_6"
	NtpSettingsNtpmaxpollValue7      NtpSettingsNtpmaxpoll = "value_7"
	NtpSettingsNtpmaxpollValue8      NtpSettingsNtpmaxpoll = "value_8"
	NtpSettingsNtpmaxpollValue9      NtpSettingsNtpmaxpoll = "value_9"
	NtpSettingsNtpmaxpollValue10     NtpSettingsNtpmaxpoll = "value_10"
	NtpSettingsNtpmaxpollValue11     NtpSettingsNtpmaxpoll = "value_11"
	NtpSettingsNtpmaxpollValue12     NtpSettingsNtpmaxpoll = "value_12"
	NtpSettingsNtpmaxpollValue13     NtpSettingsNtpmaxpoll = "value_13"
	NtpSettingsNtpmaxpollValue14     NtpSettingsNtpmaxpoll = "value_14"
	NtpSettingsNtpmaxpollValue15     NtpSettingsNtpmaxpoll = "value_15"
	NtpSettingsNtpmaxpollValue16     NtpSettingsNtpmaxpoll = "value_16"
	NtpSettingsNtpmaxpollValue17     NtpSettingsNtpmaxpoll = "value_17"
	NtpSettingsNtpmaxpollOmit        NtpSettingsNtpmaxpoll = "omit"
)

func NewNtpSettingsNtpmaxpollFromString(s string) (NtpSettingsNtpmaxpoll, error) {
	switch s {
	case "empty_value_0":
		return NtpSettingsNtpmaxpollEmptyValue0, nil
	case "value_3":
		return NtpSettingsNtpmaxpollValue3, nil
	case "value_4":
		return NtpSettingsNtpmaxpollValue4, nil
	case "value_5":
		return NtpSettingsNtpmaxpollValue5, nil
	case "value_6":
		return NtpSettingsNtpmaxpollValue6, nil
	case "value_7":
		return NtpSettingsNtpmaxpollValue7, nil
	case "value_8":
		return NtpSettingsNtpmaxpollValue8, nil
	case "value_9":
		return NtpSettingsNtpmaxpollValue9, nil
	case "value_10":
		return NtpSettingsNtpmaxpollValue10, nil
	case "value_11":
		return NtpSettingsNtpmaxpollValue11, nil
	case "value_12":
		return NtpSettingsNtpmaxpollValue12, nil
	case "value_13":
		return NtpSettingsNtpmaxpollValue13, nil
	case "value_14":
		return NtpSettingsNtpmaxpollValue14, nil
	case "value_15":
		return NtpSettingsNtpmaxpollValue15, nil
	case "value_16":
		return NtpSettingsNtpmaxpollValue16, nil
	case "value_17":
		return NtpSettingsNtpmaxpollValue17, nil
	case "omit":
		return NtpSettingsNtpmaxpollOmit, nil
	}
	var t NtpSettingsNtpmaxpoll
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NtpSettingsNtpmaxpoll) Ptr() *NtpSettingsNtpmaxpoll {
	return &n
}

// The minimum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value.<br>
type NtpSettingsNtpminpoll string

const (
	NtpSettingsNtpminpollEmptyValue0 NtpSettingsNtpminpoll = "empty_value_0"
	NtpSettingsNtpminpollValue3      NtpSettingsNtpminpoll = "value_3"
	NtpSettingsNtpminpollValue4      NtpSettingsNtpminpoll = "value_4"
	NtpSettingsNtpminpollValue5      NtpSettingsNtpminpoll = "value_5"
	NtpSettingsNtpminpollValue6      NtpSettingsNtpminpoll = "value_6"
	NtpSettingsNtpminpollValue7      NtpSettingsNtpminpoll = "value_7"
	NtpSettingsNtpminpollValue8      NtpSettingsNtpminpoll = "value_8"
	NtpSettingsNtpminpollValue9      NtpSettingsNtpminpoll = "value_9"
	NtpSettingsNtpminpollValue10     NtpSettingsNtpminpoll = "value_10"
	NtpSettingsNtpminpollValue11     NtpSettingsNtpminpoll = "value_11"
	NtpSettingsNtpminpollValue12     NtpSettingsNtpminpoll = "value_12"
	NtpSettingsNtpminpollValue13     NtpSettingsNtpminpoll = "value_13"
	NtpSettingsNtpminpollValue14     NtpSettingsNtpminpoll = "value_14"
	NtpSettingsNtpminpollValue15     NtpSettingsNtpminpoll = "value_15"
	NtpSettingsNtpminpollValue16     NtpSettingsNtpminpoll = "value_16"
	NtpSettingsNtpminpollValue17     NtpSettingsNtpminpoll = "value_17"
	NtpSettingsNtpminpollOmit        NtpSettingsNtpminpoll = "omit"
)

func NewNtpSettingsNtpminpollFromString(s string) (NtpSettingsNtpminpoll, error) {
	switch s {
	case "empty_value_0":
		return NtpSettingsNtpminpollEmptyValue0, nil
	case "value_3":
		return NtpSettingsNtpminpollValue3, nil
	case "value_4":
		return NtpSettingsNtpminpollValue4, nil
	case "value_5":
		return NtpSettingsNtpminpollValue5, nil
	case "value_6":
		return NtpSettingsNtpminpollValue6, nil
	case "value_7":
		return NtpSettingsNtpminpollValue7, nil
	case "value_8":
		return NtpSettingsNtpminpollValue8, nil
	case "value_9":
		return NtpSettingsNtpminpollValue9, nil
	case "value_10":
		return NtpSettingsNtpminpollValue10, nil
	case "value_11":
		return NtpSettingsNtpminpollValue11, nil
	case "value_12":
		return NtpSettingsNtpminpollValue12, nil
	case "value_13":
		return NtpSettingsNtpminpollValue13, nil
	case "value_14":
		return NtpSettingsNtpminpollValue14, nil
	case "value_15":
		return NtpSettingsNtpminpollValue15, nil
	case "value_16":
		return NtpSettingsNtpminpollValue16, nil
	case "value_17":
		return NtpSettingsNtpminpollValue17, nil
	case "omit":
		return NtpSettingsNtpminpollOmit, nil
	}
	var t NtpSettingsNtpminpoll
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NtpSettingsNtpminpoll) Ptr() *NtpSettingsNtpminpoll {
	return &n
}

// The digest algorithm for the server authentication key.<br>
type NtpSettingsServerauthalgo string

const (
	NtpSettingsServerauthalgoMd5    NtpSettingsServerauthalgo = "md5"
	NtpSettingsServerauthalgoSha1   NtpSettingsServerauthalgo = "sha1"
	NtpSettingsServerauthalgoSha256 NtpSettingsServerauthalgo = "sha256"
)

func NewNtpSettingsServerauthalgoFromString(s string) (NtpSettingsServerauthalgo, error) {
	switch s {
	case "md5":
		return NtpSettingsServerauthalgoMd5, nil
	case "sha1":
		return NtpSettingsServerauthalgoSha1, nil
	case "sha256":
		return NtpSettingsServerauthalgoSha256, nil
	}
	var t NtpSettingsServerauthalgo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NtpSettingsServerauthalgo) Ptr() *NtpSettingsServerauthalgo {
	return &n
}

type NtpTimeServer struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NtpTimeServer) UnmarshalJSON(data []byte) error {
	type unmarshaler NtpTimeServer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NtpTimeServer(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NtpTimeServer) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
type NtpTimeServerType string

const (
	NtpTimeServerTypeServer NtpTimeServerType = "server"
	NtpTimeServerTypePool   NtpTimeServerType = "pool"
	NtpTimeServerTypePeer   NtpTimeServerType = "peer"
)

func NewNtpTimeServerTypeFromString(s string) (NtpTimeServerType, error) {
	switch s {
	case "server":
		return NtpTimeServerTypeServer, nil
	case "pool":
		return NtpTimeServerTypePool, nil
	case "peer":
		return NtpTimeServerTypePeer, nil
	}
	var t NtpTimeServerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NtpTimeServerType) Ptr() *NtpTimeServerType {
	return &n
}

type ServiceWatchdog struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ServiceWatchdog) UnmarshalJSON(data []byte) error {
	type unmarshaler ServiceWatchdog
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServiceWatchdog(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServiceWatchdog) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SSH struct {
	// Enable the SSH server on this system.<br>
	Enable *bool `json:"enable,omitempty"`
	// The TCP port the SSH server will listen on. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The SSH authentication mode to use. Use `enabled` to require public key authentication, use both to require both a public key AND a password, or use `null` to allow a password OR a public key.<br>
	Sshdkeyonly *SSHSshdkeyonly `json:"sshdkeyonly,omitempty"`
	// Enable support for ssh-agent forwarding.<br>
	Sshdagentforwarding *bool `json:"sshdagentforwarding,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SSH) UnmarshalJSON(data []byte) error {
	type unmarshaler SSH
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SSH(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SSH) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The SSH authentication mode to use. Use `enabled` to require public key authentication, use both to require both a public key AND a password, or use `null` to allow a password OR a public key.<br>
type SSHSshdkeyonly string

const (
	SSHSshdkeyonlyEnabled SSHSshdkeyonly = "enabled"
	SSHSshdkeyonlyBoth    SSHSshdkeyonly = "both"
)

func NewSSHSshdkeyonlyFromString(s string) (SSHSshdkeyonly, error) {
	switch s {
	case "enabled":
		return SSHSshdkeyonlyEnabled, nil
	case "both":
		return SSHSshdkeyonlyBoth, nil
	}
	var t SSHSshdkeyonly
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SSHSshdkeyonly) Ptr() *SSHSshdkeyonly {
	return &s
}

type WakeOnLanSend struct {
	// The interface the host to be woken up is connected to.<br>
	Interface *string `json:"interface,omitempty"`
	// The MAC address of the host to be awoken.<br>
	MacAddr *string `json:"mac_addr,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WakeOnLanSend) UnmarshalJSON(data []byte) error {
	type unmarshaler WakeOnLanSend
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WakeOnLanSend(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WakeOnLanSend) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type DeleteServicesAcmeAccountKeyEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesAcmeAccountKeyEndpointRequestIDFromInteger(value int) *DeleteServicesAcmeAccountKeyEndpointRequestID {
	return &DeleteServicesAcmeAccountKeyEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesAcmeAccountKeyEndpointRequestIDFromString(value string) *DeleteServicesAcmeAccountKeyEndpointRequestID {
	return &DeleteServicesAcmeAccountKeyEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesAcmeAccountKeyEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesAcmeAccountKeyEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesAcmeAccountKeyEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesAcmeAccountKeyEndpointRequestID) Accept(visitor DeleteServicesAcmeAccountKeyEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesAcmeAccountKeyEndpointResponse struct {
	Data *DeleteServicesAcmeAccountKeyEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeAccountKeyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeAccountKeyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeAccountKeyEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeAccountKeyEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeAccountKeyEndpointResponseData struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeAccountKeyEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeAccountKeyEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeAccountKeyEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeAccountKeyEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeAccountKeysEndpointResponse struct {
	Data []*DeleteServicesAcmeAccountKeysEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeAccountKeysEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeAccountKeysEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeAccountKeysEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeAccountKeysEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeAccountKeysEndpointResponseDataItem struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeAccountKeysEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeAccountKeysEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeAccountKeysEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeAccountKeysEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificateActionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesAcmeCertificateActionEndpointRequestIDFromInteger(value int) *DeleteServicesAcmeCertificateActionEndpointRequestID {
	return &DeleteServicesAcmeCertificateActionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesAcmeCertificateActionEndpointRequestIDFromString(value string) *DeleteServicesAcmeCertificateActionEndpointRequestID {
	return &DeleteServicesAcmeCertificateActionEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesAcmeCertificateActionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesAcmeCertificateActionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesAcmeCertificateActionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesAcmeCertificateActionEndpointRequestID) Accept(visitor DeleteServicesAcmeCertificateActionEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesAcmeCertificateActionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesAcmeCertificateActionEndpointRequestParentIDFromInteger(value int) *DeleteServicesAcmeCertificateActionEndpointRequestParentID {
	return &DeleteServicesAcmeCertificateActionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesAcmeCertificateActionEndpointRequestParentIDFromString(value string) *DeleteServicesAcmeCertificateActionEndpointRequestParentID {
	return &DeleteServicesAcmeCertificateActionEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesAcmeCertificateActionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesAcmeCertificateActionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesAcmeCertificateActionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesAcmeCertificateActionEndpointRequestParentID) Accept(visitor DeleteServicesAcmeCertificateActionEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesAcmeCertificateActionEndpointResponse struct {
	Data *DeleteServicesAcmeCertificateActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificateActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificateActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificateActionEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificateActionEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificateActionEndpointResponseData struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method   *AcmeCertificateActionMethod `json:"method,omitempty"`
	ParentID *int                         `json:"parent_id,omitempty"`
	ID       *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificateActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificateActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificateActionEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificateActionEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificateDomainEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesAcmeCertificateDomainEndpointRequestIDFromInteger(value int) *DeleteServicesAcmeCertificateDomainEndpointRequestID {
	return &DeleteServicesAcmeCertificateDomainEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesAcmeCertificateDomainEndpointRequestIDFromString(value string) *DeleteServicesAcmeCertificateDomainEndpointRequestID {
	return &DeleteServicesAcmeCertificateDomainEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesAcmeCertificateDomainEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesAcmeCertificateDomainEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesAcmeCertificateDomainEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesAcmeCertificateDomainEndpointRequestID) Accept(visitor DeleteServicesAcmeCertificateDomainEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesAcmeCertificateDomainEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesAcmeCertificateDomainEndpointRequestParentIDFromInteger(value int) *DeleteServicesAcmeCertificateDomainEndpointRequestParentID {
	return &DeleteServicesAcmeCertificateDomainEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesAcmeCertificateDomainEndpointRequestParentIDFromString(value string) *DeleteServicesAcmeCertificateDomainEndpointRequestParentID {
	return &DeleteServicesAcmeCertificateDomainEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesAcmeCertificateDomainEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesAcmeCertificateDomainEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesAcmeCertificateDomainEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesAcmeCertificateDomainEndpointRequestParentID) Accept(visitor DeleteServicesAcmeCertificateDomainEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesAcmeCertificateDomainEndpointResponse struct {
	Data *DeleteServicesAcmeCertificateDomainEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificateDomainEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificateDomainEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificateDomainEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificateDomainEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificateDomainEndpointResponseData struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`
	ParentID              *int  `json:"parent_id,omitempty"`
	ID                    *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificateDomainEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificateDomainEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificateDomainEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificateDomainEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesAcmeCertificateEndpointRequestIDFromInteger(value int) *DeleteServicesAcmeCertificateEndpointRequestID {
	return &DeleteServicesAcmeCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesAcmeCertificateEndpointRequestIDFromString(value string) *DeleteServicesAcmeCertificateEndpointRequestID {
	return &DeleteServicesAcmeCertificateEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesAcmeCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesAcmeCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesAcmeCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesAcmeCertificateEndpointRequestID) Accept(visitor DeleteServicesAcmeCertificateEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesAcmeCertificateEndpointResponse struct {
	Data *DeleteServicesAcmeCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificateEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificateEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificateEndpointResponseData struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificateEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificateEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificatesEndpointResponse struct {
	Data []*DeleteServicesAcmeCertificatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificatesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificatesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesAcmeCertificatesEndpointResponseDataItem struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesAcmeCertificatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesAcmeCertificatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesAcmeCertificatesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesAcmeCertificatesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindAccessListEndpointRequestIDFromInteger(value int) *DeleteServicesBindAccessListEndpointRequestID {
	return &DeleteServicesBindAccessListEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindAccessListEndpointRequestIDFromString(value string) *DeleteServicesBindAccessListEndpointRequestID {
	return &DeleteServicesBindAccessListEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesBindAccessListEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindAccessListEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindAccessListEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindAccessListEndpointRequestID) Accept(visitor DeleteServicesBindAccessListEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindAccessListEndpointResponse struct {
	Data *DeleteServicesBindAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListEndpointResponseData struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	ID      *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListEntriesEndpointResponse struct {
	Data []*DeleteServicesBindAccessListEntriesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListEntriesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListEntriesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListEntriesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListEntriesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListEntriesEndpointResponseDataItem struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListEntriesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListEntriesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListEntriesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListEntriesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListEntryEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindAccessListEntryEndpointRequestIDFromInteger(value int) *DeleteServicesBindAccessListEntryEndpointRequestID {
	return &DeleteServicesBindAccessListEntryEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindAccessListEntryEndpointRequestIDFromString(value string) *DeleteServicesBindAccessListEntryEndpointRequestID {
	return &DeleteServicesBindAccessListEntryEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesBindAccessListEntryEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindAccessListEntryEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindAccessListEntryEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindAccessListEntryEndpointRequestID) Accept(visitor DeleteServicesBindAccessListEntryEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindAccessListEntryEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindAccessListEntryEndpointRequestParentIDFromInteger(value int) *DeleteServicesBindAccessListEntryEndpointRequestParentID {
	return &DeleteServicesBindAccessListEntryEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindAccessListEntryEndpointRequestParentIDFromString(value string) *DeleteServicesBindAccessListEntryEndpointRequestParentID {
	return &DeleteServicesBindAccessListEntryEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesBindAccessListEntryEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindAccessListEntryEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindAccessListEntryEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindAccessListEntryEndpointRequestParentID) Accept(visitor DeleteServicesBindAccessListEntryEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindAccessListEntryEndpointResponse struct {
	Data *DeleteServicesBindAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListEntryEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListEntryEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListEntryEndpointResponseData struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListEntryEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListEntryEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListsEndpointResponse struct {
	Data []*DeleteServicesBindAccessListsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindAccessListsEndpointResponseDataItem struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	ID      *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindAccessListsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindAccessListsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindAccessListsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindAccessListsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindSyncRemoteHostEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindSyncRemoteHostEndpointRequestIDFromInteger(value int) *DeleteServicesBindSyncRemoteHostEndpointRequestID {
	return &DeleteServicesBindSyncRemoteHostEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindSyncRemoteHostEndpointRequestIDFromString(value string) *DeleteServicesBindSyncRemoteHostEndpointRequestID {
	return &DeleteServicesBindSyncRemoteHostEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesBindSyncRemoteHostEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindSyncRemoteHostEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindSyncRemoteHostEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindSyncRemoteHostEndpointRequestID) Accept(visitor DeleteServicesBindSyncRemoteHostEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindSyncRemoteHostEndpointResponse struct {
	Data *DeleteServicesBindSyncRemoteHostEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindSyncRemoteHostEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindSyncRemoteHostEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindSyncRemoteHostEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindSyncRemoteHostEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindSyncRemoteHostEndpointResponseData struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindSyncRemoteHostEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindSyncRemoteHostEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindSyncRemoteHostEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindSyncRemoteHostEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindSyncRemoteHostsEndpointResponse struct {
	Data []*DeleteServicesBindSyncRemoteHostsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindSyncRemoteHostsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindSyncRemoteHostsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindSyncRemoteHostsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindSyncRemoteHostsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindSyncRemoteHostsEndpointResponseDataItem struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindSyncRemoteHostsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindSyncRemoteHostsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindSyncRemoteHostsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindSyncRemoteHostsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindViewEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindViewEndpointRequestIDFromInteger(value int) *DeleteServicesBindViewEndpointRequestID {
	return &DeleteServicesBindViewEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindViewEndpointRequestIDFromString(value string) *DeleteServicesBindViewEndpointRequestID {
	return &DeleteServicesBindViewEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesBindViewEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindViewEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindViewEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindViewEndpointRequestID) Accept(visitor DeleteServicesBindViewEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindViewEndpointResponse struct {
	Data *DeleteServicesBindViewEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindViewEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindViewEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindViewEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindViewEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindViewEndpointResponseData struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	ID                *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindViewEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindViewEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindViewEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindViewEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindViewsEndpointResponse struct {
	Data []*DeleteServicesBindViewsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindViewsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindViewsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindViewsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindViewsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindViewsEndpointResponseDataItem struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	ID                *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindViewsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindViewsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindViewsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindViewsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindZoneEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindZoneEndpointRequestIDFromInteger(value int) *DeleteServicesBindZoneEndpointRequestID {
	return &DeleteServicesBindZoneEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindZoneEndpointRequestIDFromString(value string) *DeleteServicesBindZoneEndpointRequestID {
	return &DeleteServicesBindZoneEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesBindZoneEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindZoneEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindZoneEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindZoneEndpointRequestID) Accept(visitor DeleteServicesBindZoneEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindZoneEndpointResponse struct {
	Data *DeleteServicesBindZoneEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindZoneEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindZoneEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindZoneEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindZoneEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindZoneEndpointResponseData struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	ID      *int                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindZoneEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindZoneEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindZoneEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindZoneEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindZoneRecordEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindZoneRecordEndpointRequestIDFromInteger(value int) *DeleteServicesBindZoneRecordEndpointRequestID {
	return &DeleteServicesBindZoneRecordEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindZoneRecordEndpointRequestIDFromString(value string) *DeleteServicesBindZoneRecordEndpointRequestID {
	return &DeleteServicesBindZoneRecordEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesBindZoneRecordEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindZoneRecordEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindZoneRecordEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindZoneRecordEndpointRequestID) Accept(visitor DeleteServicesBindZoneRecordEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindZoneRecordEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesBindZoneRecordEndpointRequestParentIDFromInteger(value int) *DeleteServicesBindZoneRecordEndpointRequestParentID {
	return &DeleteServicesBindZoneRecordEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesBindZoneRecordEndpointRequestParentIDFromString(value string) *DeleteServicesBindZoneRecordEndpointRequestParentID {
	return &DeleteServicesBindZoneRecordEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesBindZoneRecordEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesBindZoneRecordEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesBindZoneRecordEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesBindZoneRecordEndpointRequestParentID) Accept(visitor DeleteServicesBindZoneRecordEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesBindZoneRecordEndpointResponse struct {
	Data *DeleteServicesBindZoneRecordEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindZoneRecordEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindZoneRecordEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindZoneRecordEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindZoneRecordEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindZoneRecordEndpointResponseData struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindZoneRecordEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindZoneRecordEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindZoneRecordEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindZoneRecordEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindZonesEndpointResponse struct {
	Data []*DeleteServicesBindZonesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindZonesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindZonesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindZonesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindZonesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesBindZonesEndpointResponseDataItem struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	ID      *int                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesBindZonesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesBindZonesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesBindZonesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesBindZonesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesCronJobEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesCronJobEndpointRequestIDFromInteger(value int) *DeleteServicesCronJobEndpointRequestID {
	return &DeleteServicesCronJobEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesCronJobEndpointRequestIDFromString(value string) *DeleteServicesCronJobEndpointRequestID {
	return &DeleteServicesCronJobEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesCronJobEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesCronJobEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesCronJobEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesCronJobEndpointRequestID) Accept(visitor DeleteServicesCronJobEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesCronJobEndpointResponse struct {
	Data *DeleteServicesCronJobEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesCronJobEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesCronJobEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesCronJobEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesCronJobEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesCronJobEndpointResponseData struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesCronJobEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesCronJobEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesCronJobEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesCronJobEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesCronJobsEndpointResponse struct {
	Data []*DeleteServicesCronJobsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesCronJobsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesCronJobsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesCronJobsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesCronJobsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesCronJobsEndpointResponseDataItem struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesCronJobsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesCronJobsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesCronJobsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesCronJobsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerAddressPoolEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDhcpServerAddressPoolEndpointRequestIDFromInteger(value int) *DeleteServicesDhcpServerAddressPoolEndpointRequestID {
	return &DeleteServicesDhcpServerAddressPoolEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDhcpServerAddressPoolEndpointRequestIDFromString(value string) *DeleteServicesDhcpServerAddressPoolEndpointRequestID {
	return &DeleteServicesDhcpServerAddressPoolEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDhcpServerAddressPoolEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDhcpServerAddressPoolEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointRequestID) Accept(visitor DeleteServicesDhcpServerAddressPoolEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDhcpServerAddressPoolEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDhcpServerAddressPoolEndpointRequestParentIDFromInteger(value int) *DeleteServicesDhcpServerAddressPoolEndpointRequestParentID {
	return &DeleteServicesDhcpServerAddressPoolEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDhcpServerAddressPoolEndpointRequestParentIDFromString(value string) *DeleteServicesDhcpServerAddressPoolEndpointRequestParentID {
	return &DeleteServicesDhcpServerAddressPoolEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDhcpServerAddressPoolEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDhcpServerAddressPoolEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointRequestParentID) Accept(visitor DeleteServicesDhcpServerAddressPoolEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDhcpServerAddressPoolEndpointResponse struct {
	Data *DeleteServicesDhcpServerAddressPoolEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerAddressPoolEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerAddressPoolEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerAddressPoolEndpointResponseData struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	ParentID    *string                           `json:"parent_id,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerAddressPoolEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerAddressPoolEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerAddressPoolEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerAddressPoolsEndpointResponse struct {
	Data []*DeleteServicesDhcpServerAddressPoolsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerAddressPoolsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerAddressPoolsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerAddressPoolsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerAddressPoolsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerAddressPoolsEndpointResponseDataItem struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	ParentID    *string                           `json:"parent_id,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerAddressPoolsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerAddressPoolsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerAddressPoolsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerAddressPoolsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerCustomOptionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDhcpServerCustomOptionEndpointRequestIDFromInteger(value int) *DeleteServicesDhcpServerCustomOptionEndpointRequestID {
	return &DeleteServicesDhcpServerCustomOptionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDhcpServerCustomOptionEndpointRequestIDFromString(value string) *DeleteServicesDhcpServerCustomOptionEndpointRequestID {
	return &DeleteServicesDhcpServerCustomOptionEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDhcpServerCustomOptionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDhcpServerCustomOptionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointRequestID) Accept(visitor DeleteServicesDhcpServerCustomOptionEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDhcpServerCustomOptionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDhcpServerCustomOptionEndpointRequestParentIDFromInteger(value int) *DeleteServicesDhcpServerCustomOptionEndpointRequestParentID {
	return &DeleteServicesDhcpServerCustomOptionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDhcpServerCustomOptionEndpointRequestParentIDFromString(value string) *DeleteServicesDhcpServerCustomOptionEndpointRequestParentID {
	return &DeleteServicesDhcpServerCustomOptionEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDhcpServerCustomOptionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDhcpServerCustomOptionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointRequestParentID) Accept(visitor DeleteServicesDhcpServerCustomOptionEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDhcpServerCustomOptionEndpointResponse struct {
	Data *DeleteServicesDhcpServerCustomOptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerCustomOptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerCustomOptionEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerCustomOptionEndpointResponseData struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value    *string `json:"value,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerCustomOptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerCustomOptionEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerCustomOptionEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerCustomOptionsEndpointResponse struct {
	Data []*DeleteServicesDhcpServerCustomOptionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerCustomOptionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerCustomOptionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerCustomOptionsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerCustomOptionsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerCustomOptionsEndpointResponseDataItem struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value    *string `json:"value,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerCustomOptionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerCustomOptionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerCustomOptionsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerCustomOptionsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDhcpServerEndpointRequestIDFromInteger(value int) *DeleteServicesDhcpServerEndpointRequestID {
	return &DeleteServicesDhcpServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDhcpServerEndpointRequestIDFromString(value string) *DeleteServicesDhcpServerEndpointRequestID {
	return &DeleteServicesDhcpServerEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDhcpServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDhcpServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDhcpServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDhcpServerEndpointRequestID) Accept(visitor DeleteServicesDhcpServerEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDhcpServerEndpointResponse struct {
	Data *DeleteServicesDhcpServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerEndpointResponseData struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
	ID        *string                    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerStaticMappingEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDhcpServerStaticMappingEndpointRequestIDFromInteger(value int) *DeleteServicesDhcpServerStaticMappingEndpointRequestID {
	return &DeleteServicesDhcpServerStaticMappingEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDhcpServerStaticMappingEndpointRequestIDFromString(value string) *DeleteServicesDhcpServerStaticMappingEndpointRequestID {
	return &DeleteServicesDhcpServerStaticMappingEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDhcpServerStaticMappingEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDhcpServerStaticMappingEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointRequestID) Accept(visitor DeleteServicesDhcpServerStaticMappingEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDhcpServerStaticMappingEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDhcpServerStaticMappingEndpointRequestParentIDFromInteger(value int) *DeleteServicesDhcpServerStaticMappingEndpointRequestParentID {
	return &DeleteServicesDhcpServerStaticMappingEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDhcpServerStaticMappingEndpointRequestParentIDFromString(value string) *DeleteServicesDhcpServerStaticMappingEndpointRequestParentID {
	return &DeleteServicesDhcpServerStaticMappingEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDhcpServerStaticMappingEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDhcpServerStaticMappingEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointRequestParentID) Accept(visitor DeleteServicesDhcpServerStaticMappingEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDhcpServerStaticMappingEndpointResponse struct {
	Data *DeleteServicesDhcpServerStaticMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerStaticMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerStaticMappingEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerStaticMappingEndpointResponseData struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerStaticMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerStaticMappingEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerStaticMappingEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerStaticMappingsEndpointResponse struct {
	Data []*DeleteServicesDhcpServerStaticMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerStaticMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerStaticMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerStaticMappingsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerStaticMappingsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDhcpServerStaticMappingsEndpointResponseDataItem struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDhcpServerStaticMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDhcpServerStaticMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDhcpServerStaticMappingsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDhcpServerStaticMappingsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSForwarderHostOverrideAliasEndpointRequestIDFromInteger(value int) *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID {
	return &DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSForwarderHostOverrideAliasEndpointRequestIDFromString(value string) *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID {
	return &DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestID) Accept(visitor DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDFromInteger(value int) *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID {
	return &DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDFromString(value string) *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID {
	return &DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentID) Accept(visitor DeleteServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSForwarderHostOverrideAliasEndpointResponse struct {
	Data *DeleteServicesDNSForwarderHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverrideAliasEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverrideAliasEndpointResponseData struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverrideAliasEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponse struct {
	Data []*DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverrideEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSForwarderHostOverrideEndpointRequestIDFromInteger(value int) *DeleteServicesDNSForwarderHostOverrideEndpointRequestID {
	return &DeleteServicesDNSForwarderHostOverrideEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSForwarderHostOverrideEndpointRequestIDFromString(value string) *DeleteServicesDNSForwarderHostOverrideEndpointRequestID {
	return &DeleteServicesDNSForwarderHostOverrideEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSForwarderHostOverrideEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSForwarderHostOverrideEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSForwarderHostOverrideEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSForwarderHostOverrideEndpointRequestID) Accept(visitor DeleteServicesDNSForwarderHostOverrideEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSForwarderHostOverrideEndpointResponse struct {
	Data *DeleteServicesDNSForwarderHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverrideEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverrideEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverrideEndpointResponseData struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverrideEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverrideEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverridesEndpointResponse struct {
	Data []*DeleteServicesDNSForwarderHostOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverridesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverridesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSForwarderHostOverridesEndpointResponseDataItem struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSForwarderHostOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSForwarderHostOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSForwarderHostOverridesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSForwarderHostOverridesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSResolverAccessListEndpointRequestIDFromInteger(value int) *DeleteServicesDNSResolverAccessListEndpointRequestID {
	return &DeleteServicesDNSResolverAccessListEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSResolverAccessListEndpointRequestIDFromString(value string) *DeleteServicesDNSResolverAccessListEndpointRequestID {
	return &DeleteServicesDNSResolverAccessListEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSResolverAccessListEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSResolverAccessListEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSResolverAccessListEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSResolverAccessListEndpointRequestID) Accept(visitor DeleteServicesDNSResolverAccessListEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSResolverAccessListEndpointResponse struct {
	Data *DeleteServicesDNSResolverAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListEndpointResponseData struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	ID       *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListNetworkEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSResolverAccessListNetworkEndpointRequestIDFromInteger(value int) *DeleteServicesDNSResolverAccessListNetworkEndpointRequestID {
	return &DeleteServicesDNSResolverAccessListNetworkEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSResolverAccessListNetworkEndpointRequestIDFromString(value string) *DeleteServicesDNSResolverAccessListNetworkEndpointRequestID {
	return &DeleteServicesDNSResolverAccessListNetworkEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSResolverAccessListNetworkEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSResolverAccessListNetworkEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointRequestID) Accept(visitor DeleteServicesDNSResolverAccessListNetworkEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSResolverAccessListNetworkEndpointRequestParentIDFromInteger(value int) *DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID {
	return &DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSResolverAccessListNetworkEndpointRequestParentIDFromString(value string) *DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID {
	return &DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentID) Accept(visitor DeleteServicesDNSResolverAccessListNetworkEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSResolverAccessListNetworkEndpointResponse struct {
	Data *DeleteServicesDNSResolverAccessListNetworkEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListNetworkEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListNetworkEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListNetworkEndpointResponseData struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListNetworkEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListNetworkEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListNetworkEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListNetworksEndpointResponse struct {
	Data []*DeleteServicesDNSResolverAccessListNetworksEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListNetworksEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListNetworksEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListNetworksEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListNetworksEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListNetworksEndpointResponseDataItem struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListNetworksEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListNetworksEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListNetworksEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListNetworksEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListsEndpointResponse struct {
	Data []*DeleteServicesDNSResolverAccessListsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverAccessListsEndpointResponseDataItem struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	ID       *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverAccessListsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverAccessListsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverAccessListsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverAccessListsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverDomainOverrideEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSResolverDomainOverrideEndpointRequestIDFromInteger(value int) *DeleteServicesDNSResolverDomainOverrideEndpointRequestID {
	return &DeleteServicesDNSResolverDomainOverrideEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSResolverDomainOverrideEndpointRequestIDFromString(value string) *DeleteServicesDNSResolverDomainOverrideEndpointRequestID {
	return &DeleteServicesDNSResolverDomainOverrideEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSResolverDomainOverrideEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSResolverDomainOverrideEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSResolverDomainOverrideEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSResolverDomainOverrideEndpointRequestID) Accept(visitor DeleteServicesDNSResolverDomainOverrideEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSResolverDomainOverrideEndpointResponse struct {
	Data *DeleteServicesDNSResolverDomainOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverDomainOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverDomainOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverDomainOverrideEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverDomainOverrideEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverDomainOverrideEndpointResponseData struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverDomainOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverDomainOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverDomainOverrideEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverDomainOverrideEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverDomainOverridesEndpointResponse struct {
	Data []*DeleteServicesDNSResolverDomainOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverDomainOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverDomainOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverDomainOverridesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverDomainOverridesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverDomainOverridesEndpointResponseDataItem struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverDomainOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverDomainOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverDomainOverridesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverDomainOverridesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSResolverHostOverrideAliasEndpointRequestIDFromInteger(value int) *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID {
	return &DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSResolverHostOverrideAliasEndpointRequestIDFromString(value string) *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID {
	return &DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSResolverHostOverrideAliasEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestID) Accept(visitor DeleteServicesDNSResolverHostOverrideAliasEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentIDFromInteger(value int) *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID {
	return &DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentIDFromString(value string) *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID {
	return &DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentID) Accept(visitor DeleteServicesDNSResolverHostOverrideAliasEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSResolverHostOverrideAliasEndpointResponse struct {
	Data *DeleteServicesDNSResolverHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverrideAliasEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverrideAliasEndpointResponseData struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverrideAliasEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverrideAliasEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverrideAliasesEndpointResponse struct {
	Data []*DeleteServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverrideAliasesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverrideAliasesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverrideAliasesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverrideAliasesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverrideEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesDNSResolverHostOverrideEndpointRequestIDFromInteger(value int) *DeleteServicesDNSResolverHostOverrideEndpointRequestID {
	return &DeleteServicesDNSResolverHostOverrideEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesDNSResolverHostOverrideEndpointRequestIDFromString(value string) *DeleteServicesDNSResolverHostOverrideEndpointRequestID {
	return &DeleteServicesDNSResolverHostOverrideEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesDNSResolverHostOverrideEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesDNSResolverHostOverrideEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesDNSResolverHostOverrideEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesDNSResolverHostOverrideEndpointRequestID) Accept(visitor DeleteServicesDNSResolverHostOverrideEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesDNSResolverHostOverrideEndpointResponse struct {
	Data *DeleteServicesDNSResolverHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverrideEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverrideEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverrideEndpointResponseData struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverrideEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverrideEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverridesEndpointResponse struct {
	Data []*DeleteServicesDNSResolverHostOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverridesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverridesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesDNSResolverHostOverridesEndpointResponseDataItem struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesDNSResolverHostOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesDNSResolverHostOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesDNSResolverHostOverridesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesDNSResolverHostOverridesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusClientEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesFreeRadiusClientEndpointRequestIDFromInteger(value int) *DeleteServicesFreeRadiusClientEndpointRequestID {
	return &DeleteServicesFreeRadiusClientEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesFreeRadiusClientEndpointRequestIDFromString(value string) *DeleteServicesFreeRadiusClientEndpointRequestID {
	return &DeleteServicesFreeRadiusClientEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesFreeRadiusClientEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesFreeRadiusClientEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesFreeRadiusClientEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesFreeRadiusClientEndpointRequestID) Accept(visitor DeleteServicesFreeRadiusClientEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesFreeRadiusClientEndpointResponse struct {
	Data *DeleteServicesFreeRadiusClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusClientEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusClientEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusClientEndpointResponseData struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusClientEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusClientEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusClientsEndpointResponse struct {
	Data []*DeleteServicesFreeRadiusClientsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusClientsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusClientsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusClientsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusClientsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusClientsEndpointResponseDataItem struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusClientsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusClientsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusClientsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusClientsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusInterfaceEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesFreeRadiusInterfaceEndpointRequestIDFromInteger(value int) *DeleteServicesFreeRadiusInterfaceEndpointRequestID {
	return &DeleteServicesFreeRadiusInterfaceEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesFreeRadiusInterfaceEndpointRequestIDFromString(value string) *DeleteServicesFreeRadiusInterfaceEndpointRequestID {
	return &DeleteServicesFreeRadiusInterfaceEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesFreeRadiusInterfaceEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesFreeRadiusInterfaceEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesFreeRadiusInterfaceEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesFreeRadiusInterfaceEndpointRequestID) Accept(visitor DeleteServicesFreeRadiusInterfaceEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesFreeRadiusInterfaceEndpointResponse struct {
	Data *DeleteServicesFreeRadiusInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusInterfaceEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusInterfaceEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusInterfaceEndpointResponseData struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusInterfaceEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusInterfaceEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusInterfacesEndpointResponse struct {
	Data []*DeleteServicesFreeRadiusInterfacesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusInterfacesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusInterfacesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusInterfacesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusInterfacesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusInterfacesEndpointResponseDataItem struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusInterfacesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusInterfacesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusInterfacesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusInterfacesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusUserEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesFreeRadiusUserEndpointRequestIDFromInteger(value int) *DeleteServicesFreeRadiusUserEndpointRequestID {
	return &DeleteServicesFreeRadiusUserEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesFreeRadiusUserEndpointRequestIDFromString(value string) *DeleteServicesFreeRadiusUserEndpointRequestID {
	return &DeleteServicesFreeRadiusUserEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesFreeRadiusUserEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesFreeRadiusUserEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesFreeRadiusUserEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesFreeRadiusUserEndpointRequestID) Accept(visitor DeleteServicesFreeRadiusUserEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesFreeRadiusUserEndpointResponse struct {
	Data *DeleteServicesFreeRadiusUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusUserEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusUserEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusUserEndpointResponseData struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusUserEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusUserEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusUsersEndpointResponse struct {
	Data []*DeleteServicesFreeRadiusUsersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusUsersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusUsersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusUsersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusUsersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesFreeRadiusUsersEndpointResponseDataItem struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesFreeRadiusUsersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesFreeRadiusUsersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesFreeRadiusUsersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesFreeRadiusUsersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendAcLsEndpointResponse struct {
	Data []*DeleteServicesHaProxyBackendAcLsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendAcLsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendAcLsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendAcLsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendAcLsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendAcLsEndpointResponseDataItem struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendAcLsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendAcLsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendAcLsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendAcLsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendACLEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendACLEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyBackendACLEndpointRequestID {
	return &DeleteServicesHaProxyBackendACLEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendACLEndpointRequestIDFromString(value string) *DeleteServicesHaProxyBackendACLEndpointRequestID {
	return &DeleteServicesHaProxyBackendACLEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendACLEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendACLEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendACLEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendACLEndpointRequestID) Accept(visitor DeleteServicesHaProxyBackendACLEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendACLEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendACLEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyBackendACLEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendACLEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendACLEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyBackendACLEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendACLEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendACLEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendACLEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendACLEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendACLEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyBackendACLEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendACLEndpointResponse struct {
	Data *DeleteServicesHaProxyBackendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendACLEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendACLEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendACLEndpointResponseData struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendACLEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendACLEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendActionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendActionEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyBackendActionEndpointRequestID {
	return &DeleteServicesHaProxyBackendActionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendActionEndpointRequestIDFromString(value string) *DeleteServicesHaProxyBackendActionEndpointRequestID {
	return &DeleteServicesHaProxyBackendActionEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendActionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendActionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendActionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendActionEndpointRequestID) Accept(visitor DeleteServicesHaProxyBackendActionEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendActionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendActionEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyBackendActionEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendActionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendActionEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyBackendActionEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendActionEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendActionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendActionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendActionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendActionEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyBackendActionEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendActionEndpointResponse struct {
	Data *DeleteServicesHaProxyBackendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendActionEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendActionEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendActionEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendActionEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendActionsEndpointResponse struct {
	Data []*DeleteServicesHaProxyBackendActionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendActionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendActionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendActionsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendActionsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendActionsEndpointResponseDataItem struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendActionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendActionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendActionsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendActionsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyBackendEndpointRequestID {
	return &DeleteServicesHaProxyBackendEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendEndpointRequestIDFromString(value string) *DeleteServicesHaProxyBackendEndpointRequestID {
	return &DeleteServicesHaProxyBackendEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendEndpointRequestID) Accept(visitor DeleteServicesHaProxyBackendEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendEndpointResponse struct {
	Data *DeleteServicesHaProxyBackendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendEndpointResponseData struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendErrorFileEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendErrorFileEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyBackendErrorFileEndpointRequestID {
	return &DeleteServicesHaProxyBackendErrorFileEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendErrorFileEndpointRequestIDFromString(value string) *DeleteServicesHaProxyBackendErrorFileEndpointRequestID {
	return &DeleteServicesHaProxyBackendErrorFileEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendErrorFileEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendErrorFileEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointRequestID) Accept(visitor DeleteServicesHaProxyBackendErrorFileEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendErrorFileEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendErrorFileEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendErrorFileEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyBackendErrorFileEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendErrorFileEndpointResponse struct {
	Data *DeleteServicesHaProxyBackendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendErrorFileEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendErrorFileEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendErrorFileEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendErrorFilesEndpointResponse struct {
	Data []*DeleteServicesHaProxyBackendErrorFilesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendErrorFilesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendErrorFilesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendErrorFilesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendErrorFilesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendErrorFilesEndpointResponseDataItem struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendErrorFilesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendErrorFilesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendErrorFilesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendErrorFilesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendServerEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyBackendServerEndpointRequestID {
	return &DeleteServicesHaProxyBackendServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendServerEndpointRequestIDFromString(value string) *DeleteServicesHaProxyBackendServerEndpointRequestID {
	return &DeleteServicesHaProxyBackendServerEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendServerEndpointRequestID) Accept(visitor DeleteServicesHaProxyBackendServerEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendServerEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyBackendServerEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyBackendServerEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendServerEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyBackendServerEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyBackendServerEndpointRequestParentID {
	return &DeleteServicesHaProxyBackendServerEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyBackendServerEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyBackendServerEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyBackendServerEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyBackendServerEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyBackendServerEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyBackendServerEndpointResponse struct {
	Data *DeleteServicesHaProxyBackendServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendServerEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendServerEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendServerEndpointResponseData struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendServerEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendServerEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendServersEndpointResponse struct {
	Data []*DeleteServicesHaProxyBackendServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendServersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendServersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendServersEndpointResponseDataItem struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendServersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendServersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendsEndpointResponse struct {
	Data []*DeleteServicesHaProxyBackendsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyBackendsEndpointResponseDataItem struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyBackendsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyBackendsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyBackendsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyBackendsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFileEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFileEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyFileEndpointRequestID {
	return &DeleteServicesHaProxyFileEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFileEndpointRequestIDFromString(value string) *DeleteServicesHaProxyFileEndpointRequestID {
	return &DeleteServicesHaProxyFileEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFileEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFileEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFileEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFileEndpointRequestID) Accept(visitor DeleteServicesHaProxyFileEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFileEndpointResponse struct {
	Data *DeleteServicesHaProxyFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFileEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFileEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFileEndpointResponseData struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFileEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFileEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFilesResponse struct {
	Data []*DeleteServicesHaProxyFilesResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFilesResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFilesResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFilesResponseDataItem struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFilesResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFilesResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFilesResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFilesResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendAcLsEndpointResponse struct {
	Data []*DeleteServicesHaProxyFrontendAcLsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendAcLsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendAcLsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendAcLsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendAcLsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendAcLsEndpointResponseDataItem struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendAcLsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendAcLsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendAcLsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendAcLsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendACLEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendACLEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyFrontendACLEndpointRequestID {
	return &DeleteServicesHaProxyFrontendACLEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendACLEndpointRequestIDFromString(value string) *DeleteServicesHaProxyFrontendACLEndpointRequestID {
	return &DeleteServicesHaProxyFrontendACLEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendACLEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendACLEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendACLEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendACLEndpointRequestID) Accept(visitor DeleteServicesHaProxyFrontendACLEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendACLEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendACLEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyFrontendACLEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendACLEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendACLEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyFrontendACLEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendACLEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendACLEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendACLEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendACLEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendACLEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyFrontendACLEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendACLEndpointResponse struct {
	Data *DeleteServicesHaProxyFrontendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendACLEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendACLEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendACLEndpointResponseData struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendACLEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendACLEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendActionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendActionEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyFrontendActionEndpointRequestID {
	return &DeleteServicesHaProxyFrontendActionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendActionEndpointRequestIDFromString(value string) *DeleteServicesHaProxyFrontendActionEndpointRequestID {
	return &DeleteServicesHaProxyFrontendActionEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendActionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendActionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendActionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendActionEndpointRequestID) Accept(visitor DeleteServicesHaProxyFrontendActionEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendActionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendActionEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyFrontendActionEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendActionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendActionEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyFrontendActionEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendActionEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendActionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendActionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendActionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendActionEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyFrontendActionEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendActionEndpointResponse struct {
	Data *DeleteServicesHaProxyFrontendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendActionEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendActionEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendActionEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendActionEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendActionsEndpointResponse struct {
	Data []*DeleteServicesHaProxyFrontendActionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendActionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendActionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendActionsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendActionsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendActionsEndpointResponseDataItem struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendActionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendActionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendActionsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendActionsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendAddressEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendAddressEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyFrontendAddressEndpointRequestID {
	return &DeleteServicesHaProxyFrontendAddressEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendAddressEndpointRequestIDFromString(value string) *DeleteServicesHaProxyFrontendAddressEndpointRequestID {
	return &DeleteServicesHaProxyFrontendAddressEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendAddressEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendAddressEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointRequestID) Accept(visitor DeleteServicesHaProxyFrontendAddressEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendAddressEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendAddressEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyFrontendAddressEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendAddressEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendAddressEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyFrontendAddressEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendAddressEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendAddressEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendAddressEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyFrontendAddressEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendAddressEndpointResponse struct {
	Data *DeleteServicesHaProxyFrontendAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendAddressEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendAddressEndpointResponseData struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendAddressEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendAddressEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendAddressesEndpointResponse struct {
	Data []*DeleteServicesHaProxyFrontendAddressesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendAddressesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendAddressesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendAddressesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendAddressesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendAddressesEndpointResponseDataItem struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendAddressesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendAddressesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendAddressesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendAddressesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendCertificateEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyFrontendCertificateEndpointRequestID {
	return &DeleteServicesHaProxyFrontendCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendCertificateEndpointRequestIDFromString(value string) *DeleteServicesHaProxyFrontendCertificateEndpointRequestID {
	return &DeleteServicesHaProxyFrontendCertificateEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointRequestID) Accept(visitor DeleteServicesHaProxyFrontendCertificateEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendCertificateEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendCertificateEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendCertificateEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyFrontendCertificateEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendCertificateEndpointResponse struct {
	Data *DeleteServicesHaProxyFrontendCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendCertificateEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendCertificateEndpointResponseData struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendCertificateEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendCertificateEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendCertificatesEndpointResponse struct {
	Data []*DeleteServicesHaProxyFrontendCertificatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendCertificatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendCertificatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendCertificatesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendCertificatesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendCertificatesEndpointResponseDataItem struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendCertificatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendCertificatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendCertificatesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendCertificatesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyFrontendEndpointRequestID {
	return &DeleteServicesHaProxyFrontendEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendEndpointRequestIDFromString(value string) *DeleteServicesHaProxyFrontendEndpointRequestID {
	return &DeleteServicesHaProxyFrontendEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendEndpointRequestID) Accept(visitor DeleteServicesHaProxyFrontendEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendEndpointResponse struct {
	Data *DeleteServicesHaProxyFrontendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendEndpointResponseData struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	ID             *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendErrorFileEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendErrorFileEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxyFrontendErrorFileEndpointRequestID {
	return &DeleteServicesHaProxyFrontendErrorFileEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendErrorFileEndpointRequestIDFromString(value string) *DeleteServicesHaProxyFrontendErrorFileEndpointRequestID {
	return &DeleteServicesHaProxyFrontendErrorFileEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendErrorFileEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendErrorFileEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointRequestID) Accept(visitor DeleteServicesHaProxyFrontendErrorFileEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxyFrontendErrorFileEndpointRequestParentIDFromInteger(value int) *DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxyFrontendErrorFileEndpointRequestParentIDFromString(value string) *DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID {
	return &DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentID) Accept(visitor DeleteServicesHaProxyFrontendErrorFileEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxyFrontendErrorFileEndpointResponse struct {
	Data *DeleteServicesHaProxyFrontendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendErrorFileEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendErrorFileEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendErrorFileEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendErrorFilesEndpointResponse struct {
	Data []*DeleteServicesHaProxyFrontendErrorFilesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendErrorFilesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendErrorFilesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendErrorFilesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendErrorFilesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendErrorFilesEndpointResponseDataItem struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendErrorFilesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendErrorFilesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendErrorFilesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendErrorFilesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendsEndpointResponse struct {
	Data []*DeleteServicesHaProxyFrontendsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxyFrontendsEndpointResponseDataItem struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	ID             *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxyFrontendsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxyFrontendsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxyFrontendsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxyFrontendsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsDNSResolverEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxySettingsDNSResolverEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxySettingsDNSResolverEndpointRequestID {
	return &DeleteServicesHaProxySettingsDNSResolverEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxySettingsDNSResolverEndpointRequestIDFromString(value string) *DeleteServicesHaProxySettingsDNSResolverEndpointRequestID {
	return &DeleteServicesHaProxySettingsDNSResolverEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxySettingsDNSResolverEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxySettingsDNSResolverEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxySettingsDNSResolverEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxySettingsDNSResolverEndpointRequestID) Accept(visitor DeleteServicesHaProxySettingsDNSResolverEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxySettingsDNSResolverEndpointResponse struct {
	Data *DeleteServicesHaProxySettingsDNSResolverEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsDNSResolverEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsDNSResolverEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsDNSResolverEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsDNSResolverEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsDNSResolverEndpointResponseData struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port     *string `json:"port,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsDNSResolverEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsDNSResolverEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsDNSResolverEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsDNSResolverEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsDNSResolversEndpointResponse struct {
	Data []*DeleteServicesHaProxySettingsDNSResolversEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsDNSResolversEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsDNSResolversEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsDNSResolversEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsDNSResolversEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsDNSResolversEndpointResponseDataItem struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port     *string `json:"port,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsDNSResolversEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsDNSResolversEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsDNSResolversEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsDNSResolversEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsEmailMailerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesHaProxySettingsEmailMailerEndpointRequestIDFromInteger(value int) *DeleteServicesHaProxySettingsEmailMailerEndpointRequestID {
	return &DeleteServicesHaProxySettingsEmailMailerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesHaProxySettingsEmailMailerEndpointRequestIDFromString(value string) *DeleteServicesHaProxySettingsEmailMailerEndpointRequestID {
	return &DeleteServicesHaProxySettingsEmailMailerEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesHaProxySettingsEmailMailerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesHaProxySettingsEmailMailerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesHaProxySettingsEmailMailerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesHaProxySettingsEmailMailerEndpointRequestID) Accept(visitor DeleteServicesHaProxySettingsEmailMailerEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesHaProxySettingsEmailMailerEndpointResponse struct {
	Data *DeleteServicesHaProxySettingsEmailMailerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsEmailMailerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsEmailMailerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsEmailMailerEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsEmailMailerEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsEmailMailerEndpointResponseData struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsEmailMailerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsEmailMailerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsEmailMailerEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsEmailMailerEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsEmailMailersEndpointResponse struct {
	Data []*DeleteServicesHaProxySettingsEmailMailersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsEmailMailersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsEmailMailersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsEmailMailersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsEmailMailersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesHaProxySettingsEmailMailersEndpointResponseDataItem struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesHaProxySettingsEmailMailersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesHaProxySettingsEmailMailersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesHaProxySettingsEmailMailersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesHaProxySettingsEmailMailersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesNtpTimeServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesNtpTimeServerEndpointRequestIDFromInteger(value int) *DeleteServicesNtpTimeServerEndpointRequestID {
	return &DeleteServicesNtpTimeServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesNtpTimeServerEndpointRequestIDFromString(value string) *DeleteServicesNtpTimeServerEndpointRequestID {
	return &DeleteServicesNtpTimeServerEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesNtpTimeServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesNtpTimeServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesNtpTimeServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesNtpTimeServerEndpointRequestID) Accept(visitor DeleteServicesNtpTimeServerEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesNtpTimeServerEndpointResponse struct {
	Data *DeleteServicesNtpTimeServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesNtpTimeServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesNtpTimeServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesNtpTimeServerEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesNtpTimeServerEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesNtpTimeServerEndpointResponseData struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesNtpTimeServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesNtpTimeServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesNtpTimeServerEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesNtpTimeServerEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesNtpTimeServersEndpointResponse struct {
	Data []*DeleteServicesNtpTimeServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesNtpTimeServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesNtpTimeServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesNtpTimeServersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesNtpTimeServersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesNtpTimeServersEndpointResponseDataItem struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesNtpTimeServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesNtpTimeServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesNtpTimeServersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesNtpTimeServersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesServiceWatchdogEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteServicesServiceWatchdogEndpointRequestIDFromInteger(value int) *DeleteServicesServiceWatchdogEndpointRequestID {
	return &DeleteServicesServiceWatchdogEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteServicesServiceWatchdogEndpointRequestIDFromString(value string) *DeleteServicesServiceWatchdogEndpointRequestID {
	return &DeleteServicesServiceWatchdogEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteServicesServiceWatchdogEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteServicesServiceWatchdogEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteServicesServiceWatchdogEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteServicesServiceWatchdogEndpointRequestID) Accept(visitor DeleteServicesServiceWatchdogEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteServicesServiceWatchdogEndpointResponse struct {
	Data *DeleteServicesServiceWatchdogEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesServiceWatchdogEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesServiceWatchdogEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesServiceWatchdogEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesServiceWatchdogEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesServiceWatchdogEndpointResponseData struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	ID      *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesServiceWatchdogEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesServiceWatchdogEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesServiceWatchdogEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesServiceWatchdogEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesServiceWatchdogsEndpointResponse struct {
	Data []*DeleteServicesServiceWatchdogsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesServiceWatchdogsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesServiceWatchdogsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesServiceWatchdogsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesServiceWatchdogsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteServicesServiceWatchdogsEndpointResponseDataItem struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	ID      *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteServicesServiceWatchdogsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteServicesServiceWatchdogsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteServicesServiceWatchdogsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteServicesServiceWatchdogsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetServicesAcmeAccountKeyEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesAcmeAccountKeyEndpointRequestIDFromInteger(value int) *GetServicesAcmeAccountKeyEndpointRequestID {
	return &GetServicesAcmeAccountKeyEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesAcmeAccountKeyEndpointRequestIDFromString(value string) *GetServicesAcmeAccountKeyEndpointRequestID {
	return &GetServicesAcmeAccountKeyEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesAcmeAccountKeyEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesAcmeAccountKeyEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesAcmeAccountKeyEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesAcmeAccountKeyEndpointRequestID) Accept(visitor GetServicesAcmeAccountKeyEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesAcmeAccountKeyEndpointResponse struct {
	Data *GetServicesAcmeAccountKeyEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeAccountKeyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeAccountKeyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeAccountKeyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeAccountKeyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeAccountKeyEndpointResponseData struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeAccountKeyEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeAccountKeyEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeAccountKeyEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeAccountKeyEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags string

const (
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortRegular      GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortNumeric      GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortString       GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortLocaleString GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortNatural      GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortFlagCase     GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsFromString(s string) (GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags) Ptr() *GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortFlags {
	return &g
}

type GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder string

const (
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrderSortAsc  GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrderSortDesc GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrderFromString(s string) (GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder) Ptr() *GetServicesAcmeAccountKeyRegistrationsEndpointRequestSortOrder {
	return &g
}

type GetServicesAcmeAccountKeyRegistrationsEndpointResponse struct {
	Data []*GetServicesAcmeAccountKeyRegistrationsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeAccountKeyRegistrationsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeAccountKeyRegistrationsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeAccountKeyRegistrationsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeAccountKeyRegistrationsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeAccountKeyRegistrationsEndpointResponseDataItem struct {
	// The name of the ACME account key to register.<br>
	Name *string `json:"name,omitempty"`
	// The registration status of the ACME account key. This will show 'pending' if the registration process is still running, 'registered' if the registration was successful, 'failed' if the registration failed, and 'unknown' if the registration status is not known. Note: This status can only be determined for registrations initiated through the REST API.<br>
	Status *string `json:"status,omitempty"`
	ID     *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeAccountKeyRegistrationsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeAccountKeyRegistrationsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeAccountKeyRegistrationsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeAccountKeyRegistrationsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeAccountKeysEndpointRequestSortFlags string

const (
	GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortRegular      GetServicesAcmeAccountKeysEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortNumeric      GetServicesAcmeAccountKeysEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortString       GetServicesAcmeAccountKeysEndpointRequestSortFlags = "SORT_STRING"
	GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortLocaleString GetServicesAcmeAccountKeysEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortNatural      GetServicesAcmeAccountKeysEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortFlagCase     GetServicesAcmeAccountKeysEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesAcmeAccountKeysEndpointRequestSortFlagsFromString(s string) (GetServicesAcmeAccountKeysEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesAcmeAccountKeysEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesAcmeAccountKeysEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeAccountKeysEndpointRequestSortFlags) Ptr() *GetServicesAcmeAccountKeysEndpointRequestSortFlags {
	return &g
}

type GetServicesAcmeAccountKeysEndpointRequestSortOrder string

const (
	GetServicesAcmeAccountKeysEndpointRequestSortOrderSortAsc  GetServicesAcmeAccountKeysEndpointRequestSortOrder = "SORT_ASC"
	GetServicesAcmeAccountKeysEndpointRequestSortOrderSortDesc GetServicesAcmeAccountKeysEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesAcmeAccountKeysEndpointRequestSortOrderFromString(s string) (GetServicesAcmeAccountKeysEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesAcmeAccountKeysEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesAcmeAccountKeysEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesAcmeAccountKeysEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeAccountKeysEndpointRequestSortOrder) Ptr() *GetServicesAcmeAccountKeysEndpointRequestSortOrder {
	return &g
}

type GetServicesAcmeAccountKeysEndpointResponse struct {
	Data []*GetServicesAcmeAccountKeysEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeAccountKeysEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeAccountKeysEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeAccountKeysEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeAccountKeysEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeAccountKeysEndpointResponseDataItem struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeAccountKeysEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeAccountKeysEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeAccountKeysEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeAccountKeysEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateActionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesAcmeCertificateActionEndpointRequestIDFromInteger(value int) *GetServicesAcmeCertificateActionEndpointRequestID {
	return &GetServicesAcmeCertificateActionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesAcmeCertificateActionEndpointRequestIDFromString(value string) *GetServicesAcmeCertificateActionEndpointRequestID {
	return &GetServicesAcmeCertificateActionEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesAcmeCertificateActionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesAcmeCertificateActionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesAcmeCertificateActionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesAcmeCertificateActionEndpointRequestID) Accept(visitor GetServicesAcmeCertificateActionEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesAcmeCertificateActionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesAcmeCertificateActionEndpointRequestParentIDFromInteger(value int) *GetServicesAcmeCertificateActionEndpointRequestParentID {
	return &GetServicesAcmeCertificateActionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesAcmeCertificateActionEndpointRequestParentIDFromString(value string) *GetServicesAcmeCertificateActionEndpointRequestParentID {
	return &GetServicesAcmeCertificateActionEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesAcmeCertificateActionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesAcmeCertificateActionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesAcmeCertificateActionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesAcmeCertificateActionEndpointRequestParentID) Accept(visitor GetServicesAcmeCertificateActionEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesAcmeCertificateActionEndpointResponse struct {
	Data *GetServicesAcmeCertificateActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateActionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateActionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateActionEndpointResponseData struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method   *AcmeCertificateActionMethod `json:"method,omitempty"`
	ParentID *int                         `json:"parent_id,omitempty"`
	ID       *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateActionEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateActionEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateDomainEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesAcmeCertificateDomainEndpointRequestIDFromInteger(value int) *GetServicesAcmeCertificateDomainEndpointRequestID {
	return &GetServicesAcmeCertificateDomainEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesAcmeCertificateDomainEndpointRequestIDFromString(value string) *GetServicesAcmeCertificateDomainEndpointRequestID {
	return &GetServicesAcmeCertificateDomainEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesAcmeCertificateDomainEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesAcmeCertificateDomainEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesAcmeCertificateDomainEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesAcmeCertificateDomainEndpointRequestID) Accept(visitor GetServicesAcmeCertificateDomainEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesAcmeCertificateDomainEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesAcmeCertificateDomainEndpointRequestParentIDFromInteger(value int) *GetServicesAcmeCertificateDomainEndpointRequestParentID {
	return &GetServicesAcmeCertificateDomainEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesAcmeCertificateDomainEndpointRequestParentIDFromString(value string) *GetServicesAcmeCertificateDomainEndpointRequestParentID {
	return &GetServicesAcmeCertificateDomainEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesAcmeCertificateDomainEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesAcmeCertificateDomainEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesAcmeCertificateDomainEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesAcmeCertificateDomainEndpointRequestParentID) Accept(visitor GetServicesAcmeCertificateDomainEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesAcmeCertificateDomainEndpointResponse struct {
	Data *GetServicesAcmeCertificateDomainEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateDomainEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateDomainEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateDomainEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateDomainEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateDomainEndpointResponseData struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`
	ParentID              *int  `json:"parent_id,omitempty"`
	ID                    *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateDomainEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateDomainEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateDomainEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateDomainEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesAcmeCertificateEndpointRequestIDFromInteger(value int) *GetServicesAcmeCertificateEndpointRequestID {
	return &GetServicesAcmeCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesAcmeCertificateEndpointRequestIDFromString(value string) *GetServicesAcmeCertificateEndpointRequestID {
	return &GetServicesAcmeCertificateEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesAcmeCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesAcmeCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesAcmeCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesAcmeCertificateEndpointRequestID) Accept(visitor GetServicesAcmeCertificateEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesAcmeCertificateEndpointResponse struct {
	Data *GetServicesAcmeCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateEndpointResponseData struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags string

const (
	GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortRegular      GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortNumeric      GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortString       GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortLocaleString GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortNatural      GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortFlagCase     GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsFromString(s string) (GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags) Ptr() *GetServicesAcmeCertificateIssuancesEndpointRequestSortFlags {
	return &g
}

type GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder string

const (
	GetServicesAcmeCertificateIssuancesEndpointRequestSortOrderSortAsc  GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesAcmeCertificateIssuancesEndpointRequestSortOrderSortDesc GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesAcmeCertificateIssuancesEndpointRequestSortOrderFromString(s string) (GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesAcmeCertificateIssuancesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder) Ptr() *GetServicesAcmeCertificateIssuancesEndpointRequestSortOrder {
	return &g
}

type GetServicesAcmeCertificateIssuancesEndpointResponse struct {
	Data []*GetServicesAcmeCertificateIssuancesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateIssuancesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateIssuancesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateIssuancesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateIssuancesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateIssuancesEndpointResponseDataItem struct {
	// The name of the ACME certificate to be issued.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate issue process. This will show 'pending' if the issue process is still running or 'completed' if the issue process has finished. This status only indicates whether the issue process has completed, not whether it was successful. You will needto refer to the result log for that information.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate issue status last changed.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh issue command.<br>
	ResultLog *string `json:"result_log,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateIssuancesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateIssuancesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateIssuancesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateIssuancesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags string

const (
	GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortRegular      GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortNumeric      GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortString       GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortLocaleString GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortNatural      GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortFlagCase     GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsFromString(s string) (GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags) Ptr() *GetServicesAcmeCertificateRenewalsEndpointRequestSortFlags {
	return &g
}

type GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder string

const (
	GetServicesAcmeCertificateRenewalsEndpointRequestSortOrderSortAsc  GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesAcmeCertificateRenewalsEndpointRequestSortOrderSortDesc GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesAcmeCertificateRenewalsEndpointRequestSortOrderFromString(s string) (GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesAcmeCertificateRenewalsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder) Ptr() *GetServicesAcmeCertificateRenewalsEndpointRequestSortOrder {
	return &g
}

type GetServicesAcmeCertificateRenewalsEndpointResponse struct {
	Data []*GetServicesAcmeCertificateRenewalsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateRenewalsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateRenewalsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateRenewalsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateRenewalsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificateRenewalsEndpointResponseDataItem struct {
	// The name of the ACME certificate to be renewed.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate renew process. This will show 'pending' if the renew process is still running or 'completed' if the renew process has finished. This status only indicates whether the renew process has completed, not whether it was successful. You will needto refer to the result log for that information. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate renew status last changed. Note: This timestamp is only updated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh renew command. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	ResultLog *string `json:"result_log,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificateRenewalsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificateRenewalsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificateRenewalsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificateRenewalsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificatesEndpointRequestSortFlags string

const (
	GetServicesAcmeCertificatesEndpointRequestSortFlagsSortRegular      GetServicesAcmeCertificatesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesAcmeCertificatesEndpointRequestSortFlagsSortNumeric      GetServicesAcmeCertificatesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesAcmeCertificatesEndpointRequestSortFlagsSortString       GetServicesAcmeCertificatesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesAcmeCertificatesEndpointRequestSortFlagsSortLocaleString GetServicesAcmeCertificatesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesAcmeCertificatesEndpointRequestSortFlagsSortNatural      GetServicesAcmeCertificatesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesAcmeCertificatesEndpointRequestSortFlagsSortFlagCase     GetServicesAcmeCertificatesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesAcmeCertificatesEndpointRequestSortFlagsFromString(s string) (GetServicesAcmeCertificatesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesAcmeCertificatesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesAcmeCertificatesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesAcmeCertificatesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesAcmeCertificatesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesAcmeCertificatesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesAcmeCertificatesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesAcmeCertificatesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeCertificatesEndpointRequestSortFlags) Ptr() *GetServicesAcmeCertificatesEndpointRequestSortFlags {
	return &g
}

type GetServicesAcmeCertificatesEndpointRequestSortOrder string

const (
	GetServicesAcmeCertificatesEndpointRequestSortOrderSortAsc  GetServicesAcmeCertificatesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesAcmeCertificatesEndpointRequestSortOrderSortDesc GetServicesAcmeCertificatesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesAcmeCertificatesEndpointRequestSortOrderFromString(s string) (GetServicesAcmeCertificatesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesAcmeCertificatesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesAcmeCertificatesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesAcmeCertificatesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesAcmeCertificatesEndpointRequestSortOrder) Ptr() *GetServicesAcmeCertificatesEndpointRequestSortOrder {
	return &g
}

type GetServicesAcmeCertificatesEndpointResponse struct {
	Data []*GetServicesAcmeCertificatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificatesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificatesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeCertificatesEndpointResponseDataItem struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeCertificatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeCertificatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeCertificatesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeCertificatesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesAcmeSettingsEndpointResponse struct {
	Data *AcmeSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesAcmeSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesAcmeSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesAcmeSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesAcmeSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindAccessListEndpointRequestIDFromInteger(value int) *GetServicesBindAccessListEndpointRequestID {
	return &GetServicesBindAccessListEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesBindAccessListEndpointRequestIDFromString(value string) *GetServicesBindAccessListEndpointRequestID {
	return &GetServicesBindAccessListEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesBindAccessListEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindAccessListEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindAccessListEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindAccessListEndpointRequestID) Accept(visitor GetServicesBindAccessListEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindAccessListEndpointResponse struct {
	Data *GetServicesBindAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListEndpointResponseData struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	ID      *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListEntriesEndpointRequestSortFlags string

const (
	GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortRegular      GetServicesBindAccessListEntriesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortNumeric      GetServicesBindAccessListEntriesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortString       GetServicesBindAccessListEntriesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortLocaleString GetServicesBindAccessListEntriesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortNatural      GetServicesBindAccessListEntriesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortFlagCase     GetServicesBindAccessListEntriesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesBindAccessListEntriesEndpointRequestSortFlagsFromString(s string) (GetServicesBindAccessListEntriesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesBindAccessListEntriesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesBindAccessListEntriesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindAccessListEntriesEndpointRequestSortFlags) Ptr() *GetServicesBindAccessListEntriesEndpointRequestSortFlags {
	return &g
}

type GetServicesBindAccessListEntriesEndpointRequestSortOrder string

const (
	GetServicesBindAccessListEntriesEndpointRequestSortOrderSortAsc  GetServicesBindAccessListEntriesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesBindAccessListEntriesEndpointRequestSortOrderSortDesc GetServicesBindAccessListEntriesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesBindAccessListEntriesEndpointRequestSortOrderFromString(s string) (GetServicesBindAccessListEntriesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesBindAccessListEntriesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesBindAccessListEntriesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesBindAccessListEntriesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindAccessListEntriesEndpointRequestSortOrder) Ptr() *GetServicesBindAccessListEntriesEndpointRequestSortOrder {
	return &g
}

type GetServicesBindAccessListEntriesEndpointResponse struct {
	Data []*GetServicesBindAccessListEntriesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListEntriesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListEntriesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListEntriesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListEntriesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListEntriesEndpointResponseDataItem struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListEntriesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListEntriesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListEntriesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListEntriesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListEntryEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindAccessListEntryEndpointRequestIDFromInteger(value int) *GetServicesBindAccessListEntryEndpointRequestID {
	return &GetServicesBindAccessListEntryEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesBindAccessListEntryEndpointRequestIDFromString(value string) *GetServicesBindAccessListEntryEndpointRequestID {
	return &GetServicesBindAccessListEntryEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesBindAccessListEntryEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindAccessListEntryEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindAccessListEntryEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindAccessListEntryEndpointRequestID) Accept(visitor GetServicesBindAccessListEntryEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindAccessListEntryEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindAccessListEntryEndpointRequestParentIDFromInteger(value int) *GetServicesBindAccessListEntryEndpointRequestParentID {
	return &GetServicesBindAccessListEntryEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesBindAccessListEntryEndpointRequestParentIDFromString(value string) *GetServicesBindAccessListEntryEndpointRequestParentID {
	return &GetServicesBindAccessListEntryEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesBindAccessListEntryEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindAccessListEntryEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindAccessListEntryEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindAccessListEntryEndpointRequestParentID) Accept(visitor GetServicesBindAccessListEntryEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindAccessListEntryEndpointResponse struct {
	Data *GetServicesBindAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListEntryEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListEntryEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListEntryEndpointResponseData struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListEntryEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListEntryEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListsEndpointRequestSortFlags string

const (
	GetServicesBindAccessListsEndpointRequestSortFlagsSortRegular      GetServicesBindAccessListsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesBindAccessListsEndpointRequestSortFlagsSortNumeric      GetServicesBindAccessListsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesBindAccessListsEndpointRequestSortFlagsSortString       GetServicesBindAccessListsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesBindAccessListsEndpointRequestSortFlagsSortLocaleString GetServicesBindAccessListsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesBindAccessListsEndpointRequestSortFlagsSortNatural      GetServicesBindAccessListsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesBindAccessListsEndpointRequestSortFlagsSortFlagCase     GetServicesBindAccessListsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesBindAccessListsEndpointRequestSortFlagsFromString(s string) (GetServicesBindAccessListsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesBindAccessListsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesBindAccessListsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesBindAccessListsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesBindAccessListsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesBindAccessListsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesBindAccessListsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesBindAccessListsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindAccessListsEndpointRequestSortFlags) Ptr() *GetServicesBindAccessListsEndpointRequestSortFlags {
	return &g
}

type GetServicesBindAccessListsEndpointRequestSortOrder string

const (
	GetServicesBindAccessListsEndpointRequestSortOrderSortAsc  GetServicesBindAccessListsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesBindAccessListsEndpointRequestSortOrderSortDesc GetServicesBindAccessListsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesBindAccessListsEndpointRequestSortOrderFromString(s string) (GetServicesBindAccessListsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesBindAccessListsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesBindAccessListsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesBindAccessListsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindAccessListsEndpointRequestSortOrder) Ptr() *GetServicesBindAccessListsEndpointRequestSortOrder {
	return &g
}

type GetServicesBindAccessListsEndpointResponse struct {
	Data []*GetServicesBindAccessListsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindAccessListsEndpointResponseDataItem struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	ID      *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindAccessListsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindAccessListsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindAccessListsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindAccessListsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindSettingsEndpointResponse struct {
	Data *BindSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindSyncRemoteHostEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindSyncRemoteHostEndpointRequestIDFromInteger(value int) *GetServicesBindSyncRemoteHostEndpointRequestID {
	return &GetServicesBindSyncRemoteHostEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesBindSyncRemoteHostEndpointRequestIDFromString(value string) *GetServicesBindSyncRemoteHostEndpointRequestID {
	return &GetServicesBindSyncRemoteHostEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesBindSyncRemoteHostEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindSyncRemoteHostEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindSyncRemoteHostEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindSyncRemoteHostEndpointRequestID) Accept(visitor GetServicesBindSyncRemoteHostEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindSyncRemoteHostEndpointResponse struct {
	Data *GetServicesBindSyncRemoteHostEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindSyncRemoteHostEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindSyncRemoteHostEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindSyncRemoteHostEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindSyncRemoteHostEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindSyncRemoteHostEndpointResponseData struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindSyncRemoteHostEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindSyncRemoteHostEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindSyncRemoteHostEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindSyncRemoteHostEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindSyncRemoteHostsEndpointRequestSortFlags string

const (
	GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortRegular      GetServicesBindSyncRemoteHostsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortNumeric      GetServicesBindSyncRemoteHostsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortString       GetServicesBindSyncRemoteHostsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortLocaleString GetServicesBindSyncRemoteHostsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortNatural      GetServicesBindSyncRemoteHostsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortFlagCase     GetServicesBindSyncRemoteHostsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesBindSyncRemoteHostsEndpointRequestSortFlagsFromString(s string) (GetServicesBindSyncRemoteHostsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesBindSyncRemoteHostsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindSyncRemoteHostsEndpointRequestSortFlags) Ptr() *GetServicesBindSyncRemoteHostsEndpointRequestSortFlags {
	return &g
}

type GetServicesBindSyncRemoteHostsEndpointRequestSortOrder string

const (
	GetServicesBindSyncRemoteHostsEndpointRequestSortOrderSortAsc  GetServicesBindSyncRemoteHostsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesBindSyncRemoteHostsEndpointRequestSortOrderSortDesc GetServicesBindSyncRemoteHostsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesBindSyncRemoteHostsEndpointRequestSortOrderFromString(s string) (GetServicesBindSyncRemoteHostsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesBindSyncRemoteHostsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesBindSyncRemoteHostsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindSyncRemoteHostsEndpointRequestSortOrder) Ptr() *GetServicesBindSyncRemoteHostsEndpointRequestSortOrder {
	return &g
}

type GetServicesBindSyncRemoteHostsEndpointResponse struct {
	Data []*GetServicesBindSyncRemoteHostsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindSyncRemoteHostsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindSyncRemoteHostsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindSyncRemoteHostsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindSyncRemoteHostsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindSyncRemoteHostsEndpointResponseDataItem struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindSyncRemoteHostsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindSyncRemoteHostsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindSyncRemoteHostsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindSyncRemoteHostsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindSyncSettingsEndpointResponse struct {
	Data *BindSyncSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindSyncSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindSyncSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindSyncSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindSyncSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindViewEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindViewEndpointRequestIDFromInteger(value int) *GetServicesBindViewEndpointRequestID {
	return &GetServicesBindViewEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesBindViewEndpointRequestIDFromString(value string) *GetServicesBindViewEndpointRequestID {
	return &GetServicesBindViewEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesBindViewEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindViewEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindViewEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindViewEndpointRequestID) Accept(visitor GetServicesBindViewEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindViewEndpointResponse struct {
	Data *GetServicesBindViewEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindViewEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindViewEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindViewEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindViewEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindViewEndpointResponseData struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	ID                *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindViewEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindViewEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindViewEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindViewEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindViewsEndpointRequestSortFlags string

const (
	GetServicesBindViewsEndpointRequestSortFlagsSortRegular      GetServicesBindViewsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesBindViewsEndpointRequestSortFlagsSortNumeric      GetServicesBindViewsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesBindViewsEndpointRequestSortFlagsSortString       GetServicesBindViewsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesBindViewsEndpointRequestSortFlagsSortLocaleString GetServicesBindViewsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesBindViewsEndpointRequestSortFlagsSortNatural      GetServicesBindViewsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesBindViewsEndpointRequestSortFlagsSortFlagCase     GetServicesBindViewsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesBindViewsEndpointRequestSortFlagsFromString(s string) (GetServicesBindViewsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesBindViewsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesBindViewsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesBindViewsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesBindViewsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesBindViewsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesBindViewsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesBindViewsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindViewsEndpointRequestSortFlags) Ptr() *GetServicesBindViewsEndpointRequestSortFlags {
	return &g
}

type GetServicesBindViewsEndpointRequestSortOrder string

const (
	GetServicesBindViewsEndpointRequestSortOrderSortAsc  GetServicesBindViewsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesBindViewsEndpointRequestSortOrderSortDesc GetServicesBindViewsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesBindViewsEndpointRequestSortOrderFromString(s string) (GetServicesBindViewsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesBindViewsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesBindViewsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesBindViewsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindViewsEndpointRequestSortOrder) Ptr() *GetServicesBindViewsEndpointRequestSortOrder {
	return &g
}

type GetServicesBindViewsEndpointResponse struct {
	Data []*GetServicesBindViewsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindViewsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindViewsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindViewsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindViewsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindViewsEndpointResponseDataItem struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	ID                *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindViewsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindViewsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindViewsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindViewsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindZoneEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindZoneEndpointRequestIDFromInteger(value int) *GetServicesBindZoneEndpointRequestID {
	return &GetServicesBindZoneEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesBindZoneEndpointRequestIDFromString(value string) *GetServicesBindZoneEndpointRequestID {
	return &GetServicesBindZoneEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesBindZoneEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindZoneEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindZoneEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindZoneEndpointRequestID) Accept(visitor GetServicesBindZoneEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindZoneEndpointResponse struct {
	Data *GetServicesBindZoneEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindZoneEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindZoneEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindZoneEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindZoneEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindZoneEndpointResponseData struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	ID      *int                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindZoneEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindZoneEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindZoneEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindZoneEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindZoneRecordEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindZoneRecordEndpointRequestIDFromInteger(value int) *GetServicesBindZoneRecordEndpointRequestID {
	return &GetServicesBindZoneRecordEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesBindZoneRecordEndpointRequestIDFromString(value string) *GetServicesBindZoneRecordEndpointRequestID {
	return &GetServicesBindZoneRecordEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesBindZoneRecordEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindZoneRecordEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindZoneRecordEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindZoneRecordEndpointRequestID) Accept(visitor GetServicesBindZoneRecordEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindZoneRecordEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesBindZoneRecordEndpointRequestParentIDFromInteger(value int) *GetServicesBindZoneRecordEndpointRequestParentID {
	return &GetServicesBindZoneRecordEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesBindZoneRecordEndpointRequestParentIDFromString(value string) *GetServicesBindZoneRecordEndpointRequestParentID {
	return &GetServicesBindZoneRecordEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesBindZoneRecordEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesBindZoneRecordEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesBindZoneRecordEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesBindZoneRecordEndpointRequestParentID) Accept(visitor GetServicesBindZoneRecordEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesBindZoneRecordEndpointResponse struct {
	Data *GetServicesBindZoneRecordEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindZoneRecordEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindZoneRecordEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindZoneRecordEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindZoneRecordEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindZoneRecordEndpointResponseData struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindZoneRecordEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindZoneRecordEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindZoneRecordEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindZoneRecordEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindZonesEndpointRequestSortFlags string

const (
	GetServicesBindZonesEndpointRequestSortFlagsSortRegular      GetServicesBindZonesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesBindZonesEndpointRequestSortFlagsSortNumeric      GetServicesBindZonesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesBindZonesEndpointRequestSortFlagsSortString       GetServicesBindZonesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesBindZonesEndpointRequestSortFlagsSortLocaleString GetServicesBindZonesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesBindZonesEndpointRequestSortFlagsSortNatural      GetServicesBindZonesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesBindZonesEndpointRequestSortFlagsSortFlagCase     GetServicesBindZonesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesBindZonesEndpointRequestSortFlagsFromString(s string) (GetServicesBindZonesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesBindZonesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesBindZonesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesBindZonesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesBindZonesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesBindZonesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesBindZonesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesBindZonesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindZonesEndpointRequestSortFlags) Ptr() *GetServicesBindZonesEndpointRequestSortFlags {
	return &g
}

type GetServicesBindZonesEndpointRequestSortOrder string

const (
	GetServicesBindZonesEndpointRequestSortOrderSortAsc  GetServicesBindZonesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesBindZonesEndpointRequestSortOrderSortDesc GetServicesBindZonesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesBindZonesEndpointRequestSortOrderFromString(s string) (GetServicesBindZonesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesBindZonesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesBindZonesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesBindZonesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesBindZonesEndpointRequestSortOrder) Ptr() *GetServicesBindZonesEndpointRequestSortOrder {
	return &g
}

type GetServicesBindZonesEndpointResponse struct {
	Data []*GetServicesBindZonesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindZonesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindZonesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindZonesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindZonesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesBindZonesEndpointResponseDataItem struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	ID      *int                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesBindZonesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesBindZonesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesBindZonesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesBindZonesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesCronJobEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesCronJobEndpointRequestIDFromInteger(value int) *GetServicesCronJobEndpointRequestID {
	return &GetServicesCronJobEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesCronJobEndpointRequestIDFromString(value string) *GetServicesCronJobEndpointRequestID {
	return &GetServicesCronJobEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesCronJobEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesCronJobEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesCronJobEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesCronJobEndpointRequestID) Accept(visitor GetServicesCronJobEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesCronJobEndpointResponse struct {
	Data *GetServicesCronJobEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesCronJobEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesCronJobEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesCronJobEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesCronJobEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesCronJobEndpointResponseData struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesCronJobEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesCronJobEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesCronJobEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesCronJobEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesCronJobsEndpointRequestSortFlags string

const (
	GetServicesCronJobsEndpointRequestSortFlagsSortRegular      GetServicesCronJobsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesCronJobsEndpointRequestSortFlagsSortNumeric      GetServicesCronJobsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesCronJobsEndpointRequestSortFlagsSortString       GetServicesCronJobsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesCronJobsEndpointRequestSortFlagsSortLocaleString GetServicesCronJobsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesCronJobsEndpointRequestSortFlagsSortNatural      GetServicesCronJobsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesCronJobsEndpointRequestSortFlagsSortFlagCase     GetServicesCronJobsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesCronJobsEndpointRequestSortFlagsFromString(s string) (GetServicesCronJobsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesCronJobsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesCronJobsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesCronJobsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesCronJobsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesCronJobsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesCronJobsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesCronJobsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesCronJobsEndpointRequestSortFlags) Ptr() *GetServicesCronJobsEndpointRequestSortFlags {
	return &g
}

type GetServicesCronJobsEndpointRequestSortOrder string

const (
	GetServicesCronJobsEndpointRequestSortOrderSortAsc  GetServicesCronJobsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesCronJobsEndpointRequestSortOrderSortDesc GetServicesCronJobsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesCronJobsEndpointRequestSortOrderFromString(s string) (GetServicesCronJobsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesCronJobsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesCronJobsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesCronJobsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesCronJobsEndpointRequestSortOrder) Ptr() *GetServicesCronJobsEndpointRequestSortOrder {
	return &g
}

type GetServicesCronJobsEndpointResponse struct {
	Data []*GetServicesCronJobsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesCronJobsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesCronJobsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesCronJobsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesCronJobsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesCronJobsEndpointResponseDataItem struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesCronJobsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesCronJobsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesCronJobsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesCronJobsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpRelayEndpointResponse struct {
	Data *DhcpRelay `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpRelayEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpRelayEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpRelayEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpRelayEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerAddressPoolEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDhcpServerAddressPoolEndpointRequestIDFromInteger(value int) *GetServicesDhcpServerAddressPoolEndpointRequestID {
	return &GetServicesDhcpServerAddressPoolEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDhcpServerAddressPoolEndpointRequestIDFromString(value string) *GetServicesDhcpServerAddressPoolEndpointRequestID {
	return &GetServicesDhcpServerAddressPoolEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDhcpServerAddressPoolEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDhcpServerAddressPoolEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDhcpServerAddressPoolEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDhcpServerAddressPoolEndpointRequestID) Accept(visitor GetServicesDhcpServerAddressPoolEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDhcpServerAddressPoolEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDhcpServerAddressPoolEndpointRequestParentIDFromInteger(value int) *GetServicesDhcpServerAddressPoolEndpointRequestParentID {
	return &GetServicesDhcpServerAddressPoolEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesDhcpServerAddressPoolEndpointRequestParentIDFromString(value string) *GetServicesDhcpServerAddressPoolEndpointRequestParentID {
	return &GetServicesDhcpServerAddressPoolEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesDhcpServerAddressPoolEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDhcpServerAddressPoolEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDhcpServerAddressPoolEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDhcpServerAddressPoolEndpointRequestParentID) Accept(visitor GetServicesDhcpServerAddressPoolEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDhcpServerAddressPoolEndpointResponse struct {
	Data *GetServicesDhcpServerAddressPoolEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerAddressPoolEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerAddressPoolEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerAddressPoolEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerAddressPoolEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerAddressPoolEndpointResponseData struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	ParentID    *string                           `json:"parent_id,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerAddressPoolEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerAddressPoolEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerAddressPoolEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerAddressPoolEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags string

const (
	GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortRegular      GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortNumeric      GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortString       GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortLocaleString GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortNatural      GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortFlagCase     GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsFromString(s string) (GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags) Ptr() *GetServicesDhcpServerAddressPoolsEndpointRequestSortFlags {
	return &g
}

type GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder string

const (
	GetServicesDhcpServerAddressPoolsEndpointRequestSortOrderSortAsc  GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDhcpServerAddressPoolsEndpointRequestSortOrderSortDesc GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDhcpServerAddressPoolsEndpointRequestSortOrderFromString(s string) (GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDhcpServerAddressPoolsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder) Ptr() *GetServicesDhcpServerAddressPoolsEndpointRequestSortOrder {
	return &g
}

type GetServicesDhcpServerAddressPoolsEndpointResponse struct {
	Data []*GetServicesDhcpServerAddressPoolsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerAddressPoolsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerAddressPoolsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerAddressPoolsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerAddressPoolsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerAddressPoolsEndpointResponseDataItem struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	ParentID    *string                           `json:"parent_id,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerAddressPoolsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerAddressPoolsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerAddressPoolsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerAddressPoolsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerApplyEndpointResponse struct {
	Data *DhcpServerApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerCustomOptionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDhcpServerCustomOptionEndpointRequestIDFromInteger(value int) *GetServicesDhcpServerCustomOptionEndpointRequestID {
	return &GetServicesDhcpServerCustomOptionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDhcpServerCustomOptionEndpointRequestIDFromString(value string) *GetServicesDhcpServerCustomOptionEndpointRequestID {
	return &GetServicesDhcpServerCustomOptionEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDhcpServerCustomOptionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDhcpServerCustomOptionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDhcpServerCustomOptionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDhcpServerCustomOptionEndpointRequestID) Accept(visitor GetServicesDhcpServerCustomOptionEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDhcpServerCustomOptionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDhcpServerCustomOptionEndpointRequestParentIDFromInteger(value int) *GetServicesDhcpServerCustomOptionEndpointRequestParentID {
	return &GetServicesDhcpServerCustomOptionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesDhcpServerCustomOptionEndpointRequestParentIDFromString(value string) *GetServicesDhcpServerCustomOptionEndpointRequestParentID {
	return &GetServicesDhcpServerCustomOptionEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesDhcpServerCustomOptionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDhcpServerCustomOptionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDhcpServerCustomOptionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDhcpServerCustomOptionEndpointRequestParentID) Accept(visitor GetServicesDhcpServerCustomOptionEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDhcpServerCustomOptionEndpointResponse struct {
	Data *GetServicesDhcpServerCustomOptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerCustomOptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerCustomOptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerCustomOptionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerCustomOptionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerCustomOptionEndpointResponseData struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value    *string `json:"value,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerCustomOptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerCustomOptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerCustomOptionEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerCustomOptionEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags string

const (
	GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortRegular      GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortNumeric      GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortString       GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortLocaleString GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortNatural      GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortFlagCase     GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsFromString(s string) (GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags) Ptr() *GetServicesDhcpServerCustomOptionsEndpointRequestSortFlags {
	return &g
}

type GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder string

const (
	GetServicesDhcpServerCustomOptionsEndpointRequestSortOrderSortAsc  GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDhcpServerCustomOptionsEndpointRequestSortOrderSortDesc GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDhcpServerCustomOptionsEndpointRequestSortOrderFromString(s string) (GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDhcpServerCustomOptionsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder) Ptr() *GetServicesDhcpServerCustomOptionsEndpointRequestSortOrder {
	return &g
}

type GetServicesDhcpServerCustomOptionsEndpointResponse struct {
	Data []*GetServicesDhcpServerCustomOptionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerCustomOptionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerCustomOptionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerCustomOptionsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerCustomOptionsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerCustomOptionsEndpointResponseDataItem struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value    *string `json:"value,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerCustomOptionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerCustomOptionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerCustomOptionsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerCustomOptionsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDhcpServerEndpointRequestIDFromInteger(value int) *GetServicesDhcpServerEndpointRequestID {
	return &GetServicesDhcpServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDhcpServerEndpointRequestIDFromString(value string) *GetServicesDhcpServerEndpointRequestID {
	return &GetServicesDhcpServerEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDhcpServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDhcpServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDhcpServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDhcpServerEndpointRequestID) Accept(visitor GetServicesDhcpServerEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDhcpServerEndpointResponse struct {
	Data *GetServicesDhcpServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerEndpointResponseData struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
	ID        *string                    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerStaticMappingEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDhcpServerStaticMappingEndpointRequestIDFromInteger(value int) *GetServicesDhcpServerStaticMappingEndpointRequestID {
	return &GetServicesDhcpServerStaticMappingEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDhcpServerStaticMappingEndpointRequestIDFromString(value string) *GetServicesDhcpServerStaticMappingEndpointRequestID {
	return &GetServicesDhcpServerStaticMappingEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDhcpServerStaticMappingEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDhcpServerStaticMappingEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDhcpServerStaticMappingEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDhcpServerStaticMappingEndpointRequestID) Accept(visitor GetServicesDhcpServerStaticMappingEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDhcpServerStaticMappingEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDhcpServerStaticMappingEndpointRequestParentIDFromInteger(value int) *GetServicesDhcpServerStaticMappingEndpointRequestParentID {
	return &GetServicesDhcpServerStaticMappingEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesDhcpServerStaticMappingEndpointRequestParentIDFromString(value string) *GetServicesDhcpServerStaticMappingEndpointRequestParentID {
	return &GetServicesDhcpServerStaticMappingEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesDhcpServerStaticMappingEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDhcpServerStaticMappingEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDhcpServerStaticMappingEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDhcpServerStaticMappingEndpointRequestParentID) Accept(visitor GetServicesDhcpServerStaticMappingEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDhcpServerStaticMappingEndpointResponse struct {
	Data *GetServicesDhcpServerStaticMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerStaticMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerStaticMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerStaticMappingEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerStaticMappingEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerStaticMappingEndpointResponseData struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerStaticMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerStaticMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerStaticMappingEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerStaticMappingEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags string

const (
	GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortRegular      GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortNumeric      GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortString       GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortLocaleString GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortNatural      GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortFlagCase     GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsFromString(s string) (GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags) Ptr() *GetServicesDhcpServerStaticMappingsEndpointRequestSortFlags {
	return &g
}

type GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder string

const (
	GetServicesDhcpServerStaticMappingsEndpointRequestSortOrderSortAsc  GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDhcpServerStaticMappingsEndpointRequestSortOrderSortDesc GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDhcpServerStaticMappingsEndpointRequestSortOrderFromString(s string) (GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDhcpServerStaticMappingsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder) Ptr() *GetServicesDhcpServerStaticMappingsEndpointRequestSortOrder {
	return &g
}

type GetServicesDhcpServerStaticMappingsEndpointResponse struct {
	Data []*GetServicesDhcpServerStaticMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerStaticMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerStaticMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerStaticMappingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerStaticMappingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServerStaticMappingsEndpointResponseDataItem struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServerStaticMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServerStaticMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServerStaticMappingsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServerStaticMappingsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServersEndpointRequestSortFlags string

const (
	GetServicesDhcpServersEndpointRequestSortFlagsSortRegular      GetServicesDhcpServersEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDhcpServersEndpointRequestSortFlagsSortNumeric      GetServicesDhcpServersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDhcpServersEndpointRequestSortFlagsSortString       GetServicesDhcpServersEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDhcpServersEndpointRequestSortFlagsSortLocaleString GetServicesDhcpServersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDhcpServersEndpointRequestSortFlagsSortNatural      GetServicesDhcpServersEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDhcpServersEndpointRequestSortFlagsSortFlagCase     GetServicesDhcpServersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDhcpServersEndpointRequestSortFlagsFromString(s string) (GetServicesDhcpServersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDhcpServersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDhcpServersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDhcpServersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDhcpServersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDhcpServersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDhcpServersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDhcpServersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServersEndpointRequestSortFlags) Ptr() *GetServicesDhcpServersEndpointRequestSortFlags {
	return &g
}

type GetServicesDhcpServersEndpointRequestSortOrder string

const (
	GetServicesDhcpServersEndpointRequestSortOrderSortAsc  GetServicesDhcpServersEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDhcpServersEndpointRequestSortOrderSortDesc GetServicesDhcpServersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDhcpServersEndpointRequestSortOrderFromString(s string) (GetServicesDhcpServersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDhcpServersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDhcpServersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDhcpServersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDhcpServersEndpointRequestSortOrder) Ptr() *GetServicesDhcpServersEndpointRequestSortOrder {
	return &g
}

type GetServicesDhcpServersEndpointResponse struct {
	Data []*GetServicesDhcpServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDhcpServersEndpointResponseDataItem struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
	ID        *string                    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDhcpServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDhcpServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDhcpServersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDhcpServersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderApplyEndpointResponse struct {
	Data *DNSForwarderApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverrideAliasEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSForwarderHostOverrideAliasEndpointRequestIDFromInteger(value int) *GetServicesDNSForwarderHostOverrideAliasEndpointRequestID {
	return &GetServicesDNSForwarderHostOverrideAliasEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSForwarderHostOverrideAliasEndpointRequestIDFromString(value string) *GetServicesDNSForwarderHostOverrideAliasEndpointRequestID {
	return &GetServicesDNSForwarderHostOverrideAliasEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSForwarderHostOverrideAliasEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSForwarderHostOverrideAliasEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointRequestID) Accept(visitor GetServicesDNSForwarderHostOverrideAliasEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDFromInteger(value int) *GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID {
	return &GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDFromString(value string) *GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID {
	return &GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentID) Accept(visitor GetServicesDNSForwarderHostOverrideAliasEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSForwarderHostOverrideAliasEndpointResponse struct {
	Data *GetServicesDNSForwarderHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverrideAliasEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverrideAliasEndpointResponseData struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverrideAliasEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverrideAliasEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags string

const (
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortRegular      GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortNumeric      GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortString       GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortLocaleString GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortNatural      GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortFlagCase     GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsFromString(s string) (GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags) Ptr() *GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortFlags {
	return &g
}

type GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder string

const (
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrderSortAsc  GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrderSortDesc GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrderFromString(s string) (GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder) Ptr() *GetServicesDNSForwarderHostOverrideAliasesEndpointRequestSortOrder {
	return &g
}

type GetServicesDNSForwarderHostOverrideAliasesEndpointResponse struct {
	Data []*GetServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverrideAliasesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverrideAliasesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverrideAliasesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverrideAliasesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverrideAliasesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverrideEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSForwarderHostOverrideEndpointRequestIDFromInteger(value int) *GetServicesDNSForwarderHostOverrideEndpointRequestID {
	return &GetServicesDNSForwarderHostOverrideEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSForwarderHostOverrideEndpointRequestIDFromString(value string) *GetServicesDNSForwarderHostOverrideEndpointRequestID {
	return &GetServicesDNSForwarderHostOverrideEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDNSForwarderHostOverrideEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSForwarderHostOverrideEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSForwarderHostOverrideEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSForwarderHostOverrideEndpointRequestID) Accept(visitor GetServicesDNSForwarderHostOverrideEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSForwarderHostOverrideEndpointResponse struct {
	Data *GetServicesDNSForwarderHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverrideEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverrideEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverrideEndpointResponseData struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverrideEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverrideEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags string

const (
	GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortRegular      GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortNumeric      GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortString       GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortLocaleString GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortNatural      GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortFlagCase     GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsFromString(s string) (GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags) Ptr() *GetServicesDNSForwarderHostOverridesEndpointRequestSortFlags {
	return &g
}

type GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder string

const (
	GetServicesDNSForwarderHostOverridesEndpointRequestSortOrderSortAsc  GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDNSForwarderHostOverridesEndpointRequestSortOrderSortDesc GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDNSForwarderHostOverridesEndpointRequestSortOrderFromString(s string) (GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDNSForwarderHostOverridesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder) Ptr() *GetServicesDNSForwarderHostOverridesEndpointRequestSortOrder {
	return &g
}

type GetServicesDNSForwarderHostOverridesEndpointResponse struct {
	Data []*GetServicesDNSForwarderHostOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverridesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverridesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSForwarderHostOverridesEndpointResponseDataItem struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSForwarderHostOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSForwarderHostOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSForwarderHostOverridesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSForwarderHostOverridesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSResolverAccessListEndpointRequestIDFromInteger(value int) *GetServicesDNSResolverAccessListEndpointRequestID {
	return &GetServicesDNSResolverAccessListEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSResolverAccessListEndpointRequestIDFromString(value string) *GetServicesDNSResolverAccessListEndpointRequestID {
	return &GetServicesDNSResolverAccessListEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDNSResolverAccessListEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSResolverAccessListEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSResolverAccessListEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSResolverAccessListEndpointRequestID) Accept(visitor GetServicesDNSResolverAccessListEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSResolverAccessListEndpointResponse struct {
	Data *GetServicesDNSResolverAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListEndpointResponseData struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	ID       *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListNetworkEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSResolverAccessListNetworkEndpointRequestIDFromInteger(value int) *GetServicesDNSResolverAccessListNetworkEndpointRequestID {
	return &GetServicesDNSResolverAccessListNetworkEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSResolverAccessListNetworkEndpointRequestIDFromString(value string) *GetServicesDNSResolverAccessListNetworkEndpointRequestID {
	return &GetServicesDNSResolverAccessListNetworkEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSResolverAccessListNetworkEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSResolverAccessListNetworkEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointRequestID) Accept(visitor GetServicesDNSResolverAccessListNetworkEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSResolverAccessListNetworkEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSResolverAccessListNetworkEndpointRequestParentIDFromInteger(value int) *GetServicesDNSResolverAccessListNetworkEndpointRequestParentID {
	return &GetServicesDNSResolverAccessListNetworkEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSResolverAccessListNetworkEndpointRequestParentIDFromString(value string) *GetServicesDNSResolverAccessListNetworkEndpointRequestParentID {
	return &GetServicesDNSResolverAccessListNetworkEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSResolverAccessListNetworkEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSResolverAccessListNetworkEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointRequestParentID) Accept(visitor GetServicesDNSResolverAccessListNetworkEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSResolverAccessListNetworkEndpointResponse struct {
	Data *GetServicesDNSResolverAccessListNetworkEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListNetworkEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListNetworkEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListNetworkEndpointResponseData struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListNetworkEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListNetworkEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListNetworkEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags string

const (
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortRegular      GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortNumeric      GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortString       GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortLocaleString GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortNatural      GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortFlagCase     GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsFromString(s string) (GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags) Ptr() *GetServicesDNSResolverAccessListNetworksEndpointRequestSortFlags {
	return &g
}

type GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder string

const (
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrderSortAsc  GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrderSortDesc GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDNSResolverAccessListNetworksEndpointRequestSortOrderFromString(s string) (GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder) Ptr() *GetServicesDNSResolverAccessListNetworksEndpointRequestSortOrder {
	return &g
}

type GetServicesDNSResolverAccessListNetworksEndpointResponse struct {
	Data []*GetServicesDNSResolverAccessListNetworksEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListNetworksEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListNetworksEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListNetworksEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListNetworksEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListNetworksEndpointResponseDataItem struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListNetworksEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListNetworksEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListNetworksEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListNetworksEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListsEndpointRequestSortFlags string

const (
	GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortRegular      GetServicesDNSResolverAccessListsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortNumeric      GetServicesDNSResolverAccessListsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortString       GetServicesDNSResolverAccessListsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortLocaleString GetServicesDNSResolverAccessListsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortNatural      GetServicesDNSResolverAccessListsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortFlagCase     GetServicesDNSResolverAccessListsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDNSResolverAccessListsEndpointRequestSortFlagsFromString(s string) (GetServicesDNSResolverAccessListsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDNSResolverAccessListsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDNSResolverAccessListsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverAccessListsEndpointRequestSortFlags) Ptr() *GetServicesDNSResolverAccessListsEndpointRequestSortFlags {
	return &g
}

type GetServicesDNSResolverAccessListsEndpointRequestSortOrder string

const (
	GetServicesDNSResolverAccessListsEndpointRequestSortOrderSortAsc  GetServicesDNSResolverAccessListsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDNSResolverAccessListsEndpointRequestSortOrderSortDesc GetServicesDNSResolverAccessListsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDNSResolverAccessListsEndpointRequestSortOrderFromString(s string) (GetServicesDNSResolverAccessListsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDNSResolverAccessListsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDNSResolverAccessListsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDNSResolverAccessListsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverAccessListsEndpointRequestSortOrder) Ptr() *GetServicesDNSResolverAccessListsEndpointRequestSortOrder {
	return &g
}

type GetServicesDNSResolverAccessListsEndpointResponse struct {
	Data []*GetServicesDNSResolverAccessListsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverAccessListsEndpointResponseDataItem struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	ID       *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverAccessListsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverAccessListsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverAccessListsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverAccessListsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverApplyEndpointResponse struct {
	Data *DNSResolverApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverDomainOverrideEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSResolverDomainOverrideEndpointRequestIDFromInteger(value int) *GetServicesDNSResolverDomainOverrideEndpointRequestID {
	return &GetServicesDNSResolverDomainOverrideEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSResolverDomainOverrideEndpointRequestIDFromString(value string) *GetServicesDNSResolverDomainOverrideEndpointRequestID {
	return &GetServicesDNSResolverDomainOverrideEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDNSResolverDomainOverrideEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSResolverDomainOverrideEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSResolverDomainOverrideEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSResolverDomainOverrideEndpointRequestID) Accept(visitor GetServicesDNSResolverDomainOverrideEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSResolverDomainOverrideEndpointResponse struct {
	Data *GetServicesDNSResolverDomainOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverDomainOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverDomainOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverDomainOverrideEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverDomainOverrideEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverDomainOverrideEndpointResponseData struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverDomainOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverDomainOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverDomainOverrideEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverDomainOverrideEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags string

const (
	GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortRegular      GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortNumeric      GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortString       GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortLocaleString GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortNatural      GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortFlagCase     GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsFromString(s string) (GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags) Ptr() *GetServicesDNSResolverDomainOverridesEndpointRequestSortFlags {
	return &g
}

type GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder string

const (
	GetServicesDNSResolverDomainOverridesEndpointRequestSortOrderSortAsc  GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDNSResolverDomainOverridesEndpointRequestSortOrderSortDesc GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDNSResolverDomainOverridesEndpointRequestSortOrderFromString(s string) (GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDNSResolverDomainOverridesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder) Ptr() *GetServicesDNSResolverDomainOverridesEndpointRequestSortOrder {
	return &g
}

type GetServicesDNSResolverDomainOverridesEndpointResponse struct {
	Data []*GetServicesDNSResolverDomainOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverDomainOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverDomainOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverDomainOverridesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverDomainOverridesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverDomainOverridesEndpointResponseDataItem struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverDomainOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverDomainOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverDomainOverridesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverDomainOverridesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverrideAliasEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSResolverHostOverrideAliasEndpointRequestIDFromInteger(value int) *GetServicesDNSResolverHostOverrideAliasEndpointRequestID {
	return &GetServicesDNSResolverHostOverrideAliasEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSResolverHostOverrideAliasEndpointRequestIDFromString(value string) *GetServicesDNSResolverHostOverrideAliasEndpointRequestID {
	return &GetServicesDNSResolverHostOverrideAliasEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSResolverHostOverrideAliasEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSResolverHostOverrideAliasEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointRequestID) Accept(visitor GetServicesDNSResolverHostOverrideAliasEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSResolverHostOverrideAliasEndpointRequestParentIDFromInteger(value int) *GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID {
	return &GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSResolverHostOverrideAliasEndpointRequestParentIDFromString(value string) *GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID {
	return &GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSResolverHostOverrideAliasEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointRequestParentID) Accept(visitor GetServicesDNSResolverHostOverrideAliasEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSResolverHostOverrideAliasEndpointResponse struct {
	Data *GetServicesDNSResolverHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverrideAliasEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverrideAliasEndpointResponseData struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverrideAliasEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverrideAliasEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags string

const (
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortRegular      GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortNumeric      GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortString       GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortLocaleString GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortNatural      GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortFlagCase     GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsFromString(s string) (GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags) Ptr() *GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortFlags {
	return &g
}

type GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder string

const (
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrderSortAsc  GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrderSortDesc GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrderFromString(s string) (GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder) Ptr() *GetServicesDNSResolverHostOverrideAliasesEndpointRequestSortOrder {
	return &g
}

type GetServicesDNSResolverHostOverrideAliasesEndpointResponse struct {
	Data []*GetServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverrideAliasesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverrideAliasesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverrideAliasesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverrideAliasesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverrideAliasesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverrideEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesDNSResolverHostOverrideEndpointRequestIDFromInteger(value int) *GetServicesDNSResolverHostOverrideEndpointRequestID {
	return &GetServicesDNSResolverHostOverrideEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesDNSResolverHostOverrideEndpointRequestIDFromString(value string) *GetServicesDNSResolverHostOverrideEndpointRequestID {
	return &GetServicesDNSResolverHostOverrideEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesDNSResolverHostOverrideEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesDNSResolverHostOverrideEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesDNSResolverHostOverrideEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesDNSResolverHostOverrideEndpointRequestID) Accept(visitor GetServicesDNSResolverHostOverrideEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesDNSResolverHostOverrideEndpointResponse struct {
	Data *GetServicesDNSResolverHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverrideEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverrideEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverrideEndpointResponseData struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverrideEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverrideEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverridesEndpointRequestSortFlags string

const (
	GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortRegular      GetServicesDNSResolverHostOverridesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortNumeric      GetServicesDNSResolverHostOverridesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortString       GetServicesDNSResolverHostOverridesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortLocaleString GetServicesDNSResolverHostOverridesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortNatural      GetServicesDNSResolverHostOverridesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortFlagCase     GetServicesDNSResolverHostOverridesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesDNSResolverHostOverridesEndpointRequestSortFlagsFromString(s string) (GetServicesDNSResolverHostOverridesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesDNSResolverHostOverridesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverHostOverridesEndpointRequestSortFlags) Ptr() *GetServicesDNSResolverHostOverridesEndpointRequestSortFlags {
	return &g
}

type GetServicesDNSResolverHostOverridesEndpointRequestSortOrder string

const (
	GetServicesDNSResolverHostOverridesEndpointRequestSortOrderSortAsc  GetServicesDNSResolverHostOverridesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesDNSResolverHostOverridesEndpointRequestSortOrderSortDesc GetServicesDNSResolverHostOverridesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesDNSResolverHostOverridesEndpointRequestSortOrderFromString(s string) (GetServicesDNSResolverHostOverridesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesDNSResolverHostOverridesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesDNSResolverHostOverridesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesDNSResolverHostOverridesEndpointRequestSortOrder) Ptr() *GetServicesDNSResolverHostOverridesEndpointRequestSortOrder {
	return &g
}

type GetServicesDNSResolverHostOverridesEndpointResponse struct {
	Data []*GetServicesDNSResolverHostOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverridesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverridesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverHostOverridesEndpointResponseDataItem struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverHostOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverHostOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverHostOverridesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverHostOverridesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesDNSResolverSettingsEndpointResponse struct {
	Data *DNSResolverSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesDNSResolverSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesDNSResolverSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesDNSResolverSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesDNSResolverSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusClientEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesFreeRadiusClientEndpointRequestIDFromInteger(value int) *GetServicesFreeRadiusClientEndpointRequestID {
	return &GetServicesFreeRadiusClientEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesFreeRadiusClientEndpointRequestIDFromString(value string) *GetServicesFreeRadiusClientEndpointRequestID {
	return &GetServicesFreeRadiusClientEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesFreeRadiusClientEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesFreeRadiusClientEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesFreeRadiusClientEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesFreeRadiusClientEndpointRequestID) Accept(visitor GetServicesFreeRadiusClientEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesFreeRadiusClientEndpointResponse struct {
	Data *GetServicesFreeRadiusClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusClientEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusClientEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusClientEndpointResponseData struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusClientEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusClientEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusClientsEndpointRequestSortFlags string

const (
	GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortRegular      GetServicesFreeRadiusClientsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortNumeric      GetServicesFreeRadiusClientsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortString       GetServicesFreeRadiusClientsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortLocaleString GetServicesFreeRadiusClientsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortNatural      GetServicesFreeRadiusClientsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortFlagCase     GetServicesFreeRadiusClientsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesFreeRadiusClientsEndpointRequestSortFlagsFromString(s string) (GetServicesFreeRadiusClientsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesFreeRadiusClientsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesFreeRadiusClientsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesFreeRadiusClientsEndpointRequestSortFlags) Ptr() *GetServicesFreeRadiusClientsEndpointRequestSortFlags {
	return &g
}

type GetServicesFreeRadiusClientsEndpointRequestSortOrder string

const (
	GetServicesFreeRadiusClientsEndpointRequestSortOrderSortAsc  GetServicesFreeRadiusClientsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesFreeRadiusClientsEndpointRequestSortOrderSortDesc GetServicesFreeRadiusClientsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesFreeRadiusClientsEndpointRequestSortOrderFromString(s string) (GetServicesFreeRadiusClientsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesFreeRadiusClientsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesFreeRadiusClientsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesFreeRadiusClientsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesFreeRadiusClientsEndpointRequestSortOrder) Ptr() *GetServicesFreeRadiusClientsEndpointRequestSortOrder {
	return &g
}

type GetServicesFreeRadiusClientsEndpointResponse struct {
	Data []*GetServicesFreeRadiusClientsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusClientsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusClientsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusClientsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusClientsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusClientsEndpointResponseDataItem struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusClientsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusClientsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusClientsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusClientsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusInterfaceEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesFreeRadiusInterfaceEndpointRequestIDFromInteger(value int) *GetServicesFreeRadiusInterfaceEndpointRequestID {
	return &GetServicesFreeRadiusInterfaceEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesFreeRadiusInterfaceEndpointRequestIDFromString(value string) *GetServicesFreeRadiusInterfaceEndpointRequestID {
	return &GetServicesFreeRadiusInterfaceEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesFreeRadiusInterfaceEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesFreeRadiusInterfaceEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesFreeRadiusInterfaceEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesFreeRadiusInterfaceEndpointRequestID) Accept(visitor GetServicesFreeRadiusInterfaceEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesFreeRadiusInterfaceEndpointResponse struct {
	Data *GetServicesFreeRadiusInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusInterfaceEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusInterfaceEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusInterfaceEndpointResponseData struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusInterfaceEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusInterfaceEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusInterfacesEndpointRequestSortFlags string

const (
	GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortRegular      GetServicesFreeRadiusInterfacesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortNumeric      GetServicesFreeRadiusInterfacesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortString       GetServicesFreeRadiusInterfacesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortLocaleString GetServicesFreeRadiusInterfacesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortNatural      GetServicesFreeRadiusInterfacesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortFlagCase     GetServicesFreeRadiusInterfacesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesFreeRadiusInterfacesEndpointRequestSortFlagsFromString(s string) (GetServicesFreeRadiusInterfacesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesFreeRadiusInterfacesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesFreeRadiusInterfacesEndpointRequestSortFlags) Ptr() *GetServicesFreeRadiusInterfacesEndpointRequestSortFlags {
	return &g
}

type GetServicesFreeRadiusInterfacesEndpointRequestSortOrder string

const (
	GetServicesFreeRadiusInterfacesEndpointRequestSortOrderSortAsc  GetServicesFreeRadiusInterfacesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesFreeRadiusInterfacesEndpointRequestSortOrderSortDesc GetServicesFreeRadiusInterfacesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesFreeRadiusInterfacesEndpointRequestSortOrderFromString(s string) (GetServicesFreeRadiusInterfacesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesFreeRadiusInterfacesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesFreeRadiusInterfacesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesFreeRadiusInterfacesEndpointRequestSortOrder) Ptr() *GetServicesFreeRadiusInterfacesEndpointRequestSortOrder {
	return &g
}

type GetServicesFreeRadiusInterfacesEndpointResponse struct {
	Data []*GetServicesFreeRadiusInterfacesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusInterfacesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusInterfacesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusInterfacesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusInterfacesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusInterfacesEndpointResponseDataItem struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusInterfacesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusInterfacesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusInterfacesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusInterfacesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusUserEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesFreeRadiusUserEndpointRequestIDFromInteger(value int) *GetServicesFreeRadiusUserEndpointRequestID {
	return &GetServicesFreeRadiusUserEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesFreeRadiusUserEndpointRequestIDFromString(value string) *GetServicesFreeRadiusUserEndpointRequestID {
	return &GetServicesFreeRadiusUserEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesFreeRadiusUserEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesFreeRadiusUserEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesFreeRadiusUserEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesFreeRadiusUserEndpointRequestID) Accept(visitor GetServicesFreeRadiusUserEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesFreeRadiusUserEndpointResponse struct {
	Data *GetServicesFreeRadiusUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusUserEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusUserEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusUserEndpointResponseData struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusUserEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusUserEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusUsersEndpointRequestSortFlags string

const (
	GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortRegular      GetServicesFreeRadiusUsersEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortNumeric      GetServicesFreeRadiusUsersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortString       GetServicesFreeRadiusUsersEndpointRequestSortFlags = "SORT_STRING"
	GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortLocaleString GetServicesFreeRadiusUsersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortNatural      GetServicesFreeRadiusUsersEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortFlagCase     GetServicesFreeRadiusUsersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesFreeRadiusUsersEndpointRequestSortFlagsFromString(s string) (GetServicesFreeRadiusUsersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesFreeRadiusUsersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesFreeRadiusUsersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesFreeRadiusUsersEndpointRequestSortFlags) Ptr() *GetServicesFreeRadiusUsersEndpointRequestSortFlags {
	return &g
}

type GetServicesFreeRadiusUsersEndpointRequestSortOrder string

const (
	GetServicesFreeRadiusUsersEndpointRequestSortOrderSortAsc  GetServicesFreeRadiusUsersEndpointRequestSortOrder = "SORT_ASC"
	GetServicesFreeRadiusUsersEndpointRequestSortOrderSortDesc GetServicesFreeRadiusUsersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesFreeRadiusUsersEndpointRequestSortOrderFromString(s string) (GetServicesFreeRadiusUsersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesFreeRadiusUsersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesFreeRadiusUsersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesFreeRadiusUsersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesFreeRadiusUsersEndpointRequestSortOrder) Ptr() *GetServicesFreeRadiusUsersEndpointRequestSortOrder {
	return &g
}

type GetServicesFreeRadiusUsersEndpointResponse struct {
	Data []*GetServicesFreeRadiusUsersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusUsersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusUsersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusUsersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusUsersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesFreeRadiusUsersEndpointResponseDataItem struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesFreeRadiusUsersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesFreeRadiusUsersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesFreeRadiusUsersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesFreeRadiusUsersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyApplyEndpointResponse struct {
	Data *HaProxyApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendAcLsEndpointRequestSortFlags string

const (
	GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortRegular      GetServicesHaProxyBackendAcLsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyBackendAcLsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortString       GetServicesHaProxyBackendAcLsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyBackendAcLsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortNatural      GetServicesHaProxyBackendAcLsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyBackendAcLsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyBackendAcLsEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyBackendAcLsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyBackendAcLsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendAcLsEndpointRequestSortFlags) Ptr() *GetServicesHaProxyBackendAcLsEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyBackendAcLsEndpointRequestSortOrder string

const (
	GetServicesHaProxyBackendAcLsEndpointRequestSortOrderSortAsc  GetServicesHaProxyBackendAcLsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyBackendAcLsEndpointRequestSortOrderSortDesc GetServicesHaProxyBackendAcLsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyBackendAcLsEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyBackendAcLsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyBackendAcLsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyBackendAcLsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendAcLsEndpointRequestSortOrder) Ptr() *GetServicesHaProxyBackendAcLsEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyBackendAcLsEndpointResponse struct {
	Data []*GetServicesHaProxyBackendAcLsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendAcLsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendAcLsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendAcLsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendAcLsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendAcLsEndpointResponseDataItem struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendAcLsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendAcLsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendAcLsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendAcLsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendACLEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendACLEndpointRequestIDFromInteger(value int) *GetServicesHaProxyBackendACLEndpointRequestID {
	return &GetServicesHaProxyBackendACLEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendACLEndpointRequestIDFromString(value string) *GetServicesHaProxyBackendACLEndpointRequestID {
	return &GetServicesHaProxyBackendACLEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendACLEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendACLEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendACLEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendACLEndpointRequestID) Accept(visitor GetServicesHaProxyBackendACLEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendACLEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendACLEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyBackendACLEndpointRequestParentID {
	return &GetServicesHaProxyBackendACLEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendACLEndpointRequestParentIDFromString(value string) *GetServicesHaProxyBackendACLEndpointRequestParentID {
	return &GetServicesHaProxyBackendACLEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendACLEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendACLEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendACLEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendACLEndpointRequestParentID) Accept(visitor GetServicesHaProxyBackendACLEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendACLEndpointResponse struct {
	Data *GetServicesHaProxyBackendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendACLEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendACLEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendACLEndpointResponseData struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendACLEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendACLEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendActionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendActionEndpointRequestIDFromInteger(value int) *GetServicesHaProxyBackendActionEndpointRequestID {
	return &GetServicesHaProxyBackendActionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendActionEndpointRequestIDFromString(value string) *GetServicesHaProxyBackendActionEndpointRequestID {
	return &GetServicesHaProxyBackendActionEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendActionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendActionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendActionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendActionEndpointRequestID) Accept(visitor GetServicesHaProxyBackendActionEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendActionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendActionEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyBackendActionEndpointRequestParentID {
	return &GetServicesHaProxyBackendActionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendActionEndpointRequestParentIDFromString(value string) *GetServicesHaProxyBackendActionEndpointRequestParentID {
	return &GetServicesHaProxyBackendActionEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendActionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendActionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendActionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendActionEndpointRequestParentID) Accept(visitor GetServicesHaProxyBackendActionEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendActionEndpointResponse struct {
	Data *GetServicesHaProxyBackendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendActionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendActionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendActionEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendActionEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendActionsEndpointRequestSortFlags string

const (
	GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortRegular      GetServicesHaProxyBackendActionsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyBackendActionsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortString       GetServicesHaProxyBackendActionsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyBackendActionsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortNatural      GetServicesHaProxyBackendActionsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyBackendActionsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyBackendActionsEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyBackendActionsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyBackendActionsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyBackendActionsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendActionsEndpointRequestSortFlags) Ptr() *GetServicesHaProxyBackendActionsEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyBackendActionsEndpointRequestSortOrder string

const (
	GetServicesHaProxyBackendActionsEndpointRequestSortOrderSortAsc  GetServicesHaProxyBackendActionsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyBackendActionsEndpointRequestSortOrderSortDesc GetServicesHaProxyBackendActionsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyBackendActionsEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyBackendActionsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyBackendActionsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyBackendActionsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyBackendActionsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendActionsEndpointRequestSortOrder) Ptr() *GetServicesHaProxyBackendActionsEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyBackendActionsEndpointResponse struct {
	Data []*GetServicesHaProxyBackendActionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendActionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendActionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendActionsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendActionsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendActionsEndpointResponseDataItem struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendActionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendActionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendActionsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendActionsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendEndpointRequestIDFromInteger(value int) *GetServicesHaProxyBackendEndpointRequestID {
	return &GetServicesHaProxyBackendEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendEndpointRequestIDFromString(value string) *GetServicesHaProxyBackendEndpointRequestID {
	return &GetServicesHaProxyBackendEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendEndpointRequestID) Accept(visitor GetServicesHaProxyBackendEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendEndpointResponse struct {
	Data *GetServicesHaProxyBackendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendEndpointResponseData struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendErrorFileEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendErrorFileEndpointRequestIDFromInteger(value int) *GetServicesHaProxyBackendErrorFileEndpointRequestID {
	return &GetServicesHaProxyBackendErrorFileEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendErrorFileEndpointRequestIDFromString(value string) *GetServicesHaProxyBackendErrorFileEndpointRequestID {
	return &GetServicesHaProxyBackendErrorFileEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendErrorFileEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendErrorFileEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendErrorFileEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendErrorFileEndpointRequestID) Accept(visitor GetServicesHaProxyBackendErrorFileEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendErrorFileEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendErrorFileEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyBackendErrorFileEndpointRequestParentID {
	return &GetServicesHaProxyBackendErrorFileEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendErrorFileEndpointRequestParentIDFromString(value string) *GetServicesHaProxyBackendErrorFileEndpointRequestParentID {
	return &GetServicesHaProxyBackendErrorFileEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendErrorFileEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendErrorFileEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendErrorFileEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendErrorFileEndpointRequestParentID) Accept(visitor GetServicesHaProxyBackendErrorFileEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendErrorFileEndpointResponse struct {
	Data *GetServicesHaProxyBackendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendErrorFileEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendErrorFileEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendErrorFileEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendErrorFileEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags string

const (
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortRegular      GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortString       GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortNatural      GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags) Ptr() *GetServicesHaProxyBackendErrorFilesEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder string

const (
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrderSortAsc  GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrderSortDesc GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyBackendErrorFilesEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder) Ptr() *GetServicesHaProxyBackendErrorFilesEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyBackendErrorFilesEndpointResponse struct {
	Data []*GetServicesHaProxyBackendErrorFilesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendErrorFilesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendErrorFilesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendErrorFilesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendErrorFilesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendErrorFilesEndpointResponseDataItem struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendErrorFilesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendErrorFilesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendErrorFilesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendErrorFilesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendServerEndpointRequestIDFromInteger(value int) *GetServicesHaProxyBackendServerEndpointRequestID {
	return &GetServicesHaProxyBackendServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendServerEndpointRequestIDFromString(value string) *GetServicesHaProxyBackendServerEndpointRequestID {
	return &GetServicesHaProxyBackendServerEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendServerEndpointRequestID) Accept(visitor GetServicesHaProxyBackendServerEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendServerEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyBackendServerEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyBackendServerEndpointRequestParentID {
	return &GetServicesHaProxyBackendServerEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyBackendServerEndpointRequestParentIDFromString(value string) *GetServicesHaProxyBackendServerEndpointRequestParentID {
	return &GetServicesHaProxyBackendServerEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyBackendServerEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyBackendServerEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyBackendServerEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyBackendServerEndpointRequestParentID) Accept(visitor GetServicesHaProxyBackendServerEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyBackendServerEndpointResponse struct {
	Data *GetServicesHaProxyBackendServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendServerEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendServerEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendServerEndpointResponseData struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendServerEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendServerEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendServersEndpointRequestSortFlags string

const (
	GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortRegular      GetServicesHaProxyBackendServersEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyBackendServersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortString       GetServicesHaProxyBackendServersEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyBackendServersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortNatural      GetServicesHaProxyBackendServersEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyBackendServersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyBackendServersEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyBackendServersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyBackendServersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyBackendServersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendServersEndpointRequestSortFlags) Ptr() *GetServicesHaProxyBackendServersEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyBackendServersEndpointRequestSortOrder string

const (
	GetServicesHaProxyBackendServersEndpointRequestSortOrderSortAsc  GetServicesHaProxyBackendServersEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyBackendServersEndpointRequestSortOrderSortDesc GetServicesHaProxyBackendServersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyBackendServersEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyBackendServersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyBackendServersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyBackendServersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyBackendServersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendServersEndpointRequestSortOrder) Ptr() *GetServicesHaProxyBackendServersEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyBackendServersEndpointResponse struct {
	Data []*GetServicesHaProxyBackendServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendServersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendServersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendServersEndpointResponseDataItem struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendServersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendServersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendsEndpointRequestSortFlags string

const (
	GetServicesHaProxyBackendsEndpointRequestSortFlagsSortRegular      GetServicesHaProxyBackendsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyBackendsEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyBackendsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyBackendsEndpointRequestSortFlagsSortString       GetServicesHaProxyBackendsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyBackendsEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyBackendsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyBackendsEndpointRequestSortFlagsSortNatural      GetServicesHaProxyBackendsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyBackendsEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyBackendsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyBackendsEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyBackendsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyBackendsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyBackendsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyBackendsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyBackendsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyBackendsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyBackendsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyBackendsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendsEndpointRequestSortFlags) Ptr() *GetServicesHaProxyBackendsEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyBackendsEndpointRequestSortOrder string

const (
	GetServicesHaProxyBackendsEndpointRequestSortOrderSortAsc  GetServicesHaProxyBackendsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyBackendsEndpointRequestSortOrderSortDesc GetServicesHaProxyBackendsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyBackendsEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyBackendsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyBackendsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyBackendsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyBackendsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyBackendsEndpointRequestSortOrder) Ptr() *GetServicesHaProxyBackendsEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyBackendsEndpointResponse struct {
	Data []*GetServicesHaProxyBackendsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyBackendsEndpointResponseDataItem struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyBackendsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyBackendsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyBackendsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyBackendsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFileEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFileEndpointRequestIDFromInteger(value int) *GetServicesHaProxyFileEndpointRequestID {
	return &GetServicesHaProxyFileEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFileEndpointRequestIDFromString(value string) *GetServicesHaProxyFileEndpointRequestID {
	return &GetServicesHaProxyFileEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFileEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFileEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFileEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFileEndpointRequestID) Accept(visitor GetServicesHaProxyFileEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFileEndpointResponse struct {
	Data *GetServicesHaProxyFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFileEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFileEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFileEndpointResponseData struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFileEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFileEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFilesRequestSortFlags string

const (
	GetServicesHaProxyFilesRequestSortFlagsSortRegular      GetServicesHaProxyFilesRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyFilesRequestSortFlagsSortNumeric      GetServicesHaProxyFilesRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyFilesRequestSortFlagsSortString       GetServicesHaProxyFilesRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyFilesRequestSortFlagsSortLocaleString GetServicesHaProxyFilesRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyFilesRequestSortFlagsSortNatural      GetServicesHaProxyFilesRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyFilesRequestSortFlagsSortFlagCase     GetServicesHaProxyFilesRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyFilesRequestSortFlagsFromString(s string) (GetServicesHaProxyFilesRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyFilesRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyFilesRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyFilesRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyFilesRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyFilesRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyFilesRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyFilesRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFilesRequestSortFlags) Ptr() *GetServicesHaProxyFilesRequestSortFlags {
	return &g
}

type GetServicesHaProxyFilesRequestSortOrder string

const (
	GetServicesHaProxyFilesRequestSortOrderSortAsc  GetServicesHaProxyFilesRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyFilesRequestSortOrderSortDesc GetServicesHaProxyFilesRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyFilesRequestSortOrderFromString(s string) (GetServicesHaProxyFilesRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyFilesRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyFilesRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyFilesRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFilesRequestSortOrder) Ptr() *GetServicesHaProxyFilesRequestSortOrder {
	return &g
}

type GetServicesHaProxyFilesResponse struct {
	Data []*GetServicesHaProxyFilesResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFilesResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFilesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFilesResponseDataItem struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFilesResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFilesResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFilesResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFilesResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags string

const (
	GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortRegular      GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortString       GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortNatural      GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags) Ptr() *GetServicesHaProxyFrontendAcLsEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder string

const (
	GetServicesHaProxyFrontendAcLsEndpointRequestSortOrderSortAsc  GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyFrontendAcLsEndpointRequestSortOrderSortDesc GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyFrontendAcLsEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyFrontendAcLsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder) Ptr() *GetServicesHaProxyFrontendAcLsEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyFrontendAcLsEndpointResponse struct {
	Data []*GetServicesHaProxyFrontendAcLsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendAcLsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendAcLsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendAcLsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendAcLsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendAcLsEndpointResponseDataItem struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendAcLsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendAcLsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendAcLsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendAcLsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendACLEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendACLEndpointRequestIDFromInteger(value int) *GetServicesHaProxyFrontendACLEndpointRequestID {
	return &GetServicesHaProxyFrontendACLEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendACLEndpointRequestIDFromString(value string) *GetServicesHaProxyFrontendACLEndpointRequestID {
	return &GetServicesHaProxyFrontendACLEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendACLEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendACLEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendACLEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendACLEndpointRequestID) Accept(visitor GetServicesHaProxyFrontendACLEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendACLEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendACLEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyFrontendACLEndpointRequestParentID {
	return &GetServicesHaProxyFrontendACLEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendACLEndpointRequestParentIDFromString(value string) *GetServicesHaProxyFrontendACLEndpointRequestParentID {
	return &GetServicesHaProxyFrontendACLEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendACLEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendACLEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendACLEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendACLEndpointRequestParentID) Accept(visitor GetServicesHaProxyFrontendACLEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendACLEndpointResponse struct {
	Data *GetServicesHaProxyFrontendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendACLEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendACLEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendACLEndpointResponseData struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendACLEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendACLEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendActionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendActionEndpointRequestIDFromInteger(value int) *GetServicesHaProxyFrontendActionEndpointRequestID {
	return &GetServicesHaProxyFrontendActionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendActionEndpointRequestIDFromString(value string) *GetServicesHaProxyFrontendActionEndpointRequestID {
	return &GetServicesHaProxyFrontendActionEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendActionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendActionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendActionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendActionEndpointRequestID) Accept(visitor GetServicesHaProxyFrontendActionEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendActionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendActionEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyFrontendActionEndpointRequestParentID {
	return &GetServicesHaProxyFrontendActionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendActionEndpointRequestParentIDFromString(value string) *GetServicesHaProxyFrontendActionEndpointRequestParentID {
	return &GetServicesHaProxyFrontendActionEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendActionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendActionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendActionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendActionEndpointRequestParentID) Accept(visitor GetServicesHaProxyFrontendActionEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendActionEndpointResponse struct {
	Data *GetServicesHaProxyFrontendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendActionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendActionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendActionEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendActionEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendActionsEndpointRequestSortFlags string

const (
	GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortRegular      GetServicesHaProxyFrontendActionsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyFrontendActionsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortString       GetServicesHaProxyFrontendActionsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyFrontendActionsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortNatural      GetServicesHaProxyFrontendActionsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyFrontendActionsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyFrontendActionsEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyFrontendActionsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyFrontendActionsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendActionsEndpointRequestSortFlags) Ptr() *GetServicesHaProxyFrontendActionsEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyFrontendActionsEndpointRequestSortOrder string

const (
	GetServicesHaProxyFrontendActionsEndpointRequestSortOrderSortAsc  GetServicesHaProxyFrontendActionsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyFrontendActionsEndpointRequestSortOrderSortDesc GetServicesHaProxyFrontendActionsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyFrontendActionsEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyFrontendActionsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyFrontendActionsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyFrontendActionsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendActionsEndpointRequestSortOrder) Ptr() *GetServicesHaProxyFrontendActionsEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyFrontendActionsEndpointResponse struct {
	Data []*GetServicesHaProxyFrontendActionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendActionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendActionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendActionsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendActionsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendActionsEndpointResponseDataItem struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendActionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendActionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendActionsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendActionsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendAddressEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendAddressEndpointRequestIDFromInteger(value int) *GetServicesHaProxyFrontendAddressEndpointRequestID {
	return &GetServicesHaProxyFrontendAddressEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendAddressEndpointRequestIDFromString(value string) *GetServicesHaProxyFrontendAddressEndpointRequestID {
	return &GetServicesHaProxyFrontendAddressEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendAddressEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendAddressEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendAddressEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendAddressEndpointRequestID) Accept(visitor GetServicesHaProxyFrontendAddressEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendAddressEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendAddressEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyFrontendAddressEndpointRequestParentID {
	return &GetServicesHaProxyFrontendAddressEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendAddressEndpointRequestParentIDFromString(value string) *GetServicesHaProxyFrontendAddressEndpointRequestParentID {
	return &GetServicesHaProxyFrontendAddressEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendAddressEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendAddressEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendAddressEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendAddressEndpointRequestParentID) Accept(visitor GetServicesHaProxyFrontendAddressEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendAddressEndpointResponse struct {
	Data *GetServicesHaProxyFrontendAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendAddressEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendAddressEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendAddressEndpointResponseData struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendAddressEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendAddressEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags string

const (
	GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortRegular      GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortString       GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortNatural      GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags) Ptr() *GetServicesHaProxyFrontendAddressesEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder string

const (
	GetServicesHaProxyFrontendAddressesEndpointRequestSortOrderSortAsc  GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyFrontendAddressesEndpointRequestSortOrderSortDesc GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyFrontendAddressesEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyFrontendAddressesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder) Ptr() *GetServicesHaProxyFrontendAddressesEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyFrontendAddressesEndpointResponse struct {
	Data []*GetServicesHaProxyFrontendAddressesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendAddressesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendAddressesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendAddressesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendAddressesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendAddressesEndpointResponseDataItem struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendAddressesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendAddressesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendAddressesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendAddressesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendCertificateEndpointRequestIDFromInteger(value int) *GetServicesHaProxyFrontendCertificateEndpointRequestID {
	return &GetServicesHaProxyFrontendCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendCertificateEndpointRequestIDFromString(value string) *GetServicesHaProxyFrontendCertificateEndpointRequestID {
	return &GetServicesHaProxyFrontendCertificateEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendCertificateEndpointRequestID) Accept(visitor GetServicesHaProxyFrontendCertificateEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendCertificateEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendCertificateEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyFrontendCertificateEndpointRequestParentID {
	return &GetServicesHaProxyFrontendCertificateEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendCertificateEndpointRequestParentIDFromString(value string) *GetServicesHaProxyFrontendCertificateEndpointRequestParentID {
	return &GetServicesHaProxyFrontendCertificateEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendCertificateEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendCertificateEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendCertificateEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendCertificateEndpointRequestParentID) Accept(visitor GetServicesHaProxyFrontendCertificateEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendCertificateEndpointResponse struct {
	Data *GetServicesHaProxyFrontendCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendCertificateEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendCertificateEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendCertificateEndpointResponseData struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendCertificateEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendCertificateEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags string

const (
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortRegular      GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortString       GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortNatural      GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags) Ptr() *GetServicesHaProxyFrontendCertificatesEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder string

const (
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrderSortAsc  GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrderSortDesc GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyFrontendCertificatesEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder) Ptr() *GetServicesHaProxyFrontendCertificatesEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyFrontendCertificatesEndpointResponse struct {
	Data []*GetServicesHaProxyFrontendCertificatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendCertificatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendCertificatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendCertificatesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendCertificatesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendCertificatesEndpointResponseDataItem struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendCertificatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendCertificatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendCertificatesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendCertificatesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendEndpointRequestIDFromInteger(value int) *GetServicesHaProxyFrontendEndpointRequestID {
	return &GetServicesHaProxyFrontendEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendEndpointRequestIDFromString(value string) *GetServicesHaProxyFrontendEndpointRequestID {
	return &GetServicesHaProxyFrontendEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendEndpointRequestID) Accept(visitor GetServicesHaProxyFrontendEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendEndpointResponse struct {
	Data *GetServicesHaProxyFrontendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendEndpointResponseData struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	ID             *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendErrorFileEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendErrorFileEndpointRequestIDFromInteger(value int) *GetServicesHaProxyFrontendErrorFileEndpointRequestID {
	return &GetServicesHaProxyFrontendErrorFileEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendErrorFileEndpointRequestIDFromString(value string) *GetServicesHaProxyFrontendErrorFileEndpointRequestID {
	return &GetServicesHaProxyFrontendErrorFileEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendErrorFileEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendErrorFileEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointRequestID) Accept(visitor GetServicesHaProxyFrontendErrorFileEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendErrorFileEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxyFrontendErrorFileEndpointRequestParentIDFromInteger(value int) *GetServicesHaProxyFrontendErrorFileEndpointRequestParentID {
	return &GetServicesHaProxyFrontendErrorFileEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxyFrontendErrorFileEndpointRequestParentIDFromString(value string) *GetServicesHaProxyFrontendErrorFileEndpointRequestParentID {
	return &GetServicesHaProxyFrontendErrorFileEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxyFrontendErrorFileEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxyFrontendErrorFileEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointRequestParentID) Accept(visitor GetServicesHaProxyFrontendErrorFileEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxyFrontendErrorFileEndpointResponse struct {
	Data *GetServicesHaProxyFrontendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendErrorFileEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendErrorFileEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendErrorFileEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags string

const (
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortRegular      GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortString       GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortNatural      GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags) Ptr() *GetServicesHaProxyFrontendErrorFilesEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder string

const (
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrderSortAsc  GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrderSortDesc GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder) Ptr() *GetServicesHaProxyFrontendErrorFilesEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyFrontendErrorFilesEndpointResponse struct {
	Data []*GetServicesHaProxyFrontendErrorFilesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendErrorFilesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendErrorFilesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendErrorFilesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendErrorFilesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendErrorFilesEndpointResponseDataItem struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendErrorFilesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendErrorFilesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendErrorFilesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendErrorFilesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendsEndpointRequestSortFlags string

const (
	GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortRegular      GetServicesHaProxyFrontendsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortNumeric      GetServicesHaProxyFrontendsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortString       GetServicesHaProxyFrontendsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortLocaleString GetServicesHaProxyFrontendsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortNatural      GetServicesHaProxyFrontendsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxyFrontendsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxyFrontendsEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxyFrontendsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxyFrontendsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxyFrontendsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendsEndpointRequestSortFlags) Ptr() *GetServicesHaProxyFrontendsEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxyFrontendsEndpointRequestSortOrder string

const (
	GetServicesHaProxyFrontendsEndpointRequestSortOrderSortAsc  GetServicesHaProxyFrontendsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxyFrontendsEndpointRequestSortOrderSortDesc GetServicesHaProxyFrontendsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxyFrontendsEndpointRequestSortOrderFromString(s string) (GetServicesHaProxyFrontendsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxyFrontendsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxyFrontendsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxyFrontendsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxyFrontendsEndpointRequestSortOrder) Ptr() *GetServicesHaProxyFrontendsEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxyFrontendsEndpointResponse struct {
	Data []*GetServicesHaProxyFrontendsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxyFrontendsEndpointResponseDataItem struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	ID             *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxyFrontendsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxyFrontendsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxyFrontendsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxyFrontendsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsDNSResolverEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxySettingsDNSResolverEndpointRequestIDFromInteger(value int) *GetServicesHaProxySettingsDNSResolverEndpointRequestID {
	return &GetServicesHaProxySettingsDNSResolverEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxySettingsDNSResolverEndpointRequestIDFromString(value string) *GetServicesHaProxySettingsDNSResolverEndpointRequestID {
	return &GetServicesHaProxySettingsDNSResolverEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxySettingsDNSResolverEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxySettingsDNSResolverEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxySettingsDNSResolverEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxySettingsDNSResolverEndpointRequestID) Accept(visitor GetServicesHaProxySettingsDNSResolverEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxySettingsDNSResolverEndpointResponse struct {
	Data *GetServicesHaProxySettingsDNSResolverEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsDNSResolverEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsDNSResolverEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsDNSResolverEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsDNSResolverEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsDNSResolverEndpointResponseData struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port     *string `json:"port,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsDNSResolverEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsDNSResolverEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsDNSResolverEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsDNSResolverEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags string

const (
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortRegular      GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortNumeric      GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortString       GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortLocaleString GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortNatural      GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags) Ptr() *GetServicesHaProxySettingsDNSResolversEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder string

const (
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrderSortAsc  GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrderSortDesc GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxySettingsDNSResolversEndpointRequestSortOrderFromString(s string) (GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder) Ptr() *GetServicesHaProxySettingsDNSResolversEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxySettingsDNSResolversEndpointResponse struct {
	Data []*GetServicesHaProxySettingsDNSResolversEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsDNSResolversEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsDNSResolversEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsDNSResolversEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsDNSResolversEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsDNSResolversEndpointResponseDataItem struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port     *string `json:"port,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsDNSResolversEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsDNSResolversEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsDNSResolversEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsDNSResolversEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsEmailMailerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesHaProxySettingsEmailMailerEndpointRequestIDFromInteger(value int) *GetServicesHaProxySettingsEmailMailerEndpointRequestID {
	return &GetServicesHaProxySettingsEmailMailerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesHaProxySettingsEmailMailerEndpointRequestIDFromString(value string) *GetServicesHaProxySettingsEmailMailerEndpointRequestID {
	return &GetServicesHaProxySettingsEmailMailerEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesHaProxySettingsEmailMailerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesHaProxySettingsEmailMailerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesHaProxySettingsEmailMailerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesHaProxySettingsEmailMailerEndpointRequestID) Accept(visitor GetServicesHaProxySettingsEmailMailerEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesHaProxySettingsEmailMailerEndpointResponse struct {
	Data *GetServicesHaProxySettingsEmailMailerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsEmailMailerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsEmailMailerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsEmailMailerEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsEmailMailerEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsEmailMailerEndpointResponseData struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsEmailMailerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsEmailMailerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsEmailMailerEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsEmailMailerEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags string

const (
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortRegular      GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortNumeric      GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortString       GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags = "SORT_STRING"
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortLocaleString GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortNatural      GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortFlagCase     GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsFromString(s string) (GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags) Ptr() *GetServicesHaProxySettingsEmailMailersEndpointRequestSortFlags {
	return &g
}

type GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder string

const (
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrderSortAsc  GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder = "SORT_ASC"
	GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrderSortDesc GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesHaProxySettingsEmailMailersEndpointRequestSortOrderFromString(s string) (GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder) Ptr() *GetServicesHaProxySettingsEmailMailersEndpointRequestSortOrder {
	return &g
}

type GetServicesHaProxySettingsEmailMailersEndpointResponse struct {
	Data []*GetServicesHaProxySettingsEmailMailersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsEmailMailersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsEmailMailersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsEmailMailersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsEmailMailersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsEmailMailersEndpointResponseDataItem struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsEmailMailersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsEmailMailersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsEmailMailersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsEmailMailersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesHaProxySettingsEndpointResponse struct {
	Data *HaProxySettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesHaProxySettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesHaProxySettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesHaProxySettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesHaProxySettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesNtpSettingsEndpointResponse struct {
	Data *NtpSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesNtpSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesNtpSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesNtpSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesNtpSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesNtpTimeServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesNtpTimeServerEndpointRequestIDFromInteger(value int) *GetServicesNtpTimeServerEndpointRequestID {
	return &GetServicesNtpTimeServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesNtpTimeServerEndpointRequestIDFromString(value string) *GetServicesNtpTimeServerEndpointRequestID {
	return &GetServicesNtpTimeServerEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesNtpTimeServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesNtpTimeServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesNtpTimeServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesNtpTimeServerEndpointRequestID) Accept(visitor GetServicesNtpTimeServerEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesNtpTimeServerEndpointResponse struct {
	Data *GetServicesNtpTimeServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesNtpTimeServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesNtpTimeServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesNtpTimeServerEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesNtpTimeServerEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesNtpTimeServerEndpointResponseData struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesNtpTimeServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesNtpTimeServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesNtpTimeServerEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesNtpTimeServerEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesNtpTimeServersEndpointRequestSortFlags string

const (
	GetServicesNtpTimeServersEndpointRequestSortFlagsSortRegular      GetServicesNtpTimeServersEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesNtpTimeServersEndpointRequestSortFlagsSortNumeric      GetServicesNtpTimeServersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesNtpTimeServersEndpointRequestSortFlagsSortString       GetServicesNtpTimeServersEndpointRequestSortFlags = "SORT_STRING"
	GetServicesNtpTimeServersEndpointRequestSortFlagsSortLocaleString GetServicesNtpTimeServersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesNtpTimeServersEndpointRequestSortFlagsSortNatural      GetServicesNtpTimeServersEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesNtpTimeServersEndpointRequestSortFlagsSortFlagCase     GetServicesNtpTimeServersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesNtpTimeServersEndpointRequestSortFlagsFromString(s string) (GetServicesNtpTimeServersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesNtpTimeServersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesNtpTimeServersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesNtpTimeServersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesNtpTimeServersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesNtpTimeServersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesNtpTimeServersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesNtpTimeServersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesNtpTimeServersEndpointRequestSortFlags) Ptr() *GetServicesNtpTimeServersEndpointRequestSortFlags {
	return &g
}

type GetServicesNtpTimeServersEndpointRequestSortOrder string

const (
	GetServicesNtpTimeServersEndpointRequestSortOrderSortAsc  GetServicesNtpTimeServersEndpointRequestSortOrder = "SORT_ASC"
	GetServicesNtpTimeServersEndpointRequestSortOrderSortDesc GetServicesNtpTimeServersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesNtpTimeServersEndpointRequestSortOrderFromString(s string) (GetServicesNtpTimeServersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesNtpTimeServersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesNtpTimeServersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesNtpTimeServersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesNtpTimeServersEndpointRequestSortOrder) Ptr() *GetServicesNtpTimeServersEndpointRequestSortOrder {
	return &g
}

type GetServicesNtpTimeServersEndpointResponse struct {
	Data []*GetServicesNtpTimeServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesNtpTimeServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesNtpTimeServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesNtpTimeServersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesNtpTimeServersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesNtpTimeServersEndpointResponseDataItem struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesNtpTimeServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesNtpTimeServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesNtpTimeServersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesNtpTimeServersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesServiceWatchdogEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetServicesServiceWatchdogEndpointRequestIDFromInteger(value int) *GetServicesServiceWatchdogEndpointRequestID {
	return &GetServicesServiceWatchdogEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetServicesServiceWatchdogEndpointRequestIDFromString(value string) *GetServicesServiceWatchdogEndpointRequestID {
	return &GetServicesServiceWatchdogEndpointRequestID{typeName: "string", String: value}
}

func (g *GetServicesServiceWatchdogEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetServicesServiceWatchdogEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetServicesServiceWatchdogEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetServicesServiceWatchdogEndpointRequestID) Accept(visitor GetServicesServiceWatchdogEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetServicesServiceWatchdogEndpointResponse struct {
	Data *GetServicesServiceWatchdogEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesServiceWatchdogEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesServiceWatchdogEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesServiceWatchdogEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesServiceWatchdogEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesServiceWatchdogEndpointResponseData struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	ID      *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesServiceWatchdogEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesServiceWatchdogEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesServiceWatchdogEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesServiceWatchdogEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesServiceWatchdogsEndpointRequestSortFlags string

const (
	GetServicesServiceWatchdogsEndpointRequestSortFlagsSortRegular      GetServicesServiceWatchdogsEndpointRequestSortFlags = "SORT_REGULAR"
	GetServicesServiceWatchdogsEndpointRequestSortFlagsSortNumeric      GetServicesServiceWatchdogsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetServicesServiceWatchdogsEndpointRequestSortFlagsSortString       GetServicesServiceWatchdogsEndpointRequestSortFlags = "SORT_STRING"
	GetServicesServiceWatchdogsEndpointRequestSortFlagsSortLocaleString GetServicesServiceWatchdogsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetServicesServiceWatchdogsEndpointRequestSortFlagsSortNatural      GetServicesServiceWatchdogsEndpointRequestSortFlags = "SORT_NATURAL"
	GetServicesServiceWatchdogsEndpointRequestSortFlagsSortFlagCase     GetServicesServiceWatchdogsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetServicesServiceWatchdogsEndpointRequestSortFlagsFromString(s string) (GetServicesServiceWatchdogsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetServicesServiceWatchdogsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetServicesServiceWatchdogsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetServicesServiceWatchdogsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetServicesServiceWatchdogsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetServicesServiceWatchdogsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetServicesServiceWatchdogsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetServicesServiceWatchdogsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesServiceWatchdogsEndpointRequestSortFlags) Ptr() *GetServicesServiceWatchdogsEndpointRequestSortFlags {
	return &g
}

type GetServicesServiceWatchdogsEndpointRequestSortOrder string

const (
	GetServicesServiceWatchdogsEndpointRequestSortOrderSortAsc  GetServicesServiceWatchdogsEndpointRequestSortOrder = "SORT_ASC"
	GetServicesServiceWatchdogsEndpointRequestSortOrderSortDesc GetServicesServiceWatchdogsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetServicesServiceWatchdogsEndpointRequestSortOrderFromString(s string) (GetServicesServiceWatchdogsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetServicesServiceWatchdogsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetServicesServiceWatchdogsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetServicesServiceWatchdogsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetServicesServiceWatchdogsEndpointRequestSortOrder) Ptr() *GetServicesServiceWatchdogsEndpointRequestSortOrder {
	return &g
}

type GetServicesServiceWatchdogsEndpointResponse struct {
	Data []*GetServicesServiceWatchdogsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesServiceWatchdogsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesServiceWatchdogsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesServiceWatchdogsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesServiceWatchdogsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesServiceWatchdogsEndpointResponseDataItem struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	ID      *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesServiceWatchdogsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesServiceWatchdogsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesServiceWatchdogsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesServiceWatchdogsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetServicesSSHEndpointResponse struct {
	Data *SSH `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetServicesSSHEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetServicesSSHEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetServicesSSHEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetServicesSSHEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PatchServicesAcmeAccountKeyEndpointResponse struct {
	Data *PatchServicesAcmeAccountKeyEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeAccountKeyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeAccountKeyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeAccountKeyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeAccountKeyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeAccountKeyEndpointResponseData struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeAccountKeyEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeAccountKeyEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeAccountKeyEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeAccountKeyEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeCertificateActionEndpointResponse struct {
	Data *PatchServicesAcmeCertificateActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeCertificateActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeCertificateActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeCertificateActionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeCertificateActionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeCertificateActionEndpointResponseData struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method   *AcmeCertificateActionMethod `json:"method,omitempty"`
	ParentID *int                         `json:"parent_id,omitempty"`
	ID       *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeCertificateActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeCertificateActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeCertificateActionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeCertificateActionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeCertificateDomainEndpointResponse struct {
	Data *PatchServicesAcmeCertificateDomainEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeCertificateDomainEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeCertificateDomainEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeCertificateDomainEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeCertificateDomainEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeCertificateDomainEndpointResponseData struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`
	ParentID              *int  `json:"parent_id,omitempty"`
	ID                    *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeCertificateDomainEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeCertificateDomainEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeCertificateDomainEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeCertificateDomainEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeCertificateEndpointResponse struct {
	Data *PatchServicesAcmeCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeCertificateEndpointResponseData struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesAcmeSettingsEndpointResponse struct {
	Data *AcmeSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesAcmeSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesAcmeSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesAcmeSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesAcmeSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindAccessListEndpointResponse struct {
	Data *PatchServicesBindAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindAccessListEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindAccessListEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindAccessListEndpointResponseData struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	ID      *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindAccessListEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindAccessListEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindAccessListEntryEndpointResponse struct {
	Data *PatchServicesBindAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindAccessListEntryEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindAccessListEntryEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindAccessListEntryEndpointResponseData struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindAccessListEntryEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindAccessListEntryEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindSettingsEndpointResponse struct {
	Data *BindSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindSyncRemoteHostEndpointResponse struct {
	Data *PatchServicesBindSyncRemoteHostEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindSyncRemoteHostEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindSyncRemoteHostEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindSyncRemoteHostEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindSyncRemoteHostEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindSyncRemoteHostEndpointResponseData struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindSyncRemoteHostEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindSyncRemoteHostEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindSyncRemoteHostEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindSyncRemoteHostEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindSyncSettingsEndpointResponse struct {
	Data *BindSyncSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindSyncSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindSyncSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindSyncSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindSyncSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindViewEndpointResponse struct {
	Data *PatchServicesBindViewEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindViewEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindViewEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindViewEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindViewEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindViewEndpointResponseData struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	ID                *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindViewEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindViewEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindViewEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindViewEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindZoneEndpointResponse struct {
	Data *PatchServicesBindZoneEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindZoneEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindZoneEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindZoneEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindZoneEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindZoneEndpointResponseData struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	ID      *int                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindZoneEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindZoneEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindZoneEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindZoneEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindZoneRecordEndpointResponse struct {
	Data *PatchServicesBindZoneRecordEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindZoneRecordEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindZoneRecordEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindZoneRecordEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindZoneRecordEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesBindZoneRecordEndpointResponseData struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesBindZoneRecordEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesBindZoneRecordEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesBindZoneRecordEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesBindZoneRecordEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesCronJobEndpointResponse struct {
	Data *PatchServicesCronJobEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesCronJobEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesCronJobEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesCronJobEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesCronJobEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesCronJobEndpointResponseData struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesCronJobEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesCronJobEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesCronJobEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesCronJobEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpRelayEndpointResponse struct {
	Data *DhcpRelay `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpRelayEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpRelayEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpRelayEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpRelayEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerAddressPoolEndpointResponse struct {
	Data *PatchServicesDhcpServerAddressPoolEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerAddressPoolEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerAddressPoolEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerAddressPoolEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerAddressPoolEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerAddressPoolEndpointResponseData struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	ParentID    *string                           `json:"parent_id,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerAddressPoolEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerAddressPoolEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerAddressPoolEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerAddressPoolEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerBackendEndpointResponse struct {
	Data *DhcpServerBackend `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerBackendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerBackendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerBackendEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerBackendEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerCustomOptionEndpointResponse struct {
	Data *PatchServicesDhcpServerCustomOptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerCustomOptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerCustomOptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerCustomOptionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerCustomOptionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerCustomOptionEndpointResponseData struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value    *string `json:"value,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerCustomOptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerCustomOptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerCustomOptionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerCustomOptionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerEndpointResponse struct {
	Data *PatchServicesDhcpServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerEndpointResponseData struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
	ID        *string                    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerStaticMappingEndpointResponse struct {
	Data *PatchServicesDhcpServerStaticMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerStaticMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerStaticMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerStaticMappingEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerStaticMappingEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDhcpServerStaticMappingEndpointResponseData struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDhcpServerStaticMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDhcpServerStaticMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDhcpServerStaticMappingEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDhcpServerStaticMappingEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSForwarderHostOverrideAliasEndpointResponse struct {
	Data *PatchServicesDNSForwarderHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSForwarderHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSForwarderHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSForwarderHostOverrideAliasEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSForwarderHostOverrideAliasEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSForwarderHostOverrideAliasEndpointResponseData struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSForwarderHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSForwarderHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSForwarderHostOverrideAliasEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSForwarderHostOverrideAliasEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSForwarderHostOverrideEndpointResponse struct {
	Data *PatchServicesDNSForwarderHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSForwarderHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSForwarderHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSForwarderHostOverrideEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSForwarderHostOverrideEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSForwarderHostOverrideEndpointResponseData struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSForwarderHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSForwarderHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSForwarderHostOverrideEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSForwarderHostOverrideEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverAccessListEndpointResponse struct {
	Data *PatchServicesDNSResolverAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverAccessListEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverAccessListEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverAccessListEndpointResponseData struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	ID       *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverAccessListEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverAccessListEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverAccessListNetworkEndpointResponse struct {
	Data *PatchServicesDNSResolverAccessListNetworkEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverAccessListNetworkEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverAccessListNetworkEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverAccessListNetworkEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverAccessListNetworkEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverAccessListNetworkEndpointResponseData struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverAccessListNetworkEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverAccessListNetworkEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverAccessListNetworkEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverAccessListNetworkEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverDomainOverrideEndpointResponse struct {
	Data *PatchServicesDNSResolverDomainOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverDomainOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverDomainOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverDomainOverrideEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverDomainOverrideEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverDomainOverrideEndpointResponseData struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverDomainOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverDomainOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverDomainOverrideEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverDomainOverrideEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverHostOverrideAliasEndpointResponse struct {
	Data *PatchServicesDNSResolverHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverHostOverrideAliasEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverHostOverrideAliasEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverHostOverrideAliasEndpointResponseData struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverHostOverrideAliasEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverHostOverrideAliasEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverHostOverrideEndpointResponse struct {
	Data *PatchServicesDNSResolverHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverHostOverrideEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverHostOverrideEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverHostOverrideEndpointResponseData struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverHostOverrideEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverHostOverrideEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesDNSResolverSettingsEndpointResponse struct {
	Data *DNSResolverSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesDNSResolverSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesDNSResolverSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesDNSResolverSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesDNSResolverSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesFreeRadiusClientEndpointResponse struct {
	Data *PatchServicesFreeRadiusClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesFreeRadiusClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesFreeRadiusClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesFreeRadiusClientEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesFreeRadiusClientEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesFreeRadiusClientEndpointResponseData struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesFreeRadiusClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesFreeRadiusClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesFreeRadiusClientEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesFreeRadiusClientEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesFreeRadiusInterfaceEndpointResponse struct {
	Data *PatchServicesFreeRadiusInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesFreeRadiusInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesFreeRadiusInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesFreeRadiusInterfaceEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesFreeRadiusInterfaceEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesFreeRadiusInterfaceEndpointResponseData struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesFreeRadiusInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesFreeRadiusInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesFreeRadiusInterfaceEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesFreeRadiusInterfaceEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesFreeRadiusUserEndpointResponse struct {
	Data *PatchServicesFreeRadiusUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesFreeRadiusUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesFreeRadiusUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesFreeRadiusUserEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesFreeRadiusUserEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesFreeRadiusUserEndpointResponseData struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesFreeRadiusUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesFreeRadiusUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesFreeRadiusUserEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesFreeRadiusUserEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendACLEndpointResponse struct {
	Data *PatchServicesHaProxyBackendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendACLEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendACLEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendACLEndpointResponseData struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendACLEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendACLEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendActionEndpointResponse struct {
	Data *PatchServicesHaProxyBackendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendActionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendActionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendActionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendActionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendEndpointResponse struct {
	Data *PatchServicesHaProxyBackendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendEndpointResponseData struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendErrorFileEndpointResponse struct {
	Data *PatchServicesHaProxyBackendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendErrorFileEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendErrorFileEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendErrorFileEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendErrorFileEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendServerEndpointResponse struct {
	Data *PatchServicesHaProxyBackendServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyBackendServerEndpointResponseData struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyBackendServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyBackendServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyBackendServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyBackendServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFileEndpointResponse struct {
	Data *PatchServicesHaProxyFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFileEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFileEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFileEndpointResponseData struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFileEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFileEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendACLEndpointResponse struct {
	Data *PatchServicesHaProxyFrontendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendACLEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendACLEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendACLEndpointResponseData struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendACLEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendACLEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendActionEndpointResponse struct {
	Data *PatchServicesHaProxyFrontendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendActionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendActionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendActionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendActionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendAddressEndpointResponse struct {
	Data *PatchServicesHaProxyFrontendAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendAddressEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendAddressEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendAddressEndpointResponseData struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendAddressEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendAddressEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendCertificateEndpointResponse struct {
	Data *PatchServicesHaProxyFrontendCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendCertificateEndpointResponseData struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendEndpointResponse struct {
	Data *PatchServicesHaProxyFrontendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendEndpointResponseData struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	ID             *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendErrorFileEndpointResponse struct {
	Data *PatchServicesHaProxyFrontendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendErrorFileEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendErrorFileEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxyFrontendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxyFrontendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxyFrontendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxyFrontendErrorFileEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxyFrontendErrorFileEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxySettingsDNSResolverEndpointResponse struct {
	Data *PatchServicesHaProxySettingsDNSResolverEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxySettingsDNSResolverEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxySettingsDNSResolverEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxySettingsDNSResolverEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxySettingsDNSResolverEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxySettingsDNSResolverEndpointResponseData struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port     *string `json:"port,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxySettingsDNSResolverEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxySettingsDNSResolverEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxySettingsDNSResolverEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxySettingsDNSResolverEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxySettingsEmailMailerEndpointResponse struct {
	Data *PatchServicesHaProxySettingsEmailMailerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxySettingsEmailMailerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxySettingsEmailMailerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxySettingsEmailMailerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxySettingsEmailMailerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxySettingsEmailMailerEndpointResponseData struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxySettingsEmailMailerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxySettingsEmailMailerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxySettingsEmailMailerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxySettingsEmailMailerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesHaProxySettingsEndpointResponse struct {
	Data *HaProxySettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesHaProxySettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesHaProxySettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesHaProxySettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesHaProxySettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesNtpSettingsEndpointResponse struct {
	Data *NtpSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesNtpSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesNtpSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesNtpSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesNtpSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesNtpTimeServerEndpointResponse struct {
	Data *PatchServicesNtpTimeServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesNtpTimeServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesNtpTimeServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesNtpTimeServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesNtpTimeServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesNtpTimeServerEndpointResponseData struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesNtpTimeServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesNtpTimeServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesNtpTimeServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesNtpTimeServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesServiceWatchdogEndpointResponse struct {
	Data *PatchServicesServiceWatchdogEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesServiceWatchdogEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesServiceWatchdogEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesServiceWatchdogEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesServiceWatchdogEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesServiceWatchdogEndpointResponseData struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	ID      *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesServiceWatchdogEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesServiceWatchdogEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesServiceWatchdogEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesServiceWatchdogEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchServicesSSHEndpointResponse struct {
	Data *SSH `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchServicesSSHEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchServicesSSHEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchServicesSSHEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchServicesSSHEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeAccountKeyEndpointResponse struct {
	Data *PostServicesAcmeAccountKeyEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeAccountKeyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeAccountKeyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeAccountKeyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeAccountKeyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeAccountKeyEndpointResponseData struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeAccountKeyEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeAccountKeyEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeAccountKeyEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeAccountKeyEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeAccountKeyRegisterEndpointResponse struct {
	Data *PostServicesAcmeAccountKeyRegisterEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeAccountKeyRegisterEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeAccountKeyRegisterEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeAccountKeyRegisterEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeAccountKeyRegisterEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeAccountKeyRegisterEndpointResponseData struct {
	// The name of the ACME account key to register.<br>
	Name *string `json:"name,omitempty"`
	// The registration status of the ACME account key. This will show 'pending' if the registration process is still running, 'registered' if the registration was successful, 'failed' if the registration failed, and 'unknown' if the registration status is not known. Note: This status can only be determined for registrations initiated through the REST API.<br>
	Status *string `json:"status,omitempty"`
	ID     *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeAccountKeyRegisterEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeAccountKeyRegisterEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeAccountKeyRegisterEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeAccountKeyRegisterEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateActionEndpointResponse struct {
	Data *PostServicesAcmeCertificateActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateActionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateActionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateActionEndpointResponseData struct {
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateActionStatus `json:"status,omitempty"`
	// The command to execute on the ACME certificate.<br>
	Command *string `json:"command,omitempty"`
	// The action method that should be used to run the command.<br>
	Method   *AcmeCertificateActionMethod `json:"method,omitempty"`
	ParentID *int                         `json:"parent_id,omitempty"`
	ID       *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateActionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateActionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateDomainEndpointResponse struct {
	Data *PostServicesAcmeCertificateDomainEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateDomainEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateDomainEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateDomainEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateDomainEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateDomainEndpointResponseData struct {
	// The fully-qualified domain name of this domain (SAN).<br>
	Name *string `json:"name,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateDomainStatus `json:"status,omitempty"`
	// The method to use to validate this domain.<br>
	Method *string `json:"method,omitempty"`
	// Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webroot'`<br>
	Webrootfolder *string `json:"webrootfolder,omitempty"`
	// Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpftpserver *string `json:"webrootftpftpserver,omitempty"`
	// Username for the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpusername *string `json:"webrootftpusername,omitempty"`
	// Password to authenticate this user on the remote server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftppassword *string `json:"webrootftppassword,omitempty"`
	// Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'webrootftp'`<br>
	Webrootftpfolder *string `json:"webrootftpfolder,omitempty"`
	// HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneport *string `json:"standaloneport,omitempty"`
	// Bind to IPv6 instead of IPv4.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalone'`<br>
	Standaloneipv6 *bool `json:"standaloneipv6,omitempty"`
	// TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'standalonetls'`<br>
	Standalonetlsport *string `json:"standalonetlsport,omitempty"`
	// The DNS server to which updates are sent (IP address or hostname)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateServer *string `json:"nsupdate_server,omitempty"`
	// (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyname *string `json:"nsupdate_keyname,omitempty"`
	// Algorithm used to generate the authentication Key for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKeyalgo *AcmeCertificateDomainNsupdateKeyalgo `json:"nsupdate_keyalgo,omitempty"`
	// The key which authenticates updates for this zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateKey *string `json:"nsupdate_key,omitempty"`
	// (Optional) Explicitly set the zone name for updates.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsupdate'`<br>
	NsupdateZone *string `json:"nsupdate_zone,omitempty"`
	// 1984Hosting Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingUsername *string `json:"one984hosting_username,omitempty"`
	// 1984Hosting Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_1984hosting'`<br>
	One984HostingPassword *string `json:"one984hosting_password,omitempty"`
	// Acmeproxy Endpoint URL (https://ip:port)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyEndpoint *string `json:"acmeproxy_endpoint,omitempty"`
	// Acmeproxy Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyUsername *string `json:"acmeproxy_username,omitempty"`
	// Acmeproxy Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmeproxy'`<br>
	AcmeproxyPassword *string `json:"acmeproxy_password,omitempty"`
	// acme-dns.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUsername *string `json:"acmedns_username,omitempty"`
	// acme-dns.io Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsPassword *string `json:"acmedns_password,omitempty"`
	// acme-dns.io subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsSubdomain *string `json:"acmedns_subdomain,omitempty"`
	// (optional) Custom ACME DNS Base URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_acmedns'`<br>
	AcmednsUpdateURL *string `json:"acmedns_update_url,omitempty"`
	// Active24 Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_active24'`<br>
	Active24Token *string `json:"active24_token,omitempty"`
	// Hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiHost *string `json:"akamai_host,omitempty"`
	// Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiAccessToken *string `json:"akamai_access_token,omitempty"`
	// Client Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientToken *string `json:"akamai_client_token,omitempty"`
	// Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_edgedns'`<br>
	AkamaiClientSecret *string `json:"akamai_client_secret,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliKey *string `json:"ali_key,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ali'`<br>
	AliSecret *string `json:"ali_secret,omitempty"`
	// Login<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasLogin *string `json:"kas_login,omitempty"`
	// Auth type (default: sha1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthtype *string `json:"kas_authtype,omitempty"`
	// Auth data<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kas'`<br>
	KasAuthdata *string `json:"kas_authdata,omitempty"`
	// Alwaysdata API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ad'`<br>
	AdAPIKey *string `json:"ad_api_key,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_anx'`<br>
	AnxToken *string `json:"anx_token,omitempty"`
	// ArtFiles Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIUsername *string `json:"af_api_username,omitempty"`
	// ArtFiles Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_artfiles'`<br>
	AfAPIPassword *string `json:"af_api_password,omitempty"`
	// Arvan API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_arvan'`<br>
	ArvanToken *string `json:"arvan_token,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraKey *string `json:"aurora_key,omitempty"`
	// API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aurora'`<br>
	AuroraSecret *string `json:"aurora_secret,omitempty"`
	// autoDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsUser *string `json:"autodns_user,omitempty"`
	// autoDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsPassword *string `json:"autodns_password,omitempty"`
	// autoDNS Context<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_autodns'`<br>
	AutodnsContext *string `json:"autodns_context,omitempty"`
	// AWS Access Key / API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsAccessKeyID *string `json:"aws_access_key_id,omitempty"`
	// AWS Secret Access / API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsSecretAccessKey *string `json:"aws_secret_access_key,omitempty"`
	// Sleep interval after TXT record update, in seconds (default: 1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_aws'`<br>
	AwsDNSSlowrate *string `json:"aws_dns_slowrate,omitempty"`
	// Account e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionEmail *string `json:"azion_email,omitempty"`
	// Account password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azion'`<br>
	AzionPassword *string `json:"azion_password,omitempty"`
	// Azure Subscription ID. First, <a href="https://github.com/acmesh-official/acme.sh/wiki/How-to-use-Azure-DNS">setup a service principal for access to the DNS Zone</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsSubscriptionid *string `json:"azuredns_subscriptionid,omitempty"`
	// Azure Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsTenantid *string `json:"azuredns_tenantid,omitempty"`
	// Azure App ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsAppid *string `json:"azuredns_appid,omitempty"`
	// Azure Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_azure'`<br>
	AzurednsClientsecret *string `json:"azuredns_clientsecret,omitempty"`
	// BookMyName Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynameUsername *string `json:"bookmyname_username,omitempty"`
	// BookMyName Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bookmyname'`<br>
	BookmynamePassword *string `json:"bookmyname_password,omitempty"`
	// Bunny DNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_bunny'`<br>
	BunnyAPIKey *string `json:"bunny_api_key,omitempty"`
	// CloudDNS e-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsEmail *string `json:"clouddns_email,omitempty"`
	// CloudDNS client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsClientID *string `json:"clouddns_client_id,omitempty"`
	// CloudDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_clouddns'`<br>
	ClouddnsPassword *string `json:"clouddns_password,omitempty"`
	// Authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthID *string `json:"cloudns_auth_id,omitempty"`
	// Sub authentication ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsSubAuthID *string `json:"cloudns_sub_auth_id,omitempty"`
	// ClouDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cloudns'`<br>
	CloudnsAuthPassword *string `json:"cloudns_auth_password,omitempty"`
	// Cloudflare API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfKey *string `json:"cf_key,omitempty"`
	// Cloudflare API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfEmail *string `json:"cf_email,omitempty"`
	// Cloudflare API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfToken *string `json:"cf_token,omitempty"`
	// Cloudflare API Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfAccountID *string `json:"cf_account_id,omitempty"`
	// Cloudflare API Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cf'`<br>
	CfZoneID *string `json:"cf_zone_id,omitempty"`
	// Conoha Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaUsername *string `json:"conoha_username,omitempty"`
	// Conoha Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaPassword *string `json:"conoha_password,omitempty"`
	// Conoha Tenant ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaTenantid *string `json:"conoha_tenantid,omitempty"`
	// Conoha Identity Service API<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_conoha'`<br>
	ConohaIdentityserviceapi *string `json:"conoha_identityserviceapi,omitempty"`
	// Constellix Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixKey *string `json:"constellix_key,omitempty"`
	// Constellix Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_constellix'`<br>
	ConstellixSecret *string `json:"constellix_secret,omitempty"`
	// cPanel username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelUsername *string `json:"cpanel_username,omitempty"`
	// cPanel API token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelApitoken *string `json:"cpanel_apitoken,omitempty"`
	// URL to cPanel instance<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cpanel'`<br>
	CpanelHostname *string `json:"cpanel_hostname,omitempty"`
	// Core Networks Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnUser *string `json:"cn_user,omitempty"`
	// Core Networks Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cn'`<br>
	CnPassword *string `json:"cn_password,omitempty"`
	// Authentication Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthclientid *string `json:"curanet_authclientid,omitempty"`
	// Authentication Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_curanet'`<br>
	CuranetAuthsecret *string `json:"curanet_authsecret,omitempty"`
	// CY username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyUsername *string `json:"cy_username,omitempty"`
	// CY Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_cyon'`<br>
	CyPassword *string `json:"cy_password,omitempty"`
	// API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ddnss'`<br>
	DdnssToken *string `json:"ddnss_token,omitempty"`
	// deSEC.io API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynToken *string `json:"dedyn_token,omitempty"`
	// deSEC.io Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_desec'`<br>
	DedynName *string `json:"dedyn_name,omitempty"`
	// DigitalOcean API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dgon'`<br>
	DoAPIKey *string `json:"do_api_key,omitempty"`
	// DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPI *string `json:"da_api,omitempty"`
	// DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always accept<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_da'`<br>
	DaAPIInsecure *string `json:"da_api_insecure,omitempty"`
	// DNSExit API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAPIKey *string `json:"dnsexit_api_key,omitempty"`
	// DNSExit Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthUser *string `json:"dnsexit_auth_user,omitempty"`
	// DNSExit Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsexit'`<br>
	DnsexitAuthPass *string `json:"dnsexit_auth_pass,omitempty"`
	// Subdomain<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomain *string `json:"dnshome_subdomain,omitempty"`
	// Subdomain Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnshome'`<br>
	DnshomeSubdomainpassword *string `json:"dnshome_subdomainpassword,omitempty"`
	// DNSimple oauth token, visit <a href="https://dnsimple.com/user">https://dnsimple.com/user</a> to generate.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsimple'`<br>
	DnsimpleOauthToken *string `json:"dnsimple_oauth_token,omitempty"`
	// DNSMadeEasy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeKey *string `json:"me_key,omitempty"`
	// DNSMadeEasy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_me'`<br>
	MeSecret *string `json:"me_secret,omitempty"`
	// dns.services Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesUsername *string `json:"dnsservices_username,omitempty"`
	// dns.services Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dnsservices'`<br>
	DnsservicesPassword *string `json:"dnsservices_password,omitempty"`
	// DO.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_doapi'`<br>
	DoLetoken *string `json:"do_letoken,omitempty"`
	// DO Customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPid *string `json:"do_pid,omitempty"`
	// DO Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_do'`<br>
	DoPw *string `json:"do_pw,omitempty"`
	// Domeneshop API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopToken *string `json:"domeneshop_token,omitempty"`
	// Domeneshop API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_domeneshop'`<br>
	DomeneshopSecret *string `json:"domeneshop_secret,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpID *string `json:"dp_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dp'`<br>
	DpKey *string `json:"dp_key,omitempty"`
	// Dnspod API ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiID *string `json:"dpi_id,omitempty"`
	// Dnspod API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dpi'`<br>
	DpiKey *string `json:"dpi_key,omitempty"`
	// Dreamhost API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dreamhost'`<br>
	DhAPIKey *string `json:"dh_api_key,omitempty"`
	// DuckDNS API Token (Look in DuckDNS account settings)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_duckdns'`<br>
	DuckdnsToken *string `json:"duckdns_token,omitempty"`
	// DurableDNS API User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIUser *string `json:"dd_api_user,omitempty"`
	// DurableDNS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_durabledns'`<br>
	DdAPIKey *string `json:"dd_api_key,omitempty"`
	// dyn.com customer ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynCustomer *string `json:"dyn_customer,omitempty"`
	// dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynUsername *string `json:"dyn_username,omitempty"`
	// dyn.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dyn'`<br>
	DynPassword *string `json:"dyn_password,omitempty"`
	// dyndnsfree.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfUser *string `json:"df_user,omitempty"`
	// dyndnsfree.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_df'`<br>
	DfPassword *string `json:"df_password,omitempty"`
	// Dynu API Client ID created in the Dynu account settings<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuClientid *string `json:"dynu_clientid,omitempty"`
	// Dynu API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_dynu'`<br>
	DynuSecret *string `json:"dynu_secret,omitempty"`
	// easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.php<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsKey *string `json:"easydns_key,omitempty"`
	// easyDNS API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_easydns'`<br>
	EasydnsToken *string `json:"easydns_token,omitempty"`
	// Euserv.eu Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservUsername *string `json:"euserv_username,omitempty"`
	// Euserv.eu Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_euserv'`<br>
	EuservPassword *string `json:"euserv_password,omitempty"`
	// Exoscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleAPIKey *string `json:"exoscale_api_key,omitempty"`
	// Exoscale Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_exoscale'`<br>
	ExoscaleSecretKey *string `json:"exoscale_secret_key,omitempty"`
	// Fornex API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_fornex'`<br>
	FornexAPIKey *string `json:"fornex_api_key,omitempty"`
	// FreeDNS username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsUser *string `json:"freedns_user,omitempty"`
	// FreeDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_freedns'`<br>
	FreednsPassword *string `json:"freedns_password,omitempty"`
	// Gandi LiveDNS API Key, retrieved from <a href="https://account.gandi.net">https://account.gandi.net</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gandi_livedns'`<br>
	GandiLivednsKey *string `json:"gandi_livedns_key,omitempty"`
	// Gcore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gcore'`<br>
	GcoreKey *string `json:"gcore_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingUsername *string `json:"geoscaling_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_geoscaling'`<br>
	GeoscalingPassword *string `json:"geoscaling_password,omitempty"`
	// GoDaddy API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdKey *string `json:"gd_key,omitempty"`
	// GoDaddy API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_gd'`<br>
	GdSecret *string `json:"gd_secret,omitempty"`
	// Google Domains API Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsAccessToken *string `json:"googledomains_access_token,omitempty"`
	// Google Domains DNS Zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_googledomains'`<br>
	GoogledomainsZone *string `json:"googledomains_zone,omitempty"`
	// Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hetzner'`<br>
	HetznerToken *string `json:"hetzner_token,omitempty"`
	// Hexonet Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetLogin *string `json:"hexonet_login,omitempty"`
	// Hexonet Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hexonet'`<br>
	HexonetPassword *string `json:"hexonet_password,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudUsername *string `json:"huaweicloud_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudPassword *string `json:"huaweicloud_password,omitempty"`
	// Domain Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_huaweicloud'`<br>
	HuaweicloudDomainname *string `json:"huaweicloud_domainname,omitempty"`
	// Hurricane Electric username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HeUsername *string `json:"he_username,omitempty"`
	// Hurricane Electric password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_he'`<br>
	HePassword *string `json:"he_password,omitempty"`
	// Hosting.de API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeApikey *string `json:"hostingde_apikey,omitempty"`
	// Hosting.de API endpoint, e.g. https://secure.hosting.de<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_hostingde'`<br>
	HostingdeEndpoint *string `json:"hostingde_endpoint,omitempty"`
	// Infoblox credentials in <strong>username:password</strong> format<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxCreds *string `json:"infoblox_creds,omitempty"`
	// Infoblox server IP address or hostname<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxServer *string `json:"infoblox_server,omitempty"`
	// Infoblox DNS View name, or enter "default"<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infoblox'`<br>
	InfobloxView *string `json:"infoblox_view,omitempty"`
	// Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakAPIToken *string `json:"infomaniak_api_token,omitempty"`
	// Infomaniak API URL (Default: https://api.infomaniak.com)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	DefaultInfomaniakApiUrl *string `json:"default_infomaniak_api_url,omitempty"`
	// Infomaniak DNS record TTL (Default: 300)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_infomaniak'`<br>
	InfomaniakTTL *string `json:"infomaniak_ttl,omitempty"`
	// Prefix<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosPrefix *string `json:"ionos_prefix,omitempty"`
	// Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ionos'`<br>
	IonosSecret *string `json:"ionos_secret,omitempty"`
	// IPv64.net Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ipv64'`<br>
	Ipv64Token *string `json:"ipv64_token,omitempty"`
	// Internet.BS API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIKey *string `json:"internetbs_api_key,omitempty"`
	// Internet.BS API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_internetbs'`<br>
	InternetbsAPIPassword *string `json:"internetbs_api_password,omitempty"`
	// INWX.de username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxUsername *string `json:"inwx_username,omitempty"`
	// INWX.de password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxPassword *string `json:"inwx_password,omitempty"`
	// INWX.de shared secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_inwx'`<br>
	InwxSharedSecret *string `json:"inwx_shared_secret,omitempty"`
	// ISPConfig remoteUser<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcUser *string `json:"ispc_user,omitempty"`
	// ISPConfig remotePassword<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcPassword *string `json:"ispc_password,omitempty"`
	// API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPI *string `json:"ispc_api,omitempty"`
	// Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ispconfig'`<br>
	IspcAPIInsecure *string `json:"ispc_api_insecure,omitempty"`
	// jdcloud Access Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeyID *string `json:"jd_access_key_id,omitempty"`
	// jdcloud Access Key Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdAccessKeySecret *string `json:"jd_access_key_secret,omitempty"`
	// jdcloud Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_jd'`<br>
	JdRegion *string `json:"jd_region,omitempty"`
	// Joker.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerUsername *string `json:"joker_username,omitempty"`
	// Joker.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_joker'`<br>
	JokerPassword *string `json:"joker_password,omitempty"`
	// kapper.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsKey *string `json:"kappernetdns_key,omitempty"`
	// kapper.net API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kappernet'`<br>
	KappernetdnsSecret *string `json:"kappernetdns_secret,omitempty"`
	// Kinghost API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostUsername *string `json:"kinghost_username,omitempty"`
	// Kinghost API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_kinghost'`<br>
	KinghostPassword *string `json:"kinghost_password,omitempty"`
	// IP address of the Knot server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotServer *string `json:"knot_server,omitempty"`
	// Knot TSIG Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_knot'`<br>
	KnotKey *string `json:"knot_key,omitempty"`
	// ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaID *string `json:"la_id,omitempty"`
	// Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_la'`<br>
	LaKey *string `json:"la_key,omitempty"`
	// Leaseweb API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_leaseweb'`<br>
	LswKey *string `json:"lsw_key,omitempty"`
	// API Key must have the following roles: dns.admin, domains.reader<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_limacity'`<br>
	LimacityApikey *string `json:"limacity_apikey,omitempty"`
	// Linode API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode'`<br>
	LinodeAPIKey *string `json:"linode_api_key,omitempty"`
	// Linode v4 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_linode_v4'`<br>
	LinodeV4APIKey *string `json:"linode_v4_api_key,omitempty"`
	// Loopia username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaUser *string `json:"loopia_user,omitempty"`
	// Loopia Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_loopia'`<br>
	LoopiaPassword *string `json:"loopia_password,omitempty"`
	// Luadns API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaKey *string `json:"lua_key,omitempty"`
	// Luadns API Email Address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_lua'`<br>
	LuaEmail *string `json:"lua_email,omitempty"`
	// MailinaBox Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabUsername *string `json:"miab_username,omitempty"`
	// MailinaBox Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabPassword *string `json:"miab_password,omitempty"`
	// MailinaBox Server<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_miab'`<br>
	MiabServer *string `json:"miab_server,omitempty"`
	// misaka.io Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_misaka'`<br>
	MisakaKey *string `json:"misaka_key,omitempty"`
	// MyDNS.jp Master ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpMasterid *string `json:"mydnsjp_masterid,omitempty"`
	// MyDNS.jp Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mydnsjp'`<br>
	MydnsjpPassword *string `json:"mydnsjp_password,omitempty"`
	// OAuth2 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAk *string `json:"mb_ak,omitempty"`
	// OAuth2 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_mythic_beasts'`<br>
	MbAs *string `json:"mb_as,omitempty"`
	// Name.com username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomUsername *string `json:"namecom_username,omitempty"`
	// Name.com API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecom'`<br>
	NamecomToken *string `json:"namecom_token,omitempty"`
	// Namecheap API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapAPIKey *string `json:"namecheap_api_key,omitempty"`
	// Namecheap Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namecheap'`<br>
	NamecheapUsername *string `json:"namecheap_username,omitempty"`
	// namemaster.de API username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmUser *string `json:"nm_user,omitempty"`
	// namemaster.de API password as SHA256 hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nm'`<br>
	NmSha256 *string `json:"nm_sha256,omitempty"`
	// Nanelo.com Access Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nanelo'`<br>
	NaneloToken *string `json:"nanelo_token,omitempty"`
	// NederHost API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nederhost'`<br>
	NederhostKey *string `json:"nederhost_key,omitempty"`
	// Namesilo API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_namesilo'`<br>
	NamesiloKey *string `json:"namesilo_key,omitempty"`
	// Neodigit API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_neodigit'`<br>
	NeodigitAPIToken *string `json:"neodigit_api_token,omitempty"`
	// Netcup API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApikey *string `json:"nc_apikey,omitempty"`
	// Netcup API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcApipw *string `json:"nc_apipw,omitempty"`
	// Netcup Customer ID/Number<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netcup'`<br>
	NcCid *string `json:"nc_cid,omitempty"`
	// Netlify API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_netlify'`<br>
	NetlifyAccessToken *string `json:"netlify_access_token,omitempty"`
	// nic.ru API Client ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientid *string `json:"nic_clientid,omitempty"`
	// nic.ru API Client Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicClientsecret *string `json:"nic_clientsecret,omitempty"`
	// nic.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicUsername *string `json:"nic_username,omitempty"`
	// nic.ru Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nic'`<br>
	NicPassword *string `json:"nic_password,omitempty"`
	// NS1 API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nsone'`<br>
	Ns1Key *string `json:"ns1_key,omitempty"`
	// NW API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIToken *string `json:"nw_api_token,omitempty"`
	// Choose the NW API Endpoint<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_nw'`<br>
	NwAPIEndpoint *AcmeCertificateDomainNwAPIEndpoint `json:"nw_api_endpoint,omitempty"`
	// One.com Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomUser *string `json:"onecom_user,omitempty"`
	// One.com Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_one'`<br>
	OnecomPassword *string `json:"onecom_password,omitempty"`
	// Online.net API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_online'`<br>
	OnlineAPIKey *string `json:"online_api_key,omitempty"`
	// OCID of tenancy that contains the target DNS zone<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliTenancy *string `json:"oci_cli_tenancy,omitempty"`
	// OCID of user with permission to add/remove records from zones<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliUser *string `json:"oci_cli_user,omitempty"`
	// Tenancy home region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliRegion *string `json:"oci_cli_region,omitempty"`
	// The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_oci'`<br>
	OciCliKey *string `json:"oci_cli_key,omitempty"`
	// OpenProvider Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderUser *string `json:"openprovider_user,omitempty"`
	// OpenProvider Password Hash<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_openprovider'`<br>
	OpenproviderPasswordhash *string `json:"openprovider_passwordhash,omitempty"`
	// OVH Application Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAk *string `json:"ovh_ak,omitempty"`
	// OVH Application Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhAs *string `json:"ovh_as,omitempty"`
	// OVH Consumer Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhCk *string `json:"ovh_ck,omitempty"`
	// Choose the OVH API Endpoint / Region<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ovh'`<br>
	OvhEndPoint *AcmeCertificateDomainOvhEndPoint `json:"ovh_end_point,omitempty"`
	// Plesk User<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlUser *string `json:"pleskxml_user,omitempty"`
	// Plesk Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlPass *string `json:"pleskxml_pass,omitempty"`
	// Plesk Server URI<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pleskxml'`<br>
	PleskxmlURI *string `json:"pleskxml_uri,omitempty"`
	// PointHQ API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqKey *string `json:"pointhq_key,omitempty"`
	// PointHQ account E-mail address<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pointhq'`<br>
	PointhqEmail *string `json:"pointhq_email,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunAPIKey *string `json:"porkbun_api_key,omitempty"`
	// Secret API Key. Obtain the key and secret from https://porkbun.com/account/api<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_porkbun'`<br>
	PorkbunSecretAPIKey *string `json:"porkbun_secret_api_key,omitempty"`
	// PowerDNS URL (e.g. http://ns.example.com:8081 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsURL *string `json:"pdns_url,omitempty"`
	// PowerDNS ServerId (e.g. localhost )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsServerid *string `json:"pdns_serverid,omitempty"`
	// PowerDNS Token (e.g. 0123456789ABCDEF )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsToken *string `json:"pdns_token,omitempty"`
	// PowerDNS Record TTL (e.g. 60 )<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_pdns'`<br>
	PdnsTTL *string `json:"pdns_ttl,omitempty"`
	// API UUID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApiuuid *string `json:"rackcorp_apiuuid,omitempty"`
	// API Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackcorp'`<br>
	RackcorpApisecret *string `json:"rackcorp_apisecret,omitempty"`
	// Rackspace Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceUsername *string `json:"rackspace_username,omitempty"`
	// Rackspace API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rackspace'`<br>
	RackspaceApikey *string `json:"rackspace_apikey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Username *string `json:"rage4_username,omitempty"`
	// Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rage4'`<br>
	Rage4Token *string `json:"rage4_token,omitempty"`
	// Rcode0 API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0APIToken *string `json:"rcode0_api_token,omitempty"`
	// Rcode0 URL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0URL *string `json:"rcode0_url,omitempty"`
	// Rcode0 TTL<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_rcode0'`<br>
	Rcode0TTL *string `json:"rcode0_ttl,omitempty"`
	// reg.ru Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIUsername *string `json:"regru_api_username,omitempty"`
	// reg.ru API Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_regru'`<br>
	RegruAPIPassword *string `json:"regru_api_password,omitempty"`
	// API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_scaleway'`<br>
	ScalewayAPIToken *string `json:"scaleway_api_token,omitempty"`
	// schlundtech.de Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechUser *string `json:"schlundtech_user,omitempty"`
	// schlundtech.de Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_schlundtech'`<br>
	SchlundtechPassword *string `json:"schlundtech_password,omitempty"`
	// Selectel API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selectel'`<br>
	SlKey *string `json:"sl_key,omitempty"`
	// Username (Customer number, not email address or DynDNS account)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsUsername *string `json:"selfhostdns_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsPassword *string `json:"selfhostdns_password,omitempty"`
	// Record ID (Edit the record, value is shown in brackets)<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_selfhost'`<br>
	SelfhostdnsMap *string `json:"selfhostdns_map,omitempty"`
	// Servercow username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIUsername *string `json:"servercow_api_username,omitempty"`
	// Servercow password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_servercow'`<br>
	ServercowAPIPassword *string `json:"servercow_api_password,omitempty"`
	// Account Name<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAccountname *string `json:"simply_accountname,omitempty"`
	// API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyApikey *string `json:"simply_apikey,omitempty"`
	// API Endpoint URL. Default: https://api.simply.com/1<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_simply'`<br>
	SimplyAPI *string `json:"simply_api,omitempty"`
	// Tele3 Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Key *string `json:"tele3_key,omitempty"`
	// Tele3 Secret<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tele3'`<br>
	Tele3Secret *string `json:"tele3_secret,omitempty"`
	// Tencent Secret ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretid *string `json:"tencent_secretid,omitempty"`
	// Tencent Secret Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_tencent'`<br>
	TencentSecretkey *string `json:"tencent_secretkey,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrUser *string `json:"udr_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_udr'`<br>
	UdrPass *string `json:"udr_pass,omitempty"`
	// UltraDNS Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraUsr *string `json:"ultra_usr,omitempty"`
	// UltraDNS Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_ultra'`<br>
	UltraPwd *string `json:"ULTRA_PWD,omitempty"`
	// UnoEuro username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoUser *string `json:"uno_user,omitempty"`
	// UnoEuro API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_unoeuro'`<br>
	UnoKey *string `json:"uno_key,omitempty"`
	// variomedia.de API Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_variomedia'`<br>
	VariomediaAPIToken *string `json:"variomedia_api_token,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespUser *string `json:"veesp_user,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_veesp'`<br>
	VeespPassword *string `json:"veesp_password,omitempty"`
	// Vercel Token<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vercel'`<br>
	VercelToken *string `json:"vercel_token,omitempty"`
	// vscale API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vscale'`<br>
	VscaleAPIKey *string `json:"vscale_api_key,omitempty"`
	// vultr.com API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_vultr'`<br>
	VultrAPIKey *string `json:"vultr_api_key,omitempty"`
	// API Key / "Identifier" in the WS Admin<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApikey *string `json:"ws_apikey,omitempty"`
	// API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_websupport'`<br>
	WsApisecret *string `json:"ws_apisecret,omitempty"`
	// West.cn Domain API Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestUsername *string `json:"west_username,omitempty"`
	// West.cn Domain API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_west_cn'`<br>
	WestKey *string `json:"west_key,omitempty"`
	// Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouUsername *string `json:"world4you_username,omitempty"`
	// Password<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_world4you'`<br>
	World4YouPassword *string `json:"world4you_password,omitempty"`
	// Yandex PDD Token, generate at <a href="https://pddimp.yandex.ru/api2/admin/get_token">https://pddimp.yandex.ru/api2/admin/get_token</a><br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yandex'`<br>
	PddToken *string `json:"pdd_token,omitempty"`
	// DNS Zone ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcZoneID *string `json:"yc_zone_id,omitempty"`
	// Yandex Cloud Folder ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcFolderID *string `json:"yc_folder_id,omitempty"`
	// Service Account ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaID *string `json:"yc_sa_id,omitempty"`
	// Service Account IAM Key ID<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyID *string `json:"yc_sa_key_id,omitempty"`
	// Base64 content of private key.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_yc'`<br>
	YcSaKeyFilePemB64 *string `json:"yc_sa_key_file_pem_b64,omitempty"`
	// Zonomi API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zonomi'`<br>
	ZmKey *string `json:"zm_key,omitempty"`
	// Zone.ee Username<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneUsername *string `json:"zone_username,omitempty"`
	// Zone.ee API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zone'`<br>
	ZoneKey *string `json:"zone_key,omitempty"`
	// Zilore API Key<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'dns_zilore'`<br>
	ZiloreKey *string `json:"zilore_key,omitempty"`
	// (Optional) Adds the --challenge-alias flag to the acme.sh call.<br/>To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.<br/>More information can be found <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode" target="_new">here</a>.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengealias *string `json:"anydnschallengealias,omitempty"`
	// (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.<br><br>This field is only available when the following conditions are met:<br>- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]<br>
	Anydnschallengedomain *bool `json:"anydnschallengedomain,omitempty"`
	ParentID              *int  `json:"parent_id,omitempty"`
	ID                    *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateDomainEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateDomainEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateDomainEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateDomainEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateEndpointResponse struct {
	Data *PostServicesAcmeCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateEndpointResponseData struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateIssueEndpointResponse struct {
	Data *PostServicesAcmeCertificateIssueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateIssueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateIssueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateIssueEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateIssueEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateIssueEndpointResponseData struct {
	// The name of the ACME certificate to be issued.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate issue process. This will show 'pending' if the issue process is still running or 'completed' if the issue process has finished. This status only indicates whether the issue process has completed, not whether it was successful. You will needto refer to the result log for that information.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate issue status last changed.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh issue command.<br>
	ResultLog *string `json:"result_log,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateIssueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateIssueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateIssueEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateIssueEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateRenewEndpointResponse struct {
	Data *PostServicesAcmeCertificateRenewEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateRenewEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateRenewEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateRenewEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateRenewEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesAcmeCertificateRenewEndpointResponseData struct {
	// The name of the ACME certificate to be renewed.<br>
	Certificate *string `json:"certificate,omitempty"`
	// The status of the ACME certificate renew process. This will show 'pending' if the renew process is still running or 'completed' if the renew process has finished. This status only indicates whether the renew process has completed, not whether it was successful. You will needto refer to the result log for that information. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	Status *string `json:"status,omitempty"`
	// The unix timestamp of when the ACME certificate renew status last changed. Note: This timestamp is only updated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	LastUpdated *int `json:"last_updated,omitempty"`
	// The output result of the acme.sh renew command. Note: This log is only populated when the renew process is initiated via REST API, not when it is initiated via the pfSense webConfigurator or auto-renewals.<br>
	ResultLog *string `json:"result_log,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesAcmeCertificateRenewEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesAcmeCertificateRenewEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesAcmeCertificateRenewEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesAcmeCertificateRenewEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindAccessListEndpointResponse struct {
	Data *PostServicesBindAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindAccessListEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindAccessListEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindAccessListEndpointResponseData struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	ID      *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindAccessListEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindAccessListEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindAccessListEntryEndpointResponse struct {
	Data *PostServicesBindAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindAccessListEntryEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindAccessListEntryEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindAccessListEntryEndpointResponseData struct {
	// The network CIDR to allow.<br>
	Value *string `json:"value,omitempty"`
	// A description of the access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindAccessListEntryEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindAccessListEntryEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindSyncRemoteHostEndpointResponse struct {
	Data *PostServicesBindSyncRemoteHostEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindSyncRemoteHostEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindSyncRemoteHostEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindSyncRemoteHostEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindSyncRemoteHostEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindSyncRemoteHostEndpointResponseData struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindSyncRemoteHostEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindSyncRemoteHostEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindSyncRemoteHostEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindSyncRemoteHostEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindViewEndpointResponse struct {
	Data *PostServicesBindViewEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindViewEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindViewEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindViewEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindViewEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindViewEndpointResponseData struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	ID                *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindViewEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindViewEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindViewEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindViewEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindZoneEndpointResponse struct {
	Data *PostServicesBindZoneEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindZoneEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindZoneEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindZoneEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindZoneEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindZoneEndpointResponseData struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	ID      *int                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindZoneEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindZoneEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindZoneEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindZoneEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindZoneRecordEndpointResponse struct {
	Data *PostServicesBindZoneRecordEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindZoneRecordEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindZoneRecordEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindZoneRecordEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindZoneRecordEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesBindZoneRecordEndpointResponseData struct {
	// The domain name for this record.<br>
	Name *string `json:"name,omitempty"`
	// The type of record.<br>
	Type *BindZoneRecordType `json:"type,omitempty"`
	// The data for this record. This can be an IP address, domain name, or other data depending on the record type.<br>
	Rdata *string `json:"rdata,omitempty"`
	// The priority for this record.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ MX, SRV ]<br>
	Priority *int `json:"priority,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesBindZoneRecordEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesBindZoneRecordEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesBindZoneRecordEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesBindZoneRecordEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesCronJobEndpointResponse struct {
	Data *PostServicesCronJobEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesCronJobEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesCronJobEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesCronJobEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesCronJobEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesCronJobEndpointResponseData struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesCronJobEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesCronJobEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesCronJobEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesCronJobEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerAddressPoolEndpointResponse struct {
	Data *PostServicesDhcpServerAddressPoolEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerAddressPoolEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerAddressPoolEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerAddressPoolEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerAddressPoolEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerAddressPoolEndpointResponseData struct {
	// The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerAddressPoolDenyunknown `json:"denyunknown,omitempty"`
	ParentID    *string                           `json:"parent_id,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerAddressPoolEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerAddressPoolEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerAddressPoolEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerAddressPoolEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerApplyEndpointResponse struct {
	Data *DhcpServerApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerCustomOptionEndpointResponse struct {
	Data *PostServicesDhcpServerCustomOptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerCustomOptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerCustomOptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerCustomOptionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerCustomOptionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerCustomOptionEndpointResponseData struct {
	// The DHCP option number to configure.<br>
	Number *int `json:"number,omitempty"`
	// The type of value to configure for the option.<br>
	Type *DhcpServerCustomOptionType `json:"type,omitempty"`
	// The value to configure for the option.<br>
	Value    *string `json:"value,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerCustomOptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerCustomOptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerCustomOptionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerCustomOptionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerEndpointResponse struct {
	Data *PostServicesDhcpServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerEndpointResponseData struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
	ID        *string                    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerStaticMappingEndpointResponse struct {
	Data *PostServicesDhcpServerStaticMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerStaticMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerStaticMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerStaticMappingEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerStaticMappingEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDhcpServerStaticMappingEndpointResponseData struct {
	// The MAC address of the client this mapping is for.<br>
	Mac *string `json:"mac,omitempty"`
	// The IP address to assign this client via DHCP.<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// The client identifier of the client this mapping is for.<br>
	Cid *string `json:"cid,omitempty"`
	// The hostname to assign this client via DHCP.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) this client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign a static ARP entry for this static mapping.<br>
	ArpTableStaticEntry *bool `json:"arp_table_static_entry,omitempty"`
	// The description of this static mapping.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *string `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDhcpServerStaticMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDhcpServerStaticMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDhcpServerStaticMappingEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDhcpServerStaticMappingEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSForwarderApplyEndpointResponse struct {
	Data *DNSForwarderApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSForwarderApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSForwarderApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSForwarderApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSForwarderApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSForwarderHostOverrideAliasEndpointResponse struct {
	Data *PostServicesDNSForwarderHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSForwarderHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSForwarderHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSForwarderHostOverrideAliasEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSForwarderHostOverrideAliasEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSForwarderHostOverrideAliasEndpointResponseData struct {
	// The hostname of this override alias.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// The description of this override alias.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSForwarderHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSForwarderHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSForwarderHostOverrideAliasEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSForwarderHostOverrideAliasEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSForwarderHostOverrideEndpointResponse struct {
	Data *PostServicesDNSForwarderHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSForwarderHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSForwarderHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSForwarderHostOverrideEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSForwarderHostOverrideEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSForwarderHostOverrideEndpointResponseData struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSForwarderHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSForwarderHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSForwarderHostOverrideEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSForwarderHostOverrideEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverAccessListEndpointResponse struct {
	Data *PostServicesDNSResolverAccessListEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverAccessListEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverAccessListEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverAccessListEndpointResponseData struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	ID       *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverAccessListEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverAccessListEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverAccessListEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverAccessListEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverAccessListNetworkEndpointResponse struct {
	Data *PostServicesDNSResolverAccessListNetworkEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverAccessListNetworkEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverAccessListNetworkEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverAccessListNetworkEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverAccessListNetworkEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverAccessListNetworkEndpointResponseData struct {
	// The network address of this access list entry.<br>
	Network *string `json:"network,omitempty"`
	// The subnet mask of this access list entry's network.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this access list entry.<br>
	Description *string `json:"description,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverAccessListNetworkEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverAccessListNetworkEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverAccessListNetworkEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverAccessListNetworkEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverApplyEndpointResponse struct {
	Data *DNSResolverApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverDomainOverrideEndpointResponse struct {
	Data *PostServicesDNSResolverDomainOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverDomainOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverDomainOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverDomainOverrideEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverDomainOverrideEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverDomainOverrideEndpointResponseData struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverDomainOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverDomainOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverDomainOverrideEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverDomainOverrideEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverHostOverrideAliasEndpointResponse struct {
	Data *PostServicesDNSResolverHostOverrideAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverHostOverrideAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverHostOverrideAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverHostOverrideAliasEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverHostOverrideAliasEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverHostOverrideAliasEndpointResponseData struct {
	// The hostname portion of the host override alias.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override alias.<br>
	Domain *string `json:"domain,omitempty"`
	// A detailed description for this host override alias.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverHostOverrideAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverHostOverrideAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverHostOverrideAliasEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverHostOverrideAliasEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverHostOverrideEndpointResponse struct {
	Data *PostServicesDNSResolverHostOverrideEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverHostOverrideEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverHostOverrideEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverHostOverrideEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverHostOverrideEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesDNSResolverHostOverrideEndpointResponseData struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesDNSResolverHostOverrideEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesDNSResolverHostOverrideEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesDNSResolverHostOverrideEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesDNSResolverHostOverrideEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesFreeRadiusClientEndpointResponse struct {
	Data *PostServicesFreeRadiusClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesFreeRadiusClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesFreeRadiusClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesFreeRadiusClientEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesFreeRadiusClientEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesFreeRadiusClientEndpointResponseData struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesFreeRadiusClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesFreeRadiusClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesFreeRadiusClientEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesFreeRadiusClientEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesFreeRadiusInterfaceEndpointResponse struct {
	Data *PostServicesFreeRadiusInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesFreeRadiusInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesFreeRadiusInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesFreeRadiusInterfaceEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesFreeRadiusInterfaceEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesFreeRadiusInterfaceEndpointResponseData struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesFreeRadiusInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesFreeRadiusInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesFreeRadiusInterfaceEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesFreeRadiusInterfaceEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesFreeRadiusUserEndpointResponse struct {
	Data *PostServicesFreeRadiusUserEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesFreeRadiusUserEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesFreeRadiusUserEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesFreeRadiusUserEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesFreeRadiusUserEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesFreeRadiusUserEndpointResponseData struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesFreeRadiusUserEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesFreeRadiusUserEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesFreeRadiusUserEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesFreeRadiusUserEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyApplyEndpointResponse struct {
	Data *HaProxyApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendACLEndpointResponse struct {
	Data *PostServicesHaProxyBackendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendACLEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendACLEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendACLEndpointResponseData struct {
	// The unique name for this backend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyBackendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendACLEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendACLEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendActionEndpointResponse struct {
	Data *PostServicesHaProxyBackendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendActionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendActionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyBackendActionAction `json:"action,omitempty"`
	// The name of the backend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend server to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_server'`<br>
	Server *string `json:"server,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendActionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendActionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendEndpointResponse struct {
	Data *PostServicesHaProxyBackendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendEndpointResponseData struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendErrorFileEndpointResponse struct {
	Data *PostServicesHaProxyBackendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendErrorFileEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendErrorFileEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendErrorFileEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendErrorFileEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendServerEndpointResponse struct {
	Data *PostServicesHaProxyBackendServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyBackendServerEndpointResponseData struct {
	// The unique name for this backend server.<br>
	Name *string `json:"name,omitempty"`
	// The eligibility status for this backend server.<br>
	Status *HaProxyBackendServerStatus `json:"status,omitempty"`
	// The hostname or IP address of this backend server. Hostname values are only resolved at service startup.<br>
	Address *string `json:"address,omitempty"`
	// The port to forward to for this backend server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The weight of this backend server when load balancing.<br>
	Weight *int `json:"weight,omitempty"`
	// Enables or disables using SSL/TLS when forwarding to this backend server.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.<br>
	Sslserververify *bool `json:"sslserververify,omitempty"`
	// The unique ID for this backend server. This value is set by the system for internal use and cannot be changed.<br>
	Serverid *int `json:"serverid,omitempty"`
	// Allows adding custom HAProxy server settings to the server.<br>
	Advanced *string `json:"advanced,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyBackendServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyBackendServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyBackendServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyBackendServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFileEndpointResponse struct {
	Data *PostServicesHaProxyFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFileEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFileEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFileEndpointResponseData struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFileEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFileEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendACLEndpointResponse struct {
	Data *PostServicesHaProxyFrontendACLEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendACLEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendACLEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendACLEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendACLEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendACLEndpointResponseData struct {
	// The unique name for this frontend ACL.<br>
	Name *string `json:"name,omitempty"`
	// The expression to use to determine the match for this ACL.<br>
	Expression *HaProxyFrontendACLExpression `json:"expression,omitempty"`
	// The value which indicates a match for this ACL.<br>
	Value *string `json:"value,omitempty"`
	// Enables or disables case-sensitive matching for this ACL.<br>
	Casesensitive *bool `json:"casesensitive,omitempty"`
	// Enables or disables inverting the context of this ACL.<br>
	Not      *bool `json:"not,omitempty"`
	ParentID *int  `json:"parent_id,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendACLEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendACLEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendACLEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendACLEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendActionEndpointResponse struct {
	Data *PostServicesHaProxyFrontendActionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendActionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendActionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendActionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendActionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendActionEndpointResponseData struct {
	// The action to take when an ACL match is found.<br>
	Action *HaProxyFrontendActionAction `json:"action,omitempty"`
	// The name of the frontend ACL this action is associated with.<br>
	ACL *string `json:"acl,omitempty"`
	// The backend to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'use_backend'`<br>
	Backend *string `json:"backend,omitempty"`
	// The custom action to take when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'custom'`<br>
	Customaction *string `json:"customaction,omitempty"`
	// The deny status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_deny, http-request_tarpit ]<br>
	DenyStatus *string `json:"deny_status,omitempty"`
	// The authentication realm to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_auth'`<br>
	Realm *string `json:"realm,omitempty"`
	// The redirect rule to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_redirect'`<br>
	Rule *string `json:"rule,omitempty"`
	// The Lua function to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]<br>
	LuaFunction *string `json:"lua_function,omitempty"`
	// The name to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Name *string `json:"name,omitempty"`
	// The fmt value to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]<br>
	Fmt *string `json:"fmt,omitempty"`
	// The value to find when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Find *string `json:"find,omitempty"`
	// The value to replace with when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]<br>
	Replace *string `json:"replace,omitempty"`
	// The path to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be equal to `'http-request_replace-path'`<br>
	Path *string `json:"path,omitempty"`
	// The status to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Status *string `json:"status,omitempty"`
	// The status reason to use when an ACL match is found.<br><br>This field is only available when the following conditions are met:<br>- `action` must be one of [ http-response_set-status, http-after-response_set-status ]<br>
	Reason   *string `json:"reason,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendActionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendActionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendActionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendActionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendAddressEndpointResponse struct {
	Data *PostServicesHaProxyFrontendAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendAddressEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendAddressEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendAddressEndpointResponseData struct {
	// The external address to use.<br>
	Extaddr *HaProxyFrontendAddressExtaddr `json:"extaddr,omitempty"`
	// The custom IPv4 or IPv6 address to use as the external address.<br><br>This field is only available when the following conditions are met:<br>- `extaddr` must be equal to `'custom'`<br>
	ExtaddrCustom *string `json:"extaddr_custom,omitempty"`
	// The port to bind to for this address. Valid options are: a TCP/UDP port number<br>
	ExtaddrPort *string `json:"extaddr_port,omitempty"`
	// Enables or disables using SSL/TLS for this address.<br>
	ExtaddrSsl *bool `json:"extaddr_ssl,omitempty"`
	// The advanced configuration to apply to this address.<br>
	ExaddrAdvanced *string `json:"exaddr_advanced,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendAddressEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendAddressEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendCertificateEndpointResponse struct {
	Data *PostServicesHaProxyFrontendCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendCertificateEndpointResponseData struct {
	// The SSL/TLS certificate refid to add to this frontend.<br>
	SslCertificate *string `json:"ssl_certificate,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendEndpointResponse struct {
	Data *PostServicesHaProxyFrontendEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendEndpointResponseData struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	ID             *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendErrorFileEndpointResponse struct {
	Data *PostServicesHaProxyFrontendErrorFileEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendErrorFileEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendErrorFileEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendErrorFileEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendErrorFileEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxyFrontendErrorFileEndpointResponseData struct {
	// The HTTP status code that will trigger this error file to be used.<br>
	Errorcode *int `json:"errorcode,omitempty"`
	// The HAProxy error file object that should be used for the assigned HTTP status code.<br>
	Errorfile *string `json:"errorfile,omitempty"`
	ParentID  *int    `json:"parent_id,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxyFrontendErrorFileEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxyFrontendErrorFileEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxyFrontendErrorFileEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxyFrontendErrorFileEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxySettingsDNSResolverEndpointResponse struct {
	Data *PostServicesHaProxySettingsDNSResolverEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxySettingsDNSResolverEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxySettingsDNSResolverEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxySettingsDNSResolverEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxySettingsDNSResolverEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxySettingsDNSResolverEndpointResponseData struct {
	// The descriptive name for this DNS server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the DNS server.<br>
	Server *string `json:"server,omitempty"`
	// The port used by this DNS server. Valid options are: a TCP/UDP port number<br>
	Port     *string `json:"port,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxySettingsDNSResolverEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxySettingsDNSResolverEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxySettingsDNSResolverEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxySettingsDNSResolverEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxySettingsEmailMailerEndpointResponse struct {
	Data *PostServicesHaProxySettingsEmailMailerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxySettingsEmailMailerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxySettingsEmailMailerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxySettingsEmailMailerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxySettingsEmailMailerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesHaProxySettingsEmailMailerEndpointResponseData struct {
	// The descriptive name for this mail server.<br>
	Name *string `json:"name,omitempty"`
	// The IP or hostname of the mail server.<br>
	Mailserver *string `json:"mailserver,omitempty"`
	// The port used by this mail server. Valid options are: a TCP/UDP port number<br>
	Mailserverport *string `json:"mailserverport,omitempty"`
	ParentID       *int    `json:"parent_id,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesHaProxySettingsEmailMailerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesHaProxySettingsEmailMailerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesHaProxySettingsEmailMailerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesHaProxySettingsEmailMailerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesNtpTimeServerEndpointResponse struct {
	Data *PostServicesNtpTimeServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesNtpTimeServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesNtpTimeServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesNtpTimeServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesNtpTimeServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesNtpTimeServerEndpointResponseData struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesNtpTimeServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesNtpTimeServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesNtpTimeServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesNtpTimeServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesServiceWatchdogEndpointResponse struct {
	Data *PostServicesServiceWatchdogEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesServiceWatchdogEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesServiceWatchdogEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesServiceWatchdogEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesServiceWatchdogEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesServiceWatchdogEndpointResponseData struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	ID      *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesServiceWatchdogEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesServiceWatchdogEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesServiceWatchdogEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesServiceWatchdogEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostServicesWakeOnLanSendEndpointResponse struct {
	Data *WakeOnLanSend `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostServicesWakeOnLanSendEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostServicesWakeOnLanSendEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostServicesWakeOnLanSendEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostServicesWakeOnLanSendEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesAcmeAccountKeysEndpointRequestItem struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesAcmeAccountKeysEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesAcmeAccountKeysEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesAcmeAccountKeysEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesAcmeAccountKeysEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesAcmeAccountKeysEndpointResponse struct {
	Data []*PutServicesAcmeAccountKeysEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesAcmeAccountKeysEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesAcmeAccountKeysEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesAcmeAccountKeysEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesAcmeAccountKeysEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesAcmeAccountKeysEndpointResponseDataItem struct {
	// The name of the ACME account key.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME account key.<br>
	Descr *string `json:"descr,omitempty"`
	// The email address associated with the ACME account key.<br>
	Email *string `json:"email,omitempty"`
	// The ACME server this account key will belong to.<br>
	Acmeserver *string `json:"acmeserver,omitempty"`
	// The RSA private key for the ACME account key.<br>
	Accountkey *string `json:"accountkey,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesAcmeAccountKeysEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesAcmeAccountKeysEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesAcmeAccountKeysEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesAcmeAccountKeysEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesAcmeCertificatesEndpointRequestItem struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesAcmeCertificatesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesAcmeCertificatesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesAcmeCertificatesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesAcmeCertificatesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesAcmeCertificatesEndpointResponse struct {
	Data []*PutServicesAcmeCertificatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesAcmeCertificatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesAcmeCertificatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesAcmeCertificatesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesAcmeCertificatesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesAcmeCertificatesEndpointResponseDataItem struct {
	// The name of the ACME certificate.<br>
	Name *string `json:"name,omitempty"`
	// A description of the ACME certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status of the ACME certificate.<br>
	Status *AcmeCertificateStatus `json:"status,omitempty"`
	// The ACME account key to use for the ACME certificate.<br>
	Acmeaccount *string `json:"acmeaccount,omitempty"`
	// The length of the private key to use for the ACME certificate.<br>
	Keylength *AcmeCertificateKeylength `json:"keylength,omitempty"`
	// The custom private key to use for the ACME certificate.<br><br>This field is only available when the following conditions are met:<br>- `keylength` must be equal to `'custom'`<br>
	Keypaste *string `json:"keypaste,omitempty"`
	// The preferred certificate chain to use for the ACME certificate.<br>
	Preferredchain *string `json:"preferredchain,omitempty"`
	// Whether to enable OCSP Stapling for the ACME certificate.<br>
	Oscpstaple *bool `json:"oscpstaple,omitempty"`
	// The number of seconds to wait for DNS propagation before requesting verification.<br>
	Dnssleep *int `json:"dnssleep,omitempty"`
	// The number of days before expiration to renew the ACME certificate.<br>
	Renewafter *int `json:"renewafter,omitempty"`
	// The list of domain verifications  to include in the ACME certificate.<br>
	ADomainlist []*AcmeCertificateADomainlistItem `json:"a_domainlist,omitempty"`
	// The list of actions to perform on the ACME certificate after being issued/renewed.<br>
	AActionlist []*AcmeCertificateAActionlistItem `json:"a_actionlist,omitempty"`
	ID          *int                              `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesAcmeCertificatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesAcmeCertificatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesAcmeCertificatesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesAcmeCertificatesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindAccessListsEndpointRequestItem struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindAccessListsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindAccessListsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindAccessListsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindAccessListsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindAccessListsEndpointResponse struct {
	Data []*PutServicesBindAccessListsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindAccessListsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindAccessListsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindAccessListsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindAccessListsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindAccessListsEndpointResponseDataItem struct {
	// The name of the access list.<br>
	Name *string `json:"name,omitempty"`
	// A description for the access list.<br>
	Description *string `json:"description,omitempty"`
	// The network entries for this access list.<br>
	Entries []*BindAccessListEntriesItem `json:"entries,omitempty"`
	ID      *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindAccessListsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindAccessListsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindAccessListsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindAccessListsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindSyncRemoteHostsEndpointRequestItem struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindSyncRemoteHostsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindSyncRemoteHostsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindSyncRemoteHostsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindSyncRemoteHostsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindSyncRemoteHostsEndpointResponse struct {
	Data []*PutServicesBindSyncRemoteHostsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindSyncRemoteHostsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindSyncRemoteHostsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindSyncRemoteHostsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindSyncRemoteHostsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindSyncRemoteHostsEndpointResponseDataItem struct {
	// Enable this remote host for syncing.<br>
	Syncdestinenable *bool `json:"syncdestinenable,omitempty"`
	// The protocol to use for syncing.<br>
	Syncprotocol *BindSyncRemoteHostSyncprotocol `json:"syncprotocol,omitempty"`
	// The IP address/hostname of the remote host.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The remote host port to use for syncing. Valid options are: a TCP/UDP port number<br>
	Syncport *string `json:"syncport,omitempty"`
	// The username to use to authenticate when syncing.<br>
	Username *string `json:"username,omitempty"`
	// The password to use to authenticate when syncing.<br>
	Password *string `json:"password,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindSyncRemoteHostsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindSyncRemoteHostsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindSyncRemoteHostsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindSyncRemoteHostsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindViewsEndpointRequestItem struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindViewsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindViewsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindViewsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindViewsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindViewsEndpointResponse struct {
	Data []*PutServicesBindViewsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindViewsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindViewsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindViewsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindViewsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindViewsEndpointResponseDataItem struct {
	// The name of the view.<br>
	Name *string `json:"name,omitempty"`
	// A description for the view.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables recursion for the view.<br>
	Recursion *bool `json:"recursion,omitempty"`
	// The access lists to match clients against.<br>
	MatchClients []string `json:"match_clients,omitempty"`
	// The access lists to allow recursion for.<br>
	AllowRecursion []string `json:"allow_recursion,omitempty"`
	// Custom BIND options for the view.<br>
	BindCustomOptions *string `json:"bind_custom_options,omitempty"`
	ID                *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindViewsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindViewsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindViewsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindViewsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindZonesEndpointRequestItem struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindZonesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindZonesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindZonesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindZonesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindZonesEndpointResponse struct {
	Data []*PutServicesBindZonesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindZonesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindZonesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindZonesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindZonesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesBindZonesEndpointResponseDataItem struct {
	// Disable this BIND zone.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The name of this BIND zone.<br>
	Name *string `json:"name,omitempty"`
	// A description for this BIND zone.<br>
	Description *string `json:"description,omitempty"`
	// The type of this BIND zone.<br>
	Type *BindZoneType `json:"type,omitempty"`
	// The views this BIND zone belongs to.<br>
	View []string `json:"view,omitempty"`
	// Enable reverse DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev4 *bool `json:"reversev4,omitempty"`
	// Enable reverse IPv6 DNS for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Reversev6 *bool `json:"reversev6,omitempty"`
	// Enable this zone as part of a response policy.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Rpz *bool `json:"rpz,omitempty"`
	// Custom BIND options for this BIND zone.<br>
	Custom *string `json:"custom,omitempty"`
	// Enable DNSSEC for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, slave ]<br>
	Dnssec *bool `json:"dnssec,omitempty"`
	// Enable backing up DNSSEC keys in the XML configuration for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `dnssec` must be equal to `true`<br>
	Backupkeys *bool `json:"backupkeys,omitempty"`
	// The IP address of the slave server for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'slave'`<br>
	Slaveip *string `json:"slaveip,omitempty"`
	// The forwarders for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'forward'`<br>
	Forwarders []string `json:"forwarders,omitempty"`
	// The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	TTL *int `json:"ttl,omitempty"`
	// The IP address of the base domain for this zone. This sets an A record for the base domain.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Baseip *string `json:"baseip,omitempty"`
	// The SOA nameserver for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Nameserver *string `json:"nameserver,omitempty"`
	// The SOA email address (RNAME) for this zone. This must be in an FQDN format.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Mail *string `json:"mail,omitempty"`
	// The SOA serial number for this zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Serial *int `json:"serial,omitempty"`
	// The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Refresh *string `json:"refresh,omitempty"`
	// The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Retry *string `json:"retry,omitempty"`
	// The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Expire *string `json:"expire,omitempty"`
	// The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.<br><br>This field is only available when the following conditions are met:<br>- `type` must be one of [ master, redirect ]<br>
	Minimum *string `json:"minimum,omitempty"`
	// Enable a specific dynamic update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	EnableUpdatepolicy *bool `json:"enable_updatepolicy,omitempty"`
	// The update policy for this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `true`<br>
	Updatepolicy *string `json:"updatepolicy,omitempty"`
	// The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>- `enable_updatepolicy` must be equal to `false`<br>
	Allowupdate []string `json:"allowupdate,omitempty"`
	// The access lists that are allowed to transfer this BIND zone.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'master'`<br>
	Allowtransfer []string `json:"allowtransfer,omitempty"`
	// The access lists that are allowed to query this BIND zone.<br>
	Allowquery []string `json:"allowquery,omitempty"`
	// Register DHCP static mappings as records in this BIND zone.<br>
	Regdhcpstatic *bool `json:"regdhcpstatic,omitempty"`
	// Custom records for this BIND zone.<br>
	Customzonerecords *string `json:"customzonerecords,omitempty"`
	// The records for this BIND zone.<br>
	Records []*BindZoneRecordsItem `json:"records,omitempty"`
	ID      *int                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesBindZonesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesBindZonesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesBindZonesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesBindZonesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesCronJobsEndpointRequestItem struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesCronJobsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesCronJobsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesCronJobsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesCronJobsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesCronJobsEndpointResponse struct {
	Data []*PutServicesCronJobsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesCronJobsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesCronJobsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesCronJobsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesCronJobsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesCronJobsEndpointResponseDataItem struct {
	// The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.<br>
	Minute *string `json:"minute,omitempty"`
	// The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Hour *string `json:"hour,omitempty"`
	// The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Mday *string `json:"mday,omitempty"`
	// The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Month *string `json:"month,omitempty"`
	// The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).<br><br>This field is only available when the following conditions are met:<br>- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]<br>
	Wday *string `json:"wday,omitempty"`
	// The OS user to use when cron runs the command.<br>
	Who *string `json:"who,omitempty"`
	// The command to run. Use full file paths for this command and include an command parameters.<br>
	Command *string `json:"command,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesCronJobsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesCronJobsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesCronJobsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesCronJobsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDhcpServersEndpointRequestItem struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDhcpServersEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDhcpServersEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDhcpServersEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDhcpServersEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDhcpServersEndpointResponse struct {
	Data []*PutServicesDhcpServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDhcpServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDhcpServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDhcpServersEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDhcpServersEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDhcpServersEndpointResponseDataItem struct {
	// The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>
	Interface *string `json:"interface,omitempty"`
	// Enable the DHCP server for this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>
	RangeFrom *string `json:"range_from,omitempty"`
	// The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>
	RangeTo *string `json:"range_to,omitempty"`
	// The domain to be assigned via DHCP.<br>
	Domain *string `json:"domain,omitempty"`
	// The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>
	FailoverPeerip *string `json:"failover_peerip,omitempty"`
	// MAC addresses this DHCP server is allowed to provide leases for.<br>
	MacAllow []string `json:"mac_allow,omitempty"`
	// MAC addresses this DHCP server is not allowed to provide leases for.<br>
	MacDeny []string `json:"mac_deny,omitempty"`
	// The domain search list to provide via DHCP.<br>
	Domainsearchlist []string `json:"domainsearchlist,omitempty"`
	// The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>
	Defaultleasetime *int `json:"defaultleasetime,omitempty"`
	// The maximum DHCP lease validity period (in seconds) a client can request.<br>
	Maxleasetime *int `json:"maxleasetime,omitempty"`
	// The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
	// The WINS servers to provide via DHCP.<br>
	Winsserver []string `json:"winsserver,omitempty"`
	// The NTP servers to provide via DHCP.<br>
	Ntpserver []string `json:"ntpserver,omitempty"`
	// Assign static ARP entries for DHCP leases provided by this server.<br>
	Staticarp *bool `json:"staticarp,omitempty"`
	// Force this DHCP server to ignore BOOTP queries.<br>
	Ignorebootp *bool `json:"ignorebootp,omitempty"`
	// Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>
	Ignoreclientuids *bool `json:"ignoreclientuids,omitempty"`
	// Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>
	Nonak *bool `json:"nonak,omitempty"`
	// Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>
	Disablepingcheck *bool `json:"disablepingcheck,omitempty"`
	// Display the DHCP lease times in local time instead of UTC.<br>
	Dhcpleaseinlocaltime *bool `json:"dhcpleaseinlocaltime,omitempty"`
	// Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>
	Statsgraph *bool `json:"statsgraph,omitempty"`
	// Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>
	Denyunknown *DhcpServerDenyunknown `json:"denyunknown,omitempty"`
	// Additional address pools applied to this DHCP server.<br>
	Pool []*DhcpServerPoolItem `json:"pool,omitempty"`
	// The custom DHCP options to apply to this DHCP server.<br>
	Numberoptions []*DhcpServerNumberoptionsItem `json:"numberoptions,omitempty"`
	// Static mappings applied to this DHCP server.<br>
	Staticmap []*DhcpServerStaticmapItem `json:"staticmap,omitempty"`
	ID        *string                    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDhcpServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDhcpServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDhcpServersEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDhcpServersEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSForwarderHostOverridesEndpointRequestItem struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSForwarderHostOverridesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSForwarderHostOverridesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSForwarderHostOverridesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSForwarderHostOverridesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSForwarderHostOverridesEndpointResponse struct {
	Data []*PutServicesDNSForwarderHostOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSForwarderHostOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSForwarderHostOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSForwarderHostOverridesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSForwarderHostOverridesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSForwarderHostOverridesEndpointResponseDataItem struct {
	// The hostname of this override.<br>
	Host *string `json:"host,omitempty"`
	// The domain of this override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address of this override.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this override.<br>
	Descr *string `json:"descr,omitempty"`
	// The aliases for this override.<br>
	Aliases []*DNSForwarderHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                   `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSForwarderHostOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSForwarderHostOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSForwarderHostOverridesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSForwarderHostOverridesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverAccessListsEndpointRequestItem struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverAccessListsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverAccessListsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverAccessListsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverAccessListsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverAccessListsEndpointResponse struct {
	Data []*PutServicesDNSResolverAccessListsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverAccessListsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverAccessListsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverAccessListsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverAccessListsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverAccessListsEndpointResponseDataItem struct {
	// The name of this access list.<br>
	Name *string `json:"name,omitempty"`
	// The action to take when an access list match is found.<br>
	Action *DNSResolverAccessListAction `json:"action,omitempty"`
	// A description for this access list.<br>
	Description *string `json:"description,omitempty"`
	// The DNS Resolver access list network entries to include in this access list.<br>
	Networks []*DNSResolverAccessListNetworksItem `json:"networks,omitempty"`
	ID       *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverAccessListsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverAccessListsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverAccessListsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverAccessListsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverDomainOverridesEndpointRequestItem struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverDomainOverridesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverDomainOverridesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverDomainOverridesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverDomainOverridesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverDomainOverridesEndpointResponse struct {
	Data []*PutServicesDNSResolverDomainOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverDomainOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverDomainOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverDomainOverridesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverDomainOverridesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverDomainOverridesEndpointResponseDataItem struct {
	// The domain to override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP address to which the domain should resolve.<br>
	IP *string `json:"ip,omitempty"`
	// The description for this domain override.<br>
	Descr *string `json:"descr,omitempty"`
	// Enables or disables forwarding DNS queries to the upstream DNS server using TLS.<br>
	ForwardTLSUpstream *bool `json:"forward_tls_upstream,omitempty"`
	// The hostname to use for the TLS connection to the upstream DNS server.<br><br>This field is only available when the following conditions are met:<br>- `forward_tls_upstream` must be equal to `true`<br>
	TLSHostname *string `json:"tls_hostname,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverDomainOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverDomainOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverDomainOverridesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverDomainOverridesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverHostOverridesEndpointRequestItem struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverHostOverridesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverHostOverridesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverHostOverridesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverHostOverridesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverHostOverridesEndpointResponse struct {
	Data []*PutServicesDNSResolverHostOverridesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverHostOverridesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverHostOverridesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverHostOverridesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverHostOverridesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesDNSResolverHostOverridesEndpointResponseDataItem struct {
	// The hostname portion of the host override.<br>
	Host *string `json:"host,omitempty"`
	// The hostname portion of the host override.<br>
	Domain *string `json:"domain,omitempty"`
	// The IP addresses this host override will resolve.<br>
	IP []string `json:"ip,omitempty"`
	// A detailed description for this host override.<br>
	Descr *string `json:"descr,omitempty"`
	// Additional alias hostnames that should resolve the same IP(s).<br>
	Aliases []*DNSResolverHostOverrideAliasesItem `json:"aliases,omitempty"`
	ID      *int                                  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesDNSResolverHostOverridesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesDNSResolverHostOverridesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesDNSResolverHostOverridesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesDNSResolverHostOverridesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusClientsEndpointRequestItem struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusClientsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusClientsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusClientsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusClientsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusClientsEndpointResponse struct {
	Data []*PutServicesFreeRadiusClientsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusClientsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusClientsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusClientsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusClientsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusClientsEndpointResponseDataItem struct {
	// The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)<br>
	Addr *string `json:"addr,omitempty"`
	// The IP version of the this Client.<br>
	IPVersion *FreeRadiusClientIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	// A short name for the client. This is generally the hostname of the NAS.<br>
	Shortname *string `json:"shortname,omitempty"`
	// This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.<br>
	Secret *string `json:"secret,omitempty"`
	// The protocol the client uses.<br>
	Proto *FreeRadiusClientProto `json:"proto,omitempty"`
	// The NAS type of the client. This is used by checkrad.pl for simultaneous use checks.<br>
	Nastype *FreeRadiusClientNastype `json:"nastype,omitempty"`
	// RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.<br>
	Msgauth *bool `json:"msgauth,omitempty"`
	// Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP
	//
	//	connections from a client.<br>
	Maxconn *int `json:"maxconn,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naslogin *string `json:"naslogin,omitempty"`
	// If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.<br>
	Naspassword *string `json:"naspassword,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusClientsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusClientsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusClientsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusClientsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusInterfacesEndpointRequestItem struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusInterfacesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusInterfacesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusInterfacesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusInterfacesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusInterfacesEndpointResponse struct {
	Data []*PutServicesFreeRadiusInterfacesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusInterfacesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusInterfacesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusInterfacesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusInterfacesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusInterfacesEndpointResponseDataItem struct {
	// The IP address of the listening interface. If you choose * then it means all interfaces.<br>
	Addr *string `json:"addr,omitempty"`
	// The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The type of the listening interface: Authentication/Accounting.<br>
	Type *FreeRadiusInterfaceType `json:"type,omitempty"`
	// The IP version of the listening interface.<br>
	IPVersion *FreeRadiusInterfaceIPVersion `json:"ip_version,omitempty"`
	// The description for this interface.<br>
	Description *string `json:"description,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusInterfacesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusInterfacesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusInterfacesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusInterfacesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusUsersEndpointRequestItem struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusUsersEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusUsersEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusUsersEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusUsersEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusUsersEndpointResponse struct {
	Data []*PutServicesFreeRadiusUsersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusUsersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusUsersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusUsersEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusUsersEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesFreeRadiusUsersEndpointResponseDataItem struct {
	// The username for this user.<br>
	Username *string `json:"username,omitempty"`
	// The password for this username.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	Password *string `json:"password,omitempty"`
	// The encryption method for the password.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `false`<br>
	PasswordEncryption *FreeRadiusUserPasswordEncryption `json:"password_encryption,omitempty"`
	// Enable or disable the use of Mobile One-Time Password (MOTP) for this user.<br>
	MotpEnable *bool `json:"motp_enable,omitempty"`
	// The authentication method for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpAuthmethod *FreeRadiusUserMotpAuthmethod `json:"motp_authmethod,omitempty"`
	// The secret for the Mobile One-Time Password (MOTP).<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpSecret *string `json:"motp_secret,omitempty"`
	// The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpPin *string `json:"motp_pin,omitempty"`
	// The timezone offset for this user.<br><br>This field is only available when the following conditions are met:<br>- `motp_enable` must be equal to `true`<br>
	MotpOffset *int `json:"motp_offset,omitempty"`
	// A description for this user.<br>
	Description *string `json:"description,omitempty"`
	// Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.<br>
	FramedIPAddress *string `json:"framed_ip_address,omitempty"`
	// Framed-IP-Netmask MUST be supported by NAS<br>
	FramedIPNetmask *string `json:"framed_ip_netmask,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesFreeRadiusUsersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesFreeRadiusUsersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesFreeRadiusUsersEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesFreeRadiusUsersEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyBackendsEndpointRequestItem struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyBackendsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyBackendsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyBackendsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyBackendsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyBackendsEndpointResponse struct {
	Data []*PutServicesHaProxyBackendsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyBackendsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyBackendsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyBackendsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyBackendsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyBackendsEndpointResponseDataItem struct {
	// The unique name for this backend.<br>
	Name *string `json:"name,omitempty"`
	// The pool of servers this backend will use.<br>
	Servers []*HaProxyBackendServersItem `json:"servers,omitempty"`
	// The load balancing option to use for servers assigned to this backend.<br>
	Balance *HaProxyBackendBalance `json:"balance,omitempty"`
	// The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUrilen *int `json:"balance_urilen,omitempty"`
	// The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUridepth *int `json:"balance_uridepth,omitempty"`
	// Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>
	BalanceUriwhole *bool `json:"balance_uriwhole,omitempty"`
	// The ACLs to apply to this backend.<br>
	ACLs []*HaProxyBackendACLsItem `json:"acls,omitempty"`
	// The actions to apply to this backend.<br>
	Actions []*HaProxyBackendActionsItem `json:"actions,omitempty"`
	// The amount of time (in milliseconds) to wait before giving up on connections.<br>
	ConnectionTimeout *int `json:"connection_timeout,omitempty"`
	// The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>
	ServerTimeout *int `json:"server_timeout,omitempty"`
	// The number of retry attempts to allow after a connection failure to the server.<br>
	Retries *int `json:"retries,omitempty"`
	// The health check method to use when checking the health of backend servers.<br>
	CheckType *HaProxyBackendCheckType `json:"check_type,omitempty"`
	// The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	Checkinter *int `json:"checkinter,omitempty"`
	// Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>
	LogHealthChecks *bool `json:"log_health_checks,omitempty"`
	// The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	HttpcheckMethod *HaProxyBackendHttpcheckMethod `json:"httpcheck_method,omitempty"`
	// The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorURI *string `json:"monitor_uri,omitempty"`
	// The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>
	MonitorHttpversion *string `json:"monitor_httpversion,omitempty"`
	// The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>
	MonitorUsername *string `json:"monitor_username,omitempty"`
	// The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>
	MonitorDomain *string `json:"monitor_domain,omitempty"`
	// Enables or disables using a TCP connection to read an ASCII string of the form.<br>
	AgentChecks *bool `json:"agent_checks,omitempty"`
	// Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentPort *string `json:"agent_port,omitempty"`
	// The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>
	AgentInter *int `json:"agent_inter,omitempty"`
	// Enables or disables cookie based persistence.<br>
	PersistCookieEnabled *bool `json:"persist_cookie_enabled,omitempty"`
	// The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieName *string `json:"persist_cookie_name,omitempty"`
	// The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieMode *HaProxyBackendPersistCookieMode `json:"persist_cookie_mode,omitempty"`
	// Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieCachable *bool `json:"persist_cookie_cachable,omitempty"`
	// Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookiePostonly *bool `json:"persist_cookie_postonly,omitempty"`
	// Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieHttponly *bool `json:"persist_cookie_httponly,omitempty"`
	// Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	PersistCookieSecure *bool `json:"persist_cookie_secure,omitempty"`
	// The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxidle *int `json:"haproxy_cookie_maxidle,omitempty"`
	// The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieMaxlife *int `json:"haproxy_cookie_maxlife,omitempty"`
	// The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDomains []string `json:"haproxy_cookie_domains,omitempty"`
	// The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>
	HaproxyCookieDynamicCookieKey *string `json:"haproxy_cookie_dynamic_cookie_key,omitempty"`
	// The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>
	PersistStickyType *HaProxyBackendPersistStickyType `json:"persist_sticky_type,omitempty"`
	// The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickExpire *string `json:"persist_stick_expire,omitempty"`
	// The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>
	PersistStickTablesize *string `json:"persist_stick_tablesize,omitempty"`
	// The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickCookiename *string `json:"persist_stick_cookiename,omitempty"`
	// The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>
	PersistStickLength *int `json:"persist_stick_length,omitempty"`
	// The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>
	EmailLevel *HaProxyBackendEmailLevel `json:"email_level,omitempty"`
	// The email address to send emails to. If left empty, the value set in the global settings will be used.<br>
	EmailTo *string `json:"email_to,omitempty"`
	// Enables or disables the HAProxy statistics page for this backend.<br>
	StatsEnabled *bool `json:"stats_enabled,omitempty"`
	// The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsURI *string `json:"stats_uri,omitempty"`
	// The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsScope []string `json:"stats_scope,omitempty"`
	// The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRealm *string `json:"stats_realm,omitempty"`
	// The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsUsername *string `json:"stats_username,omitempty"`
	// The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsPassword *string `json:"stats_password,omitempty"`
	// The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsAdmin *string `json:"stats_admin,omitempty"`
	// The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsNode *string `json:"stats_node,omitempty"`
	// The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsDesc *string `json:"stats_desc,omitempty"`
	// The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>
	StatsRefresh *int `json:"stats_refresh,omitempty"`
	// The HSTS validity period for this backend. Leave empty to disable HSTS.<br>
	StrictTransportSecurity *int `json:"strict_transport_security,omitempty"`
	// The HAProxy error file mappings to use for this backend.<br>
	Errorfiles []*HaProxyBackendErrorfilesItem `json:"errorfiles,omitempty"`
	// Enables or disables assigning the secure attributes on cookies for this backend.<br>
	CookieAttributeSecure *bool `json:"cookie_attribute_secure,omitempty"`
	// The per server pass thru to apply to each server line.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The backend pass thru to apply to the backend section.<br>
	AdvancedBackend *string `json:"advanced_backend,omitempty"`
	// Enables or disables using the client-IP to connect to backend servers.<br>
	TransparentClientip *bool `json:"transparent_clientip,omitempty"`
	// The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>
	TransparentInterface *string `json:"transparent_interface,omitempty"`
	ID                   *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyBackendsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyBackendsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyBackendsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyBackendsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyFilesRequestItem struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyFilesRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyFilesRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyFilesRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyFilesRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyFilesResponse struct {
	Data []*PutServicesHaProxyFilesResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyFilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyFilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyFilesResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyFilesResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyFilesResponseDataItem struct {
	// The unique name for this file.<br>
	Name *string `json:"name,omitempty"`
	// The type of file. Use `null` to assume an Errorfile.<br>
	Type *HaProxyFileType `json:"type,omitempty"`
	// The content of this file.<br>
	Content *string `json:"content,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyFilesResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyFilesResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyFilesResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyFilesResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyFrontendsEndpointRequestItem struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyFrontendsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyFrontendsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyFrontendsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyFrontendsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyFrontendsEndpointResponse struct {
	Data []*PutServicesHaProxyFrontendsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyFrontendsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyFrontendsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyFrontendsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyFrontendsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesHaProxyFrontendsEndpointResponseDataItem struct {
	// The unique name for this HAProxy frontend.<br>
	Name *string `json:"name,omitempty"`
	// The description for this HAProxy frontend.<br>
	Descr *string `json:"descr,omitempty"`
	// The activation status for this HAProxy frontend.<br>
	Status *HaProxyFrontendStatus `json:"status,omitempty"`
	// The external addresses assigned to this frontend.<br>
	AExtaddr []*HaProxyFrontendAExtaddrItem `json:"a_extaddr,omitempty"`
	// The maximum number of connections allowed by this frontend.<br>
	MaxConnections *int `json:"max_connections,omitempty"`
	// The processing type for this frontend.<br>
	Type *HaProxyFrontendType `json:"type,omitempty"`
	// The ACLs to apply to this frontend.<br>
	HaACLs []*HaProxyFrontendHaACLsItem `json:"ha_acls,omitempty"`
	// The actions to take when an ACL match is found.<br>
	AActionitems []*HaProxyFrontendAActionitemsItem `json:"a_actionitems,omitempty"`
	// The default backend to use for this frontend.<br>
	BackendServerpool *string `json:"backend_serverpool,omitempty"`
	// Enables or disables collecting and providing separate statistics for each socket.<br>
	SocketStats *bool `json:"socket_stats,omitempty"`
	// Enables or disables logging connections with no data transferred.<br>
	Dontlognull *bool `json:"dontlognull,omitempty"`
	// Enables or disables only logging anomalous (not normal) connection.<br>
	DontlogNormal *bool `json:"dontlog_normal,omitempty"`
	// Enables or disables changing the log level from info to err on potentially interesting info.<br>
	LogSeparateErrors *bool `json:"log_separate_errors,omitempty"`
	// Enables or disables more detailed logging.<br>
	LogDetailed *bool `json:"log_detailed,omitempty"`
	// The custom error files to use for this frontend.<br>
	AErrorfiles []*HaProxyFrontendAErrorfilesItem `json:"a_errorfiles,omitempty"`
	// The amount of time (in milliseconds) to wait for data from the client.<br>
	ClientTimeout *int `json:"client_timeout,omitempty"`
	// Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>
	Forwardfor *bool `json:"forwardfor,omitempty"`
	// The `httpclose` option this frontend will operate.<br>
	Httpclose *HaProxyFrontendHttpclose `json:"httpclose,omitempty"`
	// Custom value to pass behind each bind option.<br>
	AdvancedBind *string `json:"advanced_bind,omitempty"`
	// Custom configuration to pass to this frontend.<br>
	Advanced *string `json:"advanced,omitempty"`
	// The default SSL/TLS certificate refid to use for this frontend.<br>
	Ssloffloadcert *string `json:"ssloffloadcert,omitempty"`
	// The additional SSL/TLS certificates to use on this frontend.<br>
	HaCertificates []*HaProxyFrontendHaCertificatesItem `json:"ha_certificates,omitempty"`
	ID             *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesHaProxyFrontendsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesHaProxyFrontendsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesHaProxyFrontendsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesHaProxyFrontendsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesNtpTimeServersEndpointRequestItem struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesNtpTimeServersEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesNtpTimeServersEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesNtpTimeServersEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesNtpTimeServersEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesNtpTimeServersEndpointResponse struct {
	Data []*PutServicesNtpTimeServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesNtpTimeServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesNtpTimeServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesNtpTimeServersEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesNtpTimeServersEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesNtpTimeServersEndpointResponseDataItem struct {
	// The IP or hostname of the remote NTP time server, pool or peer.<br>
	Timeserver *string `json:"timeserver,omitempty"`
	// The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`.<br>
	Type *NtpTimeServerType `json:"type,omitempty"`
	// Enable NTP favoring the use of this server more than all others.<br>
	Prefer *bool `json:"prefer,omitempty"`
	// Prevent NTP from using this timeserver, but continue collecting stats.<br><br>This field is only available when the following conditions are met:<br>- `type` must not be equal to `'pool'`<br>
	Noselect *bool `json:"noselect,omitempty"`
	ID       *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesNtpTimeServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesNtpTimeServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesNtpTimeServersEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesNtpTimeServersEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesServiceWatchdogsEndpointRequestItem struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesServiceWatchdogsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesServiceWatchdogsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesServiceWatchdogsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesServiceWatchdogsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesServiceWatchdogsEndpointResponse struct {
	Data []*PutServicesServiceWatchdogsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesServiceWatchdogsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesServiceWatchdogsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesServiceWatchdogsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesServiceWatchdogsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutServicesServiceWatchdogsEndpointResponseDataItem struct {
	// The name of the service to be watched.<br>
	Name *string `json:"name,omitempty"`
	// The description for the service being watched.<br>
	Description *string `json:"description,omitempty"`
	// Enable or disable notifications being sent when Service Watchdogs finds this service stopped.<br>
	Notify *bool `json:"notify,omitempty"`
	// Indicates if this Service Watchdog is enabled or disabled. This value is unused.<br>
	Enabled *bool `json:"enabled,omitempty"`
	ID      *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutServicesServiceWatchdogsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutServicesServiceWatchdogsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutServicesServiceWatchdogsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutServicesServiceWatchdogsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
