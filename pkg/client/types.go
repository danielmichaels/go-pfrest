// This file was auto-generated by Fern from our API Definition.

package pfclientapi

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/danielmichaels/go-pfrest/pkg/client/core"
)

type AuthenticationError struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *AuthenticationErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AuthenticationError) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthenticationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthenticationError(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuthenticationError) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type AuthenticationErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewAuthenticationErrorDataFromStringUnknownMapList(value []map[string]interface{}) *AuthenticationErrorData {
	return &AuthenticationErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewAuthenticationErrorDataFromStringUnknownMap(value map[string]interface{}) *AuthenticationErrorData {
	return &AuthenticationErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (a *AuthenticationErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		a.typeName = "stringUnknownMapList"
		a.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		a.typeName = "stringUnknownMap"
		a.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a AuthenticationErrorData) MarshalJSON() ([]byte, error) {
	switch a.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "stringUnknownMapList":
		return json.Marshal(a.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(a.StringUnknownMap)
	}
}

type AuthenticationErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (a *AuthenticationErrorData) Accept(visitor AuthenticationErrorDataVisitor) error {
	switch a.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", a.typeName, a)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(a.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(a.StringUnknownMap)
	}
}

type BadRequestErrorBody struct {
	Data *BadRequestErrorBodyData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BadRequestErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler BadRequestErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BadRequestErrorBody(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BadRequestErrorBody) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BadRequestErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewBadRequestErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *BadRequestErrorBodyData {
	return &BadRequestErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewBadRequestErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *BadRequestErrorBodyData {
	return &BadRequestErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (b *BadRequestErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		b.typeName = "stringUnknownMapList"
		b.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		b.typeName = "stringUnknownMap"
		b.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BadRequestErrorBodyData) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMapList":
		return json.Marshal(b.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(b.StringUnknownMap)
	}
}

type BadRequestErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (b *BadRequestErrorBodyData) Accept(visitor BadRequestErrorBodyDataVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(b.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(b.StringUnknownMap)
	}
}

type ConflictErrorBody struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *ConflictErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConflictErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ConflictErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConflictErrorBody(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConflictErrorBody) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConflictErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewConflictErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *ConflictErrorBodyData {
	return &ConflictErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewConflictErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *ConflictErrorBodyData {
	return &ConflictErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (c *ConflictErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		c.typeName = "stringUnknownMapList"
		c.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		c.typeName = "stringUnknownMap"
		c.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConflictErrorBodyData) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "stringUnknownMapList":
		return json.Marshal(c.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(c.StringUnknownMap)
	}
}

type ConflictErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (c *ConflictErrorBodyData) Accept(visitor ConflictErrorBodyDataVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(c.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(c.StringUnknownMap)
	}
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type ConflictErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewConflictErrorDataFromStringUnknownMapList(value []map[string]interface{}) *ConflictErrorData {
	return &ConflictErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewConflictErrorDataFromStringUnknownMap(value map[string]interface{}) *ConflictErrorData {
	return &ConflictErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (c *ConflictErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		c.typeName = "stringUnknownMapList"
		c.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		c.typeName = "stringUnknownMap"
		c.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConflictErrorData) MarshalJSON() ([]byte, error) {
	switch c.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "stringUnknownMapList":
		return json.Marshal(c.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(c.StringUnknownMap)
	}
}

type ConflictErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (c *ConflictErrorData) Accept(visitor ConflictErrorDataVisitor) error {
	switch c.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", c.typeName, c)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(c.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(c.StringUnknownMap)
	}
}

type FailedDependencyErrorBody struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *FailedDependencyErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FailedDependencyErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler FailedDependencyErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FailedDependencyErrorBody(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FailedDependencyErrorBody) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FailedDependencyErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewFailedDependencyErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *FailedDependencyErrorBodyData {
	return &FailedDependencyErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewFailedDependencyErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *FailedDependencyErrorBodyData {
	return &FailedDependencyErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (f *FailedDependencyErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		f.typeName = "stringUnknownMapList"
		f.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		f.typeName = "stringUnknownMap"
		f.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FailedDependencyErrorBodyData) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return json.Marshal(f.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(f.StringUnknownMap)
	}
}

type FailedDependencyErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (f *FailedDependencyErrorBodyData) Accept(visitor FailedDependencyErrorBodyDataVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(f.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(f.StringUnknownMap)
	}
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type FailedDependencyErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewFailedDependencyErrorDataFromStringUnknownMapList(value []map[string]interface{}) *FailedDependencyErrorData {
	return &FailedDependencyErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewFailedDependencyErrorDataFromStringUnknownMap(value map[string]interface{}) *FailedDependencyErrorData {
	return &FailedDependencyErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (f *FailedDependencyErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		f.typeName = "stringUnknownMapList"
		f.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		f.typeName = "stringUnknownMap"
		f.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FailedDependencyErrorData) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return json.Marshal(f.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(f.StringUnknownMap)
	}
}

type FailedDependencyErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (f *FailedDependencyErrorData) Accept(visitor FailedDependencyErrorDataVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(f.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(f.StringUnknownMap)
	}
}

type ForbiddenErrorBody struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *ForbiddenErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (f *ForbiddenErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ForbiddenErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = ForbiddenErrorBody(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *ForbiddenErrorBody) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type ForbiddenErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewForbiddenErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *ForbiddenErrorBodyData {
	return &ForbiddenErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewForbiddenErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *ForbiddenErrorBodyData {
	return &ForbiddenErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (f *ForbiddenErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		f.typeName = "stringUnknownMapList"
		f.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		f.typeName = "stringUnknownMap"
		f.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f ForbiddenErrorBodyData) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return json.Marshal(f.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(f.StringUnknownMap)
	}
}

type ForbiddenErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (f *ForbiddenErrorBodyData) Accept(visitor ForbiddenErrorBodyDataVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(f.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(f.StringUnknownMap)
	}
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type ForbiddenErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewForbiddenErrorDataFromStringUnknownMapList(value []map[string]interface{}) *ForbiddenErrorData {
	return &ForbiddenErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewForbiddenErrorDataFromStringUnknownMap(value map[string]interface{}) *ForbiddenErrorData {
	return &ForbiddenErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (f *ForbiddenErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		f.typeName = "stringUnknownMapList"
		f.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		f.typeName = "stringUnknownMap"
		f.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f ForbiddenErrorData) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return json.Marshal(f.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(f.StringUnknownMap)
	}
}

type ForbiddenErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (f *ForbiddenErrorData) Accept(visitor ForbiddenErrorDataVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(f.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(f.StringUnknownMap)
	}
}

type InternalServerErrorBody struct {
	Data *InternalServerErrorBodyData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InternalServerErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler InternalServerErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InternalServerErrorBody(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InternalServerErrorBody) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InternalServerErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewInternalServerErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *InternalServerErrorBodyData {
	return &InternalServerErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewInternalServerErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *InternalServerErrorBodyData {
	return &InternalServerErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (i *InternalServerErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		i.typeName = "stringUnknownMapList"
		i.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		i.typeName = "stringUnknownMap"
		i.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InternalServerErrorBodyData) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "stringUnknownMapList":
		return json.Marshal(i.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(i.StringUnknownMap)
	}
}

type InternalServerErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (i *InternalServerErrorBodyData) Accept(visitor InternalServerErrorBodyDataVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(i.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(i.StringUnknownMap)
	}
}

type MediaTypeError struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *MediaTypeErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MediaTypeError) UnmarshalJSON(data []byte) error {
	type unmarshaler MediaTypeError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MediaTypeError(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MediaTypeError) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type MediaTypeErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewMediaTypeErrorDataFromStringUnknownMapList(value []map[string]interface{}) *MediaTypeErrorData {
	return &MediaTypeErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewMediaTypeErrorDataFromStringUnknownMap(value map[string]interface{}) *MediaTypeErrorData {
	return &MediaTypeErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (m *MediaTypeErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		m.typeName = "stringUnknownMapList"
		m.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		m.typeName = "stringUnknownMap"
		m.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MediaTypeErrorData) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringUnknownMapList":
		return json.Marshal(m.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(m.StringUnknownMap)
	}
}

type MediaTypeErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (m *MediaTypeErrorData) Accept(visitor MediaTypeErrorDataVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(m.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(m.StringUnknownMap)
	}
}

type MethodNotAllowedErrorBody struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *MethodNotAllowedErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MethodNotAllowedErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler MethodNotAllowedErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MethodNotAllowedErrorBody(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MethodNotAllowedErrorBody) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MethodNotAllowedErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewMethodNotAllowedErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *MethodNotAllowedErrorBodyData {
	return &MethodNotAllowedErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewMethodNotAllowedErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *MethodNotAllowedErrorBodyData {
	return &MethodNotAllowedErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (m *MethodNotAllowedErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		m.typeName = "stringUnknownMapList"
		m.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		m.typeName = "stringUnknownMap"
		m.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MethodNotAllowedErrorBodyData) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringUnknownMapList":
		return json.Marshal(m.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(m.StringUnknownMap)
	}
}

type MethodNotAllowedErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (m *MethodNotAllowedErrorBodyData) Accept(visitor MethodNotAllowedErrorBodyDataVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(m.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(m.StringUnknownMap)
	}
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type MethodNotAllowedErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewMethodNotAllowedErrorDataFromStringUnknownMapList(value []map[string]interface{}) *MethodNotAllowedErrorData {
	return &MethodNotAllowedErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewMethodNotAllowedErrorDataFromStringUnknownMap(value map[string]interface{}) *MethodNotAllowedErrorData {
	return &MethodNotAllowedErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (m *MethodNotAllowedErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		m.typeName = "stringUnknownMapList"
		m.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		m.typeName = "stringUnknownMap"
		m.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, m)
}

func (m MethodNotAllowedErrorData) MarshalJSON() ([]byte, error) {
	switch m.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringUnknownMapList":
		return json.Marshal(m.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(m.StringUnknownMap)
	}
}

type MethodNotAllowedErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (m *MethodNotAllowedErrorData) Accept(visitor MethodNotAllowedErrorDataVisitor) error {
	switch m.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", m.typeName, m)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(m.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(m.StringUnknownMap)
	}
}

type NotAcceptableErrorBody struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *NotAcceptableErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NotAcceptableErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler NotAcceptableErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotAcceptableErrorBody(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotAcceptableErrorBody) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotAcceptableErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewNotAcceptableErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *NotAcceptableErrorBodyData {
	return &NotAcceptableErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewNotAcceptableErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *NotAcceptableErrorBodyData {
	return &NotAcceptableErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (n *NotAcceptableErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		n.typeName = "stringUnknownMapList"
		n.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		n.typeName = "stringUnknownMap"
		n.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NotAcceptableErrorBodyData) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return json.Marshal(n.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(n.StringUnknownMap)
	}
}

type NotAcceptableErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (n *NotAcceptableErrorBodyData) Accept(visitor NotAcceptableErrorBodyDataVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(n.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(n.StringUnknownMap)
	}
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type NotAcceptableErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewNotAcceptableErrorDataFromStringUnknownMapList(value []map[string]interface{}) *NotAcceptableErrorData {
	return &NotAcceptableErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewNotAcceptableErrorDataFromStringUnknownMap(value map[string]interface{}) *NotAcceptableErrorData {
	return &NotAcceptableErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (n *NotAcceptableErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		n.typeName = "stringUnknownMapList"
		n.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		n.typeName = "stringUnknownMap"
		n.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NotAcceptableErrorData) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return json.Marshal(n.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(n.StringUnknownMap)
	}
}

type NotAcceptableErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (n *NotAcceptableErrorData) Accept(visitor NotAcceptableErrorDataVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(n.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(n.StringUnknownMap)
	}
}

type NotFoundErrorBody struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *NotFoundErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NotFoundErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler NotFoundErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotFoundErrorBody(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotFoundErrorBody) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotFoundErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewNotFoundErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *NotFoundErrorBodyData {
	return &NotFoundErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewNotFoundErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *NotFoundErrorBodyData {
	return &NotFoundErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (n *NotFoundErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		n.typeName = "stringUnknownMapList"
		n.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		n.typeName = "stringUnknownMap"
		n.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NotFoundErrorBodyData) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return json.Marshal(n.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(n.StringUnknownMap)
	}
}

type NotFoundErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (n *NotFoundErrorBodyData) Accept(visitor NotFoundErrorBodyDataVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(n.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(n.StringUnknownMap)
	}
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type NotFoundErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewNotFoundErrorDataFromStringUnknownMapList(value []map[string]interface{}) *NotFoundErrorData {
	return &NotFoundErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewNotFoundErrorDataFromStringUnknownMap(value map[string]interface{}) *NotFoundErrorData {
	return &NotFoundErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (n *NotFoundErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		n.typeName = "stringUnknownMapList"
		n.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		n.typeName = "stringUnknownMap"
		n.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, n)
}

func (n NotFoundErrorData) MarshalJSON() ([]byte, error) {
	switch n.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return json.Marshal(n.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(n.StringUnknownMap)
	}
}

type NotFoundErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (n *NotFoundErrorData) Accept(visitor NotFoundErrorDataVisitor) error {
	switch n.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", n.typeName, n)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(n.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(n.StringUnknownMap)
	}
}

type ServerError struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *ServerErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ServerError) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerError(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerError) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type ServerErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewServerErrorDataFromStringUnknownMapList(value []map[string]interface{}) *ServerErrorData {
	return &ServerErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewServerErrorDataFromStringUnknownMap(value map[string]interface{}) *ServerErrorData {
	return &ServerErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (s *ServerErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		s.typeName = "stringUnknownMapList"
		s.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		s.typeName = "stringUnknownMap"
		s.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServerErrorData) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringUnknownMapList":
		return json.Marshal(s.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(s.StringUnknownMap)
	}
}

type ServerErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (s *ServerErrorData) Accept(visitor ServerErrorDataVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(s.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(s.StringUnknownMap)
	}
}

type ServiceUnavailableErrorBody struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *ServiceUnavailableErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ServiceUnavailableErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ServiceUnavailableErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServiceUnavailableErrorBody(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServiceUnavailableErrorBody) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ServiceUnavailableErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewServiceUnavailableErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *ServiceUnavailableErrorBodyData {
	return &ServiceUnavailableErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewServiceUnavailableErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *ServiceUnavailableErrorBodyData {
	return &ServiceUnavailableErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (s *ServiceUnavailableErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		s.typeName = "stringUnknownMapList"
		s.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		s.typeName = "stringUnknownMap"
		s.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServiceUnavailableErrorBodyData) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringUnknownMapList":
		return json.Marshal(s.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(s.StringUnknownMap)
	}
}

type ServiceUnavailableErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (s *ServiceUnavailableErrorBodyData) Accept(visitor ServiceUnavailableErrorBodyDataVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(s.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(s.StringUnknownMap)
	}
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type ServiceUnavailableErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewServiceUnavailableErrorDataFromStringUnknownMapList(value []map[string]interface{}) *ServiceUnavailableErrorData {
	return &ServiceUnavailableErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewServiceUnavailableErrorDataFromStringUnknownMap(value map[string]interface{}) *ServiceUnavailableErrorData {
	return &ServiceUnavailableErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (s *ServiceUnavailableErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		s.typeName = "stringUnknownMapList"
		s.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		s.typeName = "stringUnknownMap"
		s.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ServiceUnavailableErrorData) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringUnknownMapList":
		return json.Marshal(s.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(s.StringUnknownMap)
	}
}

type ServiceUnavailableErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (s *ServiceUnavailableErrorData) Accept(visitor ServiceUnavailableErrorDataVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(s.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(s.StringUnknownMap)
	}
}

type UnauthorizedErrorBody struct {
	Data *UnauthorizedErrorBodyData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UnauthorizedErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler UnauthorizedErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnauthorizedErrorBody(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnauthorizedErrorBody) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UnauthorizedErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewUnauthorizedErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *UnauthorizedErrorBodyData {
	return &UnauthorizedErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewUnauthorizedErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *UnauthorizedErrorBodyData {
	return &UnauthorizedErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (u *UnauthorizedErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		u.typeName = "stringUnknownMapList"
		u.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		u.typeName = "stringUnknownMap"
		u.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnauthorizedErrorBodyData) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return json.Marshal(u.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(u.StringUnknownMap)
	}
}

type UnauthorizedErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (u *UnauthorizedErrorBodyData) Accept(visitor UnauthorizedErrorBodyDataVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(u.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(u.StringUnknownMap)
	}
}

type UnprocessableContentError struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *UnprocessableContentErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UnprocessableContentError) UnmarshalJSON(data []byte) error {
	type unmarshaler UnprocessableContentError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnprocessableContentError(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnprocessableContentError) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type UnprocessableContentErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewUnprocessableContentErrorDataFromStringUnknownMapList(value []map[string]interface{}) *UnprocessableContentErrorData {
	return &UnprocessableContentErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewUnprocessableContentErrorDataFromStringUnknownMap(value map[string]interface{}) *UnprocessableContentErrorData {
	return &UnprocessableContentErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (u *UnprocessableContentErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		u.typeName = "stringUnknownMapList"
		u.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		u.typeName = "stringUnknownMap"
		u.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnprocessableContentErrorData) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return json.Marshal(u.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(u.StringUnknownMap)
	}
}

type UnprocessableContentErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (u *UnprocessableContentErrorData) Accept(visitor UnprocessableContentErrorDataVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(u.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(u.StringUnknownMap)
	}
}

type UnprocessableEntityErrorBody struct {
	Data *UnprocessableEntityErrorBodyData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UnprocessableEntityErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler UnprocessableEntityErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnprocessableEntityErrorBody(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnprocessableEntityErrorBody) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UnprocessableEntityErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewUnprocessableEntityErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *UnprocessableEntityErrorBodyData {
	return &UnprocessableEntityErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewUnprocessableEntityErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *UnprocessableEntityErrorBodyData {
	return &UnprocessableEntityErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (u *UnprocessableEntityErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		u.typeName = "stringUnknownMapList"
		u.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		u.typeName = "stringUnknownMap"
		u.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnprocessableEntityErrorBodyData) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return json.Marshal(u.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(u.StringUnknownMap)
	}
}

type UnprocessableEntityErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (u *UnprocessableEntityErrorBodyData) Accept(visitor UnprocessableEntityErrorBodyDataVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(u.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(u.StringUnknownMap)
	}
}

type UnsupportedMediaTypeErrorBody struct {
	Data *UnsupportedMediaTypeErrorBodyData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UnsupportedMediaTypeErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler UnsupportedMediaTypeErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnsupportedMediaTypeErrorBody(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnsupportedMediaTypeErrorBody) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UnsupportedMediaTypeErrorBodyData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewUnsupportedMediaTypeErrorBodyDataFromStringUnknownMapList(value []map[string]interface{}) *UnsupportedMediaTypeErrorBodyData {
	return &UnsupportedMediaTypeErrorBodyData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewUnsupportedMediaTypeErrorBodyDataFromStringUnknownMap(value map[string]interface{}) *UnsupportedMediaTypeErrorBodyData {
	return &UnsupportedMediaTypeErrorBodyData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (u *UnsupportedMediaTypeErrorBodyData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		u.typeName = "stringUnknownMapList"
		u.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		u.typeName = "stringUnknownMap"
		u.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UnsupportedMediaTypeErrorBodyData) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return json.Marshal(u.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(u.StringUnknownMap)
	}
}

type UnsupportedMediaTypeErrorBodyDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (u *UnsupportedMediaTypeErrorBodyData) Accept(visitor UnsupportedMediaTypeErrorBodyDataVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(u.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(u.StringUnknownMap)
	}
}

type ValidationError struct {
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
	Data *ValidationErrorData `json:"data,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (v *ValidationError) UnmarshalJSON(data []byte) error {
	type unmarshaler ValidationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValidationError(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValidationError) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The data requested from the API. In the event that many objects havebeen requested, this field will be an array of objects. Otherwise, it will only returnthe single object requested.
type ValidationErrorData struct {
	typeName             string
	StringUnknownMapList []map[string]interface{}
	StringUnknownMap     map[string]interface{}
}

func NewValidationErrorDataFromStringUnknownMapList(value []map[string]interface{}) *ValidationErrorData {
	return &ValidationErrorData{typeName: "stringUnknownMapList", StringUnknownMapList: value}
}

func NewValidationErrorDataFromStringUnknownMap(value map[string]interface{}) *ValidationErrorData {
	return &ValidationErrorData{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (v *ValidationErrorData) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMapList []map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapList); err == nil {
		v.typeName = "stringUnknownMapList"
		v.StringUnknownMapList = valueStringUnknownMapList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		v.typeName = "stringUnknownMap"
		v.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, v)
}

func (v ValidationErrorData) MarshalJSON() ([]byte, error) {
	switch v.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "stringUnknownMapList":
		return json.Marshal(v.StringUnknownMapList)
	case "stringUnknownMap":
		return json.Marshal(v.StringUnknownMap)
	}
}

type ValidationErrorDataVisitor interface {
	VisitStringUnknownMapList([]map[string]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (v *ValidationErrorData) Accept(visitor ValidationErrorDataVisitor) error {
	switch v.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", v.typeName, v)
	case "stringUnknownMapList":
		return visitor.VisitStringUnknownMapList(v.StringUnknownMapList)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(v.StringUnknownMap)
	}
}
