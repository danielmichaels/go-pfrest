// This file was auto-generated by Fern from our API Definition.

package pfclientapi

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/danielmichaels/go-pfrest/pkg/client/core"
)

type DeleteVpniPsecPhase1EncryptionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteVpniPsecPhase1EncryptionsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpniPsecPhase1EndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteVpniPsecPhase1SEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpniPsecPhase2EncryptionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteVpniPsecPhase2EncryptionsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpniPsecPhase2EndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteVpniPsecPhase2SEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnOpenVpncsoEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteVpnOpenVpncsOsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnOpenVpnClientEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteVpnOpenVpnClientExportConfigEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteVpnOpenVpnClientExportConfigsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnOpenVpnClientsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnOpenVpnServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteVpnOpenVpnServersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnWireGuardPeerAllowedIPEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteVpnWireGuardPeerAllowedIPsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnWireGuardPeerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteVpnWireGuardPeersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnWireGuardTunnelAddressEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteVpnWireGuardTunnelAddressesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteVpnWireGuardTunnelEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteVpnWireGuardTunnelsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpniPsecPhase1EncryptionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpniPsecPhase1EncryptionsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpniPsecPhase1EndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpniPsecPhase1SEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpniPsecPhase1SEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpniPsecPhase1SEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpniPsecPhase2EncryptionEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpniPsecPhase2EncryptionsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpniPsecPhase2EndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpniPsecPhase2SEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpniPsecPhase2SEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpniPsecPhase2SEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnOpenVpncsoEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnOpenVpncsOsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnOpenVpncsOsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnOpenVpncsOsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnOpenVpnClientEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnOpenVpnClientExportConfigEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnOpenVpnClientExportConfigsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnOpenVpnClientsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnOpenVpnClientsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnOpenVpnClientsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnOpenVpnServerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnOpenVpnServersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnOpenVpnServersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnOpenVpnServersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnWireGuardPeerAllowedIPEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnWireGuardPeerAllowedIPsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnWireGuardPeerEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnWireGuardPeersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnWireGuardPeersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnWireGuardPeersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnWireGuardTunnelAddressEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnWireGuardTunnelAddressesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetVpnWireGuardTunnelEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetVpnWireGuardTunnelsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetVpnWireGuardTunnelsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetVpnWireGuardTunnelsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type PatchVpniPsecPhase1EncryptionEndpointRequest struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpniPsecPhase1EndpointRequest struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpniPsecPhase2EncryptionEndpointRequest struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen *int `json:"keylen,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpniPsecPhase2EndpointRequest struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnOpenVpncsoEndpointRequest struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnOpenVpnClientEndpointRequest struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnOpenVpnClientExportConfigEndpointRequest struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnOpenVpnServerEndpointRequest struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnWireGuardPeerAllowedIPEndpointRequest struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnWireGuardPeerEndpointRequest struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnWireGuardSettingsEndpointRequest struct {
	// Enables or disables WireGuard on this system. WireGuard cannot be disabled when one or more tunnels is assigned to a pfSense interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// Enables or disables keeping the WireGuard configuration when the package is uninstalled/reinstalled.<br>
	KeepConf *bool `json:"keep_conf,omitempty"`
	// Enables or disables tracking the 'Aliases Hostnames Resolve Interval' value as the `resolve_internal` value instead of specifying a value directly.<br>
	ResolveIntervalTrack *bool `json:"resolve_interval_track,omitempty"`
	// The interval (in seconds) for re-resolving endpoint host/domain names.<br><br>This field is only available when the following conditions are met:<br>- `resolve_interval_track` must be equal to `false`<br>
	ResolveInterval *int `json:"resolve_interval,omitempty"`
	// Configures which WireGuard tunnels are members of the WireGuard interface group.<br>
	InterfaceGroup *WireGuardSettingsInterfaceGroup `json:"interface_group,omitempty"`
	// Enables or disables hiding all secrets (private and pre-shared keys) in the user interface.<br>
	HideSecrets *bool `json:"hide_secrets,omitempty"`
	// Enables or disables initially hiding all peers in the user interface.<br>
	HidePeers *bool `json:"hide_peers,omitempty"`
}

type PatchVpnWireGuardTunnelAddressEndpointRequest struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchVpnWireGuardTunnelEndpointRequest struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PostVpniPsecApplyEndpointRequest struct {
	// Displays `true` when all IPsec changes are applied and there are no pending changes left.Displays `false` when there are pending IPsec changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
}

type PostVpniPsecPhase1EncryptionEndpointRequest struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostVpniPsecPhase1EndpointRequest struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
}

type PostVpniPsecPhase2EncryptionEndpointRequest struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen *int `json:"keylen,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostVpniPsecPhase2EndpointRequest struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
}

type PostVpnOpenVpncsoEndpointRequest struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
}

type PostVpnOpenVpnClientEndpointRequest struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
}

type PostVpnOpenVpnClientExportConfigEndpointRequest struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
}

type PostVpnOpenVpnClientExportEndpointRequest struct {
	// The type of OpenVPN client export to generate. This determines the format and content of the export file.<br>
	Type *OpenVpnClientExportType `json:"type,omitempty"`
	// The reference ID of the certificate to use for this OpenVPN client export. This is only applicable for OpenVPN servers that require client certificates.<br>
	Certref *string `json:"certref,omitempty"`
	// The username of the user this client export corresponds to. This is only applicable for OpenVPN servers that use the Local Database AND client certificates.<br>
	Username *string `json:"username,omitempty"`
	// The filename used when exporting the OpenVPN client export. This value cannot be changed<br>
	Filename *string `json:"filename,omitempty"`
	// The binary data of the OpenVPN client export. This is used to store the actual exported configuration file content. When the content-type is set to "application/octet-stream", this field will contain the data of the OpenVPN client export download.<br>
	BinaryData *string `json:"binary_data,omitempty"`
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PostVpnOpenVpnServerEndpointRequest struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
}

type PostVpnWireGuardApplyEndpointRequest struct {
	// Displays `true` when all WireGuard changes are applied and there are no pending changes left.Displays `false` when there are pending WireGuard changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
}

type PostVpnWireGuardPeerAllowedIPEndpointRequest struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostVpnWireGuardPeerEndpointRequest struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
}

type PostVpnWireGuardTunnelAddressEndpointRequest struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostVpnWireGuardTunnelEndpointRequest struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
}

type IPsecApply struct {
	// Displays `true` when all IPsec changes are applied and there are no pending changes left.Displays `false` when there are pending IPsec changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IPsecApply) UnmarshalJSON(data []byte) error {
	type unmarshaler IPsecApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPsecApply(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPsecApply) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IPsecPhase1 struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IPsecPhase1) UnmarshalJSON(data []byte) error {
	type unmarshaler IPsecPhase1
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPsecPhase1(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPsecPhase1) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The IPsec authentication method this tunnel will use.<br>
type IPsecPhase1AuthenticationMethod string

const (
	IPsecPhase1AuthenticationMethodPreSharedKey IPsecPhase1AuthenticationMethod = "pre_shared_key"
	IPsecPhase1AuthenticationMethodCert         IPsecPhase1AuthenticationMethod = "cert"
)

func NewIPsecPhase1AuthenticationMethodFromString(s string) (IPsecPhase1AuthenticationMethod, error) {
	switch s {
	case "pre_shared_key":
		return IPsecPhase1AuthenticationMethodPreSharedKey, nil
	case "cert":
		return IPsecPhase1AuthenticationMethodCert, nil
	}
	var t IPsecPhase1AuthenticationMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1AuthenticationMethod) Ptr() *IPsecPhase1AuthenticationMethod {
	return &i
}

// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
type IPsecPhase1Closeaction string

const (
	IPsecPhase1CloseactionEmptyValue0 IPsecPhase1Closeaction = "empty_value_0"
	IPsecPhase1CloseactionNone        IPsecPhase1Closeaction = "none"
	IPsecPhase1CloseactionStart       IPsecPhase1Closeaction = "start"
	IPsecPhase1CloseactionTrap        IPsecPhase1Closeaction = "trap"
)

func NewIPsecPhase1CloseactionFromString(s string) (IPsecPhase1Closeaction, error) {
	switch s {
	case "empty_value_0":
		return IPsecPhase1CloseactionEmptyValue0, nil
	case "none":
		return IPsecPhase1CloseactionNone, nil
	case "start":
		return IPsecPhase1CloseactionStart, nil
	case "trap":
		return IPsecPhase1CloseactionTrap, nil
	}
	var t IPsecPhase1Closeaction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1Closeaction) Ptr() *IPsecPhase1Closeaction {
	return &i
}

type IPsecPhase1Encryption struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IPsecPhase1Encryption) UnmarshalJSON(data []byte) error {
	type unmarshaler IPsecPhase1Encryption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPsecPhase1Encryption(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPsecPhase1Encryption) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The name of the encryption algorithm to use for this P1 encryption item.<br>
type IPsecPhase1EncryptionEncryptionAlgorithmName string

const (
	IPsecPhase1EncryptionEncryptionAlgorithmNameAes              IPsecPhase1EncryptionEncryptionAlgorithmName = "aes"
	IPsecPhase1EncryptionEncryptionAlgorithmNameAes128Gcm        IPsecPhase1EncryptionEncryptionAlgorithmName = "aes128gcm"
	IPsecPhase1EncryptionEncryptionAlgorithmNameAes192Gcm        IPsecPhase1EncryptionEncryptionAlgorithmName = "aes192gcm"
	IPsecPhase1EncryptionEncryptionAlgorithmNameAes256Gcm        IPsecPhase1EncryptionEncryptionAlgorithmName = "aes256gcm"
	IPsecPhase1EncryptionEncryptionAlgorithmNameChacha20Poly1305 IPsecPhase1EncryptionEncryptionAlgorithmName = "chacha20poly1305"
)

func NewIPsecPhase1EncryptionEncryptionAlgorithmNameFromString(s string) (IPsecPhase1EncryptionEncryptionAlgorithmName, error) {
	switch s {
	case "aes":
		return IPsecPhase1EncryptionEncryptionAlgorithmNameAes, nil
	case "aes128gcm":
		return IPsecPhase1EncryptionEncryptionAlgorithmNameAes128Gcm, nil
	case "aes192gcm":
		return IPsecPhase1EncryptionEncryptionAlgorithmNameAes192Gcm, nil
	case "aes256gcm":
		return IPsecPhase1EncryptionEncryptionAlgorithmNameAes256Gcm, nil
	case "chacha20poly1305":
		return IPsecPhase1EncryptionEncryptionAlgorithmNameChacha20Poly1305, nil
	}
	var t IPsecPhase1EncryptionEncryptionAlgorithmName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1EncryptionEncryptionAlgorithmName) Ptr() *IPsecPhase1EncryptionEncryptionAlgorithmName {
	return &i
}

// The hash algorithm to use for this P1 encryption item.<br>
type IPsecPhase1EncryptionHashAlgorithm string

const (
	IPsecPhase1EncryptionHashAlgorithmSha1    IPsecPhase1EncryptionHashAlgorithm = "sha1"
	IPsecPhase1EncryptionHashAlgorithmSha256  IPsecPhase1EncryptionHashAlgorithm = "sha256"
	IPsecPhase1EncryptionHashAlgorithmSha384  IPsecPhase1EncryptionHashAlgorithm = "sha384"
	IPsecPhase1EncryptionHashAlgorithmSha512  IPsecPhase1EncryptionHashAlgorithm = "sha512"
	IPsecPhase1EncryptionHashAlgorithmAesxcbc IPsecPhase1EncryptionHashAlgorithm = "aesxcbc"
)

func NewIPsecPhase1EncryptionHashAlgorithmFromString(s string) (IPsecPhase1EncryptionHashAlgorithm, error) {
	switch s {
	case "sha1":
		return IPsecPhase1EncryptionHashAlgorithmSha1, nil
	case "sha256":
		return IPsecPhase1EncryptionHashAlgorithmSha256, nil
	case "sha384":
		return IPsecPhase1EncryptionHashAlgorithmSha384, nil
	case "sha512":
		return IPsecPhase1EncryptionHashAlgorithmSha512, nil
	case "aesxcbc":
		return IPsecPhase1EncryptionHashAlgorithmAesxcbc, nil
	}
	var t IPsecPhase1EncryptionHashAlgorithm
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1EncryptionHashAlgorithm) Ptr() *IPsecPhase1EncryptionHashAlgorithm {
	return &i
}

type IPsecPhase1EncryptionItem struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IPsecPhase1EncryptionItem) UnmarshalJSON(data []byte) error {
	type unmarshaler IPsecPhase1EncryptionItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPsecPhase1EncryptionItem(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPsecPhase1EncryptionItem) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
type IPsecPhase1EncryptionPrfAlgorithm string

const (
	IPsecPhase1EncryptionPrfAlgorithmSha1    IPsecPhase1EncryptionPrfAlgorithm = "sha1"
	IPsecPhase1EncryptionPrfAlgorithmSha256  IPsecPhase1EncryptionPrfAlgorithm = "sha256"
	IPsecPhase1EncryptionPrfAlgorithmSha384  IPsecPhase1EncryptionPrfAlgorithm = "sha384"
	IPsecPhase1EncryptionPrfAlgorithmSha512  IPsecPhase1EncryptionPrfAlgorithm = "sha512"
	IPsecPhase1EncryptionPrfAlgorithmAesxcbc IPsecPhase1EncryptionPrfAlgorithm = "aesxcbc"
)

func NewIPsecPhase1EncryptionPrfAlgorithmFromString(s string) (IPsecPhase1EncryptionPrfAlgorithm, error) {
	switch s {
	case "sha1":
		return IPsecPhase1EncryptionPrfAlgorithmSha1, nil
	case "sha256":
		return IPsecPhase1EncryptionPrfAlgorithmSha256, nil
	case "sha384":
		return IPsecPhase1EncryptionPrfAlgorithmSha384, nil
	case "sha512":
		return IPsecPhase1EncryptionPrfAlgorithmSha512, nil
	case "aesxcbc":
		return IPsecPhase1EncryptionPrfAlgorithmAesxcbc, nil
	}
	var t IPsecPhase1EncryptionPrfAlgorithm
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1EncryptionPrfAlgorithm) Ptr() *IPsecPhase1EncryptionPrfAlgorithm {
	return &i
}

// The IKE protocol version this phase 1 entry will use.<br>
type IPsecPhase1Iketype string

const (
	IPsecPhase1IketypeIkev1 IPsecPhase1Iketype = "ikev1"
	IPsecPhase1IketypeIkev2 IPsecPhase1Iketype = "ikev2"
	IPsecPhase1IketypeAuto  IPsecPhase1Iketype = "auto"
)

func NewIPsecPhase1IketypeFromString(s string) (IPsecPhase1Iketype, error) {
	switch s {
	case "ikev1":
		return IPsecPhase1IketypeIkev1, nil
	case "ikev2":
		return IPsecPhase1IketypeIkev2, nil
	case "auto":
		return IPsecPhase1IketypeAuto, nil
	}
	var t IPsecPhase1Iketype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1Iketype) Ptr() *IPsecPhase1Iketype {
	return &i
}

// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
type IPsecPhase1Mode string

const (
	IPsecPhase1ModeMain       IPsecPhase1Mode = "main"
	IPsecPhase1ModeAggressive IPsecPhase1Mode = "aggressive"
)

func NewIPsecPhase1ModeFromString(s string) (IPsecPhase1Mode, error) {
	switch s {
	case "main":
		return IPsecPhase1ModeMain, nil
	case "aggressive":
		return IPsecPhase1ModeAggressive, nil
	}
	var t IPsecPhase1Mode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1Mode) Ptr() *IPsecPhase1Mode {
	return &i
}

// The identifier type used by the local end of the tunnel.<br>
type IPsecPhase1MyidType string

const (
	IPsecPhase1MyidTypeMyaddress IPsecPhase1MyidType = "myaddress"
	IPsecPhase1MyidTypeAddress   IPsecPhase1MyidType = "address"
	IPsecPhase1MyidTypeFqdn      IPsecPhase1MyidType = "fqdn"
	IPsecPhase1MyidTypeUserFqdn  IPsecPhase1MyidType = "user_fqdn"
	IPsecPhase1MyidTypeAsn1Dn    IPsecPhase1MyidType = "asn1dn"
	IPsecPhase1MyidTypeKeyidTag  IPsecPhase1MyidType = "keyid tag"
	IPsecPhase1MyidTypeDynDNS    IPsecPhase1MyidType = "dyn_dns"
	IPsecPhase1MyidTypeAuto      IPsecPhase1MyidType = "auto"
)

func NewIPsecPhase1MyidTypeFromString(s string) (IPsecPhase1MyidType, error) {
	switch s {
	case "myaddress":
		return IPsecPhase1MyidTypeMyaddress, nil
	case "address":
		return IPsecPhase1MyidTypeAddress, nil
	case "fqdn":
		return IPsecPhase1MyidTypeFqdn, nil
	case "user_fqdn":
		return IPsecPhase1MyidTypeUserFqdn, nil
	case "asn1dn":
		return IPsecPhase1MyidTypeAsn1Dn, nil
	case "keyid tag":
		return IPsecPhase1MyidTypeKeyidTag, nil
	case "dyn_dns":
		return IPsecPhase1MyidTypeDynDNS, nil
	case "auto":
		return IPsecPhase1MyidTypeAuto, nil
	}
	var t IPsecPhase1MyidType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1MyidType) Ptr() *IPsecPhase1MyidType {
	return &i
}

// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
type IPsecPhase1NatTraversal string

const (
	IPsecPhase1NatTraversalOn    IPsecPhase1NatTraversal = "on"
	IPsecPhase1NatTraversalForce IPsecPhase1NatTraversal = "force"
)

func NewIPsecPhase1NatTraversalFromString(s string) (IPsecPhase1NatTraversal, error) {
	switch s {
	case "on":
		return IPsecPhase1NatTraversalOn, nil
	case "force":
		return IPsecPhase1NatTraversalForce, nil
	}
	var t IPsecPhase1NatTraversal
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1NatTraversal) Ptr() *IPsecPhase1NatTraversal {
	return &i
}

// The identifier type used by the remote end of the tunnel.<br>
type IPsecPhase1PeeridType string

const (
	IPsecPhase1PeeridTypeAny         IPsecPhase1PeeridType = "any"
	IPsecPhase1PeeridTypePeeraddress IPsecPhase1PeeridType = "peeraddress"
	IPsecPhase1PeeridTypeAddress     IPsecPhase1PeeridType = "address"
	IPsecPhase1PeeridTypeFqdn        IPsecPhase1PeeridType = "fqdn"
	IPsecPhase1PeeridTypeUserFqdn    IPsecPhase1PeeridType = "user_fqdn"
	IPsecPhase1PeeridTypeAsn1Dn      IPsecPhase1PeeridType = "asn1dn"
	IPsecPhase1PeeridTypeKeyidTag    IPsecPhase1PeeridType = "keyid tag"
	IPsecPhase1PeeridTypeDynDNS      IPsecPhase1PeeridType = "dyn_dns"
	IPsecPhase1PeeridTypeAuto        IPsecPhase1PeeridType = "auto"
)

func NewIPsecPhase1PeeridTypeFromString(s string) (IPsecPhase1PeeridType, error) {
	switch s {
	case "any":
		return IPsecPhase1PeeridTypeAny, nil
	case "peeraddress":
		return IPsecPhase1PeeridTypePeeraddress, nil
	case "address":
		return IPsecPhase1PeeridTypeAddress, nil
	case "fqdn":
		return IPsecPhase1PeeridTypeFqdn, nil
	case "user_fqdn":
		return IPsecPhase1PeeridTypeUserFqdn, nil
	case "asn1dn":
		return IPsecPhase1PeeridTypeAsn1Dn, nil
	case "keyid tag":
		return IPsecPhase1PeeridTypeKeyidTag, nil
	case "dyn_dns":
		return IPsecPhase1PeeridTypeDynDNS, nil
	case "auto":
		return IPsecPhase1PeeridTypeAuto, nil
	}
	var t IPsecPhase1PeeridType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1PeeridType) Ptr() *IPsecPhase1PeeridType {
	return &i
}

// The IP version this phase 1 entry will use.<br>
type IPsecPhase1Protocol string

const (
	IPsecPhase1ProtocolInet  IPsecPhase1Protocol = "inet"
	IPsecPhase1ProtocolInet6 IPsecPhase1Protocol = "inet6"
	IPsecPhase1ProtocolBoth  IPsecPhase1Protocol = "both"
)

func NewIPsecPhase1ProtocolFromString(s string) (IPsecPhase1Protocol, error) {
	switch s {
	case "inet":
		return IPsecPhase1ProtocolInet, nil
	case "inet6":
		return IPsecPhase1ProtocolInet6, nil
	case "both":
		return IPsecPhase1ProtocolBoth, nil
	}
	var t IPsecPhase1Protocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1Protocol) Ptr() *IPsecPhase1Protocol {
	return &i
}

// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
type IPsecPhase1Startaction string

const (
	IPsecPhase1StartactionEmptyValue0 IPsecPhase1Startaction = "empty_value_0"
	IPsecPhase1StartactionNone        IPsecPhase1Startaction = "none"
	IPsecPhase1StartactionStart       IPsecPhase1Startaction = "start"
	IPsecPhase1StartactionTrap        IPsecPhase1Startaction = "trap"
)

func NewIPsecPhase1StartactionFromString(s string) (IPsecPhase1Startaction, error) {
	switch s {
	case "empty_value_0":
		return IPsecPhase1StartactionEmptyValue0, nil
	case "none":
		return IPsecPhase1StartactionNone, nil
	case "start":
		return IPsecPhase1StartactionStart, nil
	case "trap":
		return IPsecPhase1StartactionTrap, nil
	}
	var t IPsecPhase1Startaction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase1Startaction) Ptr() *IPsecPhase1Startaction {
	return &i
}

type IPsecPhase2 struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IPsecPhase2) UnmarshalJSON(data []byte) error {
	type unmarshaler IPsecPhase2
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPsecPhase2(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPsecPhase2) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IPsecPhase2Encryption struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen *int `json:"keylen,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IPsecPhase2Encryption) UnmarshalJSON(data []byte) error {
	type unmarshaler IPsecPhase2Encryption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPsecPhase2Encryption(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPsecPhase2Encryption) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IPsecPhase2EncryptionAlgorithmOptionItem struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen *int `json:"keylen,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IPsecPhase2EncryptionAlgorithmOptionItem) UnmarshalJSON(data []byte) error {
	type unmarshaler IPsecPhase2EncryptionAlgorithmOptionItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPsecPhase2EncryptionAlgorithmOptionItem(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPsecPhase2EncryptionAlgorithmOptionItem) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The name of the encryption algorithm to use for this P2 encryption item.<br>
type IPsecPhase2EncryptionName string

const (
	IPsecPhase2EncryptionNameAes              IPsecPhase2EncryptionName = "aes"
	IPsecPhase2EncryptionNameAes128Gcm        IPsecPhase2EncryptionName = "aes128gcm"
	IPsecPhase2EncryptionNameAes192Gcm        IPsecPhase2EncryptionName = "aes192gcm"
	IPsecPhase2EncryptionNameAes256Gcm        IPsecPhase2EncryptionName = "aes256gcm"
	IPsecPhase2EncryptionNameChacha20Poly1305 IPsecPhase2EncryptionName = "chacha20poly1305"
)

func NewIPsecPhase2EncryptionNameFromString(s string) (IPsecPhase2EncryptionName, error) {
	switch s {
	case "aes":
		return IPsecPhase2EncryptionNameAes, nil
	case "aes128gcm":
		return IPsecPhase2EncryptionNameAes128Gcm, nil
	case "aes192gcm":
		return IPsecPhase2EncryptionNameAes192Gcm, nil
	case "aes256gcm":
		return IPsecPhase2EncryptionNameAes256Gcm, nil
	case "chacha20poly1305":
		return IPsecPhase2EncryptionNameChacha20Poly1305, nil
	}
	var t IPsecPhase2EncryptionName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase2EncryptionName) Ptr() *IPsecPhase2EncryptionName {
	return &i
}

type IPsecPhase2HashAlgorithmOptionItem string

const (
	IPsecPhase2HashAlgorithmOptionItemHmacSha1   IPsecPhase2HashAlgorithmOptionItem = "hmac_sha1"
	IPsecPhase2HashAlgorithmOptionItemHmacSha256 IPsecPhase2HashAlgorithmOptionItem = "hmac_sha256"
	IPsecPhase2HashAlgorithmOptionItemHmacSha384 IPsecPhase2HashAlgorithmOptionItem = "hmac_sha384"
	IPsecPhase2HashAlgorithmOptionItemHmacSha512 IPsecPhase2HashAlgorithmOptionItem = "hmac_sha512"
	IPsecPhase2HashAlgorithmOptionItemAesxcbc    IPsecPhase2HashAlgorithmOptionItem = "aesxcbc"
)

func NewIPsecPhase2HashAlgorithmOptionItemFromString(s string) (IPsecPhase2HashAlgorithmOptionItem, error) {
	switch s {
	case "hmac_sha1":
		return IPsecPhase2HashAlgorithmOptionItemHmacSha1, nil
	case "hmac_sha256":
		return IPsecPhase2HashAlgorithmOptionItemHmacSha256, nil
	case "hmac_sha384":
		return IPsecPhase2HashAlgorithmOptionItemHmacSha384, nil
	case "hmac_sha512":
		return IPsecPhase2HashAlgorithmOptionItemHmacSha512, nil
	case "aesxcbc":
		return IPsecPhase2HashAlgorithmOptionItemAesxcbc, nil
	}
	var t IPsecPhase2HashAlgorithmOptionItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase2HashAlgorithmOptionItem) Ptr() *IPsecPhase2HashAlgorithmOptionItem {
	return &i
}

// The IPsec phase 2 mode this entry will use.<br>
type IPsecPhase2Mode string

const (
	IPsecPhase2ModeTunnel    IPsecPhase2Mode = "tunnel"
	IPsecPhase2ModeTunnel6   IPsecPhase2Mode = "tunnel6"
	IPsecPhase2ModeTransport IPsecPhase2Mode = "transport"
	IPsecPhase2ModeVti       IPsecPhase2Mode = "vti"
)

func NewIPsecPhase2ModeFromString(s string) (IPsecPhase2Mode, error) {
	switch s {
	case "tunnel":
		return IPsecPhase2ModeTunnel, nil
	case "tunnel6":
		return IPsecPhase2ModeTunnel6, nil
	case "transport":
		return IPsecPhase2ModeTransport, nil
	case "vti":
		return IPsecPhase2ModeVti, nil
	}
	var t IPsecPhase2Mode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase2Mode) Ptr() *IPsecPhase2Mode {
	return &i
}

// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
type IPsecPhase2Protocol string

const (
	IPsecPhase2ProtocolEsp IPsecPhase2Protocol = "esp"
	IPsecPhase2ProtocolAh  IPsecPhase2Protocol = "ah"
)

func NewIPsecPhase2ProtocolFromString(s string) (IPsecPhase2Protocol, error) {
	switch s {
	case "esp":
		return IPsecPhase2ProtocolEsp, nil
	case "ah":
		return IPsecPhase2ProtocolAh, nil
	}
	var t IPsecPhase2Protocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IPsecPhase2Protocol) Ptr() *IPsecPhase2Protocol {
	return &i
}

type OpenVpnClient struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OpenVpnClient) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenVpnClient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenVpnClient(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenVpnClient) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
type OpenVpnClientAllowCompression string

const (
	OpenVpnClientAllowCompressionNo   OpenVpnClientAllowCompression = "no"
	OpenVpnClientAllowCompressionYes  OpenVpnClientAllowCompression = "yes"
	OpenVpnClientAllowCompressionAsym OpenVpnClientAllowCompression = "asym"
)

func NewOpenVpnClientAllowCompressionFromString(s string) (OpenVpnClientAllowCompression, error) {
	switch s {
	case "no":
		return OpenVpnClientAllowCompressionNo, nil
	case "yes":
		return OpenVpnClientAllowCompressionYes, nil
	case "asym":
		return OpenVpnClientAllowCompressionAsym, nil
	}
	var t OpenVpnClientAllowCompression
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientAllowCompression) Ptr() *OpenVpnClientAllowCompression {
	return &o
}

// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
type OpenVpnClientCreateGw string

const (
	OpenVpnClientCreateGwBoth   OpenVpnClientCreateGw = "both"
	OpenVpnClientCreateGwV4Only OpenVpnClientCreateGw = "v4only"
	OpenVpnClientCreateGwV6Only OpenVpnClientCreateGw = "v6only"
)

func NewOpenVpnClientCreateGwFromString(s string) (OpenVpnClientCreateGw, error) {
	switch s {
	case "both":
		return OpenVpnClientCreateGwBoth, nil
	case "v4only":
		return OpenVpnClientCreateGwV4Only, nil
	case "v6only":
		return OpenVpnClientCreateGwV6Only, nil
	}
	var t OpenVpnClientCreateGw
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientCreateGw) Ptr() *OpenVpnClientCreateGw {
	return &o
}

// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
type OpenVpnClientDevMode string

const (
	OpenVpnClientDevModeTun OpenVpnClientDevMode = "tun"
	OpenVpnClientDevModeTap OpenVpnClientDevMode = "tap"
)

func NewOpenVpnClientDevModeFromString(s string) (OpenVpnClientDevMode, error) {
	switch s {
	case "tun":
		return OpenVpnClientDevModeTun, nil
	case "tap":
		return OpenVpnClientDevModeTap, nil
	}
	var t OpenVpnClientDevMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientDevMode) Ptr() *OpenVpnClientDevMode {
	return &o
}

// The number of times this client will attempt to send an exit notifications.<br>
type OpenVpnClientExitNotify string

const (
	OpenVpnClientExitNotifyValue1 OpenVpnClientExitNotify = "value_1"
	OpenVpnClientExitNotifyValue2 OpenVpnClientExitNotify = "value_2"
	OpenVpnClientExitNotifyValue3 OpenVpnClientExitNotify = "value_3"
	OpenVpnClientExitNotifyValue4 OpenVpnClientExitNotify = "value_4"
	OpenVpnClientExitNotifyValue5 OpenVpnClientExitNotify = "value_5"
	OpenVpnClientExitNotifyNone   OpenVpnClientExitNotify = "none"
)

func NewOpenVpnClientExitNotifyFromString(s string) (OpenVpnClientExitNotify, error) {
	switch s {
	case "value_1":
		return OpenVpnClientExitNotifyValue1, nil
	case "value_2":
		return OpenVpnClientExitNotifyValue2, nil
	case "value_3":
		return OpenVpnClientExitNotifyValue3, nil
	case "value_4":
		return OpenVpnClientExitNotifyValue4, nil
	case "value_5":
		return OpenVpnClientExitNotifyValue5, nil
	case "none":
		return OpenVpnClientExitNotifyNone, nil
	}
	var t OpenVpnClientExitNotify
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExitNotify) Ptr() *OpenVpnClientExitNotify {
	return &o
}

type OpenVpnClientExport struct {
	// The type of OpenVPN client export to generate. This determines the format and content of the export file.<br>
	Type *OpenVpnClientExportType `json:"type,omitempty"`
	// The reference ID of the certificate to use for this OpenVPN client export. This is only applicable for OpenVPN servers that require client certificates.<br>
	Certref *string `json:"certref,omitempty"`
	// The username of the user this client export corresponds to. This is only applicable for OpenVPN servers that use the Local Database AND client certificates.<br>
	Username *string `json:"username,omitempty"`
	// The filename used when exporting the OpenVPN client export. This value cannot be changed<br>
	Filename *string `json:"filename,omitempty"`
	// The binary data of the OpenVPN client export. This is used to store the actual exported configuration file content. When the content-type is set to "application/octet-stream", this field will contain the data of the OpenVPN client export download.<br>
	BinaryData *string `json:"binary_data,omitempty"`
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OpenVpnClientExport) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenVpnClientExport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenVpnClientExport(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenVpnClientExport) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
type OpenVpnClientExportBindmode string

const (
	OpenVpnClientExportBindmodeNobind OpenVpnClientExportBindmode = "nobind"
	OpenVpnClientExportBindmodeLport0 OpenVpnClientExportBindmode = "lport0"
	OpenVpnClientExportBindmodeBind   OpenVpnClientExportBindmode = "bind"
)

func NewOpenVpnClientExportBindmodeFromString(s string) (OpenVpnClientExportBindmode, error) {
	switch s {
	case "nobind":
		return OpenVpnClientExportBindmodeNobind, nil
	case "lport0":
		return OpenVpnClientExportBindmodeLport0, nil
	case "bind":
		return OpenVpnClientExportBindmodeBind, nil
	}
	var t OpenVpnClientExportBindmode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportBindmode) Ptr() *OpenVpnClientExportBindmode {
	return &o
}

type OpenVpnClientExportConfig struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OpenVpnClientExportConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenVpnClientExportConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenVpnClientExportConfig(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenVpnClientExportConfig) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
type OpenVpnClientExportConfigBindmode string

const (
	OpenVpnClientExportConfigBindmodeNobind OpenVpnClientExportConfigBindmode = "nobind"
	OpenVpnClientExportConfigBindmodeLport0 OpenVpnClientExportConfigBindmode = "lport0"
	OpenVpnClientExportConfigBindmodeBind   OpenVpnClientExportConfigBindmode = "bind"
)

func NewOpenVpnClientExportConfigBindmodeFromString(s string) (OpenVpnClientExportConfigBindmode, error) {
	switch s {
	case "nobind":
		return OpenVpnClientExportConfigBindmodeNobind, nil
	case "lport0":
		return OpenVpnClientExportConfigBindmodeLport0, nil
	case "bind":
		return OpenVpnClientExportConfigBindmodeBind, nil
	}
	var t OpenVpnClientExportConfigBindmode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportConfigBindmode) Ptr() *OpenVpnClientExportConfigBindmode {
	return &o
}

// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
type OpenVpnClientExportConfigP12Encryption string

const (
	OpenVpnClientExportConfigP12EncryptionHigh   OpenVpnClientExportConfigP12Encryption = "high"
	OpenVpnClientExportConfigP12EncryptionLow    OpenVpnClientExportConfigP12Encryption = "low"
	OpenVpnClientExportConfigP12EncryptionLegacy OpenVpnClientExportConfigP12Encryption = "legacy"
)

func NewOpenVpnClientExportConfigP12EncryptionFromString(s string) (OpenVpnClientExportConfigP12Encryption, error) {
	switch s {
	case "high":
		return OpenVpnClientExportConfigP12EncryptionHigh, nil
	case "low":
		return OpenVpnClientExportConfigP12EncryptionLow, nil
	case "legacy":
		return OpenVpnClientExportConfigP12EncryptionLegacy, nil
	}
	var t OpenVpnClientExportConfigP12Encryption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportConfigP12Encryption) Ptr() *OpenVpnClientExportConfigP12Encryption {
	return &o
}

// The method to use for the OpenVPN server address listed in the config export.<br>
type OpenVpnClientExportConfigUseaddr string

const (
	OpenVpnClientExportConfigUseaddrServeraddr      OpenVpnClientExportConfigUseaddr = "serveraddr"
	OpenVpnClientExportConfigUseaddrServermagic     OpenVpnClientExportConfigUseaddr = "servermagic"
	OpenVpnClientExportConfigUseaddrServermagichost OpenVpnClientExportConfigUseaddr = "servermagichost"
	OpenVpnClientExportConfigUseaddrServerhostname  OpenVpnClientExportConfigUseaddr = "serverhostname"
	OpenVpnClientExportConfigUseaddrOther           OpenVpnClientExportConfigUseaddr = "other"
)

func NewOpenVpnClientExportConfigUseaddrFromString(s string) (OpenVpnClientExportConfigUseaddr, error) {
	switch s {
	case "serveraddr":
		return OpenVpnClientExportConfigUseaddrServeraddr, nil
	case "servermagic":
		return OpenVpnClientExportConfigUseaddrServermagic, nil
	case "servermagichost":
		return OpenVpnClientExportConfigUseaddrServermagichost, nil
	case "serverhostname":
		return OpenVpnClientExportConfigUseaddrServerhostname, nil
	case "other":
		return OpenVpnClientExportConfigUseaddrOther, nil
	}
	var t OpenVpnClientExportConfigUseaddr
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportConfigUseaddr) Ptr() *OpenVpnClientExportConfigUseaddr {
	return &o
}

// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
type OpenVpnClientExportConfigUseproxypass string

const (
	OpenVpnClientExportConfigUseproxypassNone  OpenVpnClientExportConfigUseproxypass = "none"
	OpenVpnClientExportConfigUseproxypassBasic OpenVpnClientExportConfigUseproxypass = "basic"
	OpenVpnClientExportConfigUseproxypassNtlm  OpenVpnClientExportConfigUseproxypass = "ntlm"
)

func NewOpenVpnClientExportConfigUseproxypassFromString(s string) (OpenVpnClientExportConfigUseproxypass, error) {
	switch s {
	case "none":
		return OpenVpnClientExportConfigUseproxypassNone, nil
	case "basic":
		return OpenVpnClientExportConfigUseproxypassBasic, nil
	case "ntlm":
		return OpenVpnClientExportConfigUseproxypassNtlm, nil
	}
	var t OpenVpnClientExportConfigUseproxypass
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportConfigUseproxypass) Ptr() *OpenVpnClientExportConfigUseproxypass {
	return &o
}

// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
type OpenVpnClientExportConfigUseproxytype string

const (
	OpenVpnClientExportConfigUseproxytypeHTTP  OpenVpnClientExportConfigUseproxytype = "http"
	OpenVpnClientExportConfigUseproxytypeSocks OpenVpnClientExportConfigUseproxytype = "socks"
)

func NewOpenVpnClientExportConfigUseproxytypeFromString(s string) (OpenVpnClientExportConfigUseproxytype, error) {
	switch s {
	case "http":
		return OpenVpnClientExportConfigUseproxytypeHTTP, nil
	case "socks":
		return OpenVpnClientExportConfigUseproxytypeSocks, nil
	}
	var t OpenVpnClientExportConfigUseproxytype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportConfigUseproxytype) Ptr() *OpenVpnClientExportConfigUseproxytype {
	return &o
}

// Verify the server certificate Common Name (CN) when the client connects.<br>
type OpenVpnClientExportConfigVerifyservercn string

const (
	OpenVpnClientExportConfigVerifyservercnAuto OpenVpnClientExportConfigVerifyservercn = "auto"
	OpenVpnClientExportConfigVerifyservercnNone OpenVpnClientExportConfigVerifyservercn = "none"
)

func NewOpenVpnClientExportConfigVerifyservercnFromString(s string) (OpenVpnClientExportConfigVerifyservercn, error) {
	switch s {
	case "auto":
		return OpenVpnClientExportConfigVerifyservercnAuto, nil
	case "none":
		return OpenVpnClientExportConfigVerifyservercnNone, nil
	}
	var t OpenVpnClientExportConfigVerifyservercn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportConfigVerifyservercn) Ptr() *OpenVpnClientExportConfigVerifyservercn {
	return &o
}

// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
type OpenVpnClientExportP12Encryption string

const (
	OpenVpnClientExportP12EncryptionHigh   OpenVpnClientExportP12Encryption = "high"
	OpenVpnClientExportP12EncryptionLow    OpenVpnClientExportP12Encryption = "low"
	OpenVpnClientExportP12EncryptionLegacy OpenVpnClientExportP12Encryption = "legacy"
)

func NewOpenVpnClientExportP12EncryptionFromString(s string) (OpenVpnClientExportP12Encryption, error) {
	switch s {
	case "high":
		return OpenVpnClientExportP12EncryptionHigh, nil
	case "low":
		return OpenVpnClientExportP12EncryptionLow, nil
	case "legacy":
		return OpenVpnClientExportP12EncryptionLegacy, nil
	}
	var t OpenVpnClientExportP12Encryption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportP12Encryption) Ptr() *OpenVpnClientExportP12Encryption {
	return &o
}

// The type of OpenVPN client export to generate. This determines the format and content of the export file.<br>
type OpenVpnClientExportType string

const (
	OpenVpnClientExportTypeConfzip           OpenVpnClientExportType = "confzip"
	OpenVpnClientExportTypeConfYealinkT28    OpenVpnClientExportType = "conf_yealink_t28"
	OpenVpnClientExportTypeConfYealinkT38G   OpenVpnClientExportType = "conf_yealink_t38g"
	OpenVpnClientExportTypeConfYealinkT38G2  OpenVpnClientExportType = "conf_yealink_t38g2"
	OpenVpnClientExportTypeConfSnom          OpenVpnClientExportType = "conf_snom"
	OpenVpnClientExportTypeConfinline        OpenVpnClientExportType = "confinline"
	OpenVpnClientExportTypeConfinlinedroid   OpenVpnClientExportType = "confinlinedroid"
	OpenVpnClientExportTypeConfinlineconnect OpenVpnClientExportType = "confinlineconnect"
	OpenVpnClientExportTypeConfinlinevisc    OpenVpnClientExportType = "confinlinevisc"
	OpenVpnClientExportTypeInstWin7          OpenVpnClientExportType = "inst-Win7"
	OpenVpnClientExportTypeInstWin10         OpenVpnClientExportType = "inst-Win10"
	OpenVpnClientExportTypeInstX86Previous   OpenVpnClientExportType = "inst-x86-previous"
	OpenVpnClientExportTypeInstX64Previous   OpenVpnClientExportType = "inst-x64-previous"
	OpenVpnClientExportTypeInstX86Current    OpenVpnClientExportType = "inst-x86-current"
	OpenVpnClientExportTypeInstX64Current    OpenVpnClientExportType = "inst-x64-current"
	OpenVpnClientExportTypeVisc              OpenVpnClientExportType = "visc"
)

func NewOpenVpnClientExportTypeFromString(s string) (OpenVpnClientExportType, error) {
	switch s {
	case "confzip":
		return OpenVpnClientExportTypeConfzip, nil
	case "conf_yealink_t28":
		return OpenVpnClientExportTypeConfYealinkT28, nil
	case "conf_yealink_t38g":
		return OpenVpnClientExportTypeConfYealinkT38G, nil
	case "conf_yealink_t38g2":
		return OpenVpnClientExportTypeConfYealinkT38G2, nil
	case "conf_snom":
		return OpenVpnClientExportTypeConfSnom, nil
	case "confinline":
		return OpenVpnClientExportTypeConfinline, nil
	case "confinlinedroid":
		return OpenVpnClientExportTypeConfinlinedroid, nil
	case "confinlineconnect":
		return OpenVpnClientExportTypeConfinlineconnect, nil
	case "confinlinevisc":
		return OpenVpnClientExportTypeConfinlinevisc, nil
	case "inst-Win7":
		return OpenVpnClientExportTypeInstWin7, nil
	case "inst-Win10":
		return OpenVpnClientExportTypeInstWin10, nil
	case "inst-x86-previous":
		return OpenVpnClientExportTypeInstX86Previous, nil
	case "inst-x64-previous":
		return OpenVpnClientExportTypeInstX64Previous, nil
	case "inst-x86-current":
		return OpenVpnClientExportTypeInstX86Current, nil
	case "inst-x64-current":
		return OpenVpnClientExportTypeInstX64Current, nil
	case "visc":
		return OpenVpnClientExportTypeVisc, nil
	}
	var t OpenVpnClientExportType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportType) Ptr() *OpenVpnClientExportType {
	return &o
}

// The method to use for the OpenVPN server address listed in the config export.<br>
type OpenVpnClientExportUseaddr string

const (
	OpenVpnClientExportUseaddrServeraddr      OpenVpnClientExportUseaddr = "serveraddr"
	OpenVpnClientExportUseaddrServermagic     OpenVpnClientExportUseaddr = "servermagic"
	OpenVpnClientExportUseaddrServermagichost OpenVpnClientExportUseaddr = "servermagichost"
	OpenVpnClientExportUseaddrServerhostname  OpenVpnClientExportUseaddr = "serverhostname"
	OpenVpnClientExportUseaddrOther           OpenVpnClientExportUseaddr = "other"
)

func NewOpenVpnClientExportUseaddrFromString(s string) (OpenVpnClientExportUseaddr, error) {
	switch s {
	case "serveraddr":
		return OpenVpnClientExportUseaddrServeraddr, nil
	case "servermagic":
		return OpenVpnClientExportUseaddrServermagic, nil
	case "servermagichost":
		return OpenVpnClientExportUseaddrServermagichost, nil
	case "serverhostname":
		return OpenVpnClientExportUseaddrServerhostname, nil
	case "other":
		return OpenVpnClientExportUseaddrOther, nil
	}
	var t OpenVpnClientExportUseaddr
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportUseaddr) Ptr() *OpenVpnClientExportUseaddr {
	return &o
}

// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
type OpenVpnClientExportUseproxypass string

const (
	OpenVpnClientExportUseproxypassNone  OpenVpnClientExportUseproxypass = "none"
	OpenVpnClientExportUseproxypassBasic OpenVpnClientExportUseproxypass = "basic"
	OpenVpnClientExportUseproxypassNtlm  OpenVpnClientExportUseproxypass = "ntlm"
)

func NewOpenVpnClientExportUseproxypassFromString(s string) (OpenVpnClientExportUseproxypass, error) {
	switch s {
	case "none":
		return OpenVpnClientExportUseproxypassNone, nil
	case "basic":
		return OpenVpnClientExportUseproxypassBasic, nil
	case "ntlm":
		return OpenVpnClientExportUseproxypassNtlm, nil
	}
	var t OpenVpnClientExportUseproxypass
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportUseproxypass) Ptr() *OpenVpnClientExportUseproxypass {
	return &o
}

// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
type OpenVpnClientExportUseproxytype string

const (
	OpenVpnClientExportUseproxytypeHTTP  OpenVpnClientExportUseproxytype = "http"
	OpenVpnClientExportUseproxytypeSocks OpenVpnClientExportUseproxytype = "socks"
)

func NewOpenVpnClientExportUseproxytypeFromString(s string) (OpenVpnClientExportUseproxytype, error) {
	switch s {
	case "http":
		return OpenVpnClientExportUseproxytypeHTTP, nil
	case "socks":
		return OpenVpnClientExportUseproxytypeSocks, nil
	}
	var t OpenVpnClientExportUseproxytype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportUseproxytype) Ptr() *OpenVpnClientExportUseproxytype {
	return &o
}

// Verify the server certificate Common Name (CN) when the client connects.<br>
type OpenVpnClientExportVerifyservercn string

const (
	OpenVpnClientExportVerifyservercnAuto OpenVpnClientExportVerifyservercn = "auto"
	OpenVpnClientExportVerifyservercnNone OpenVpnClientExportVerifyservercn = "none"
)

func NewOpenVpnClientExportVerifyservercnFromString(s string) (OpenVpnClientExportVerifyservercn, error) {
	switch s {
	case "auto":
		return OpenVpnClientExportVerifyservercnAuto, nil
	case "none":
		return OpenVpnClientExportVerifyservercnNone, nil
	}
	var t OpenVpnClientExportVerifyservercn
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientExportVerifyservercn) Ptr() *OpenVpnClientExportVerifyservercn {
	return &o
}

// The OpenVPN client mode.<br>
type OpenVpnClientMode string

const (
	OpenVpnClientModeP2PTLS OpenVpnClientMode = "p2p_tls"
)

func NewOpenVpnClientModeFromString(s string) (OpenVpnClientMode, error) {
	switch s {
	case "p2p_tls":
		return OpenVpnClientModeP2PTLS, nil
	}
	var t OpenVpnClientMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientMode) Ptr() *OpenVpnClientMode {
	return &o
}

// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
type OpenVpnClientPingAction string

const (
	OpenVpnClientPingActionPingRestart OpenVpnClientPingAction = "ping_restart"
	OpenVpnClientPingActionPingExit    OpenVpnClientPingAction = "ping_exit"
)

func NewOpenVpnClientPingActionFromString(s string) (OpenVpnClientPingAction, error) {
	switch s {
	case "ping_restart":
		return OpenVpnClientPingActionPingRestart, nil
	case "ping_exit":
		return OpenVpnClientPingActionPingExit, nil
	}
	var t OpenVpnClientPingAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientPingAction) Ptr() *OpenVpnClientPingAction {
	return &o
}

// The method used to define ping configuration.<br>
type OpenVpnClientPingMethod string

const (
	OpenVpnClientPingMethodKeepalive OpenVpnClientPingMethod = "keepalive"
	OpenVpnClientPingMethodPing      OpenVpnClientPingMethod = "ping"
)

func NewOpenVpnClientPingMethodFromString(s string) (OpenVpnClientPingMethod, error) {
	switch s {
	case "keepalive":
		return OpenVpnClientPingMethodKeepalive, nil
	case "ping":
		return OpenVpnClientPingMethodPing, nil
	}
	var t OpenVpnClientPingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientPingMethod) Ptr() *OpenVpnClientPingMethod {
	return &o
}

// The protocol used by this OpenVPN client.<br>
type OpenVpnClientProtocol string

const (
	OpenVpnClientProtocolUDP4 OpenVpnClientProtocol = "UDP4"
	OpenVpnClientProtocolUDP6 OpenVpnClientProtocol = "UDP6"
	OpenVpnClientProtocolUDP  OpenVpnClientProtocol = "UDP"
	OpenVpnClientProtocolTCP4 OpenVpnClientProtocol = "TCP4"
	OpenVpnClientProtocolTCP6 OpenVpnClientProtocol = "TCP6"
	OpenVpnClientProtocolTCP  OpenVpnClientProtocol = "TCP"
)

func NewOpenVpnClientProtocolFromString(s string) (OpenVpnClientProtocol, error) {
	switch s {
	case "UDP4":
		return OpenVpnClientProtocolUDP4, nil
	case "UDP6":
		return OpenVpnClientProtocolUDP6, nil
	case "UDP":
		return OpenVpnClientProtocolUDP, nil
	case "TCP4":
		return OpenVpnClientProtocolTCP4, nil
	case "TCP6":
		return OpenVpnClientProtocolTCP6, nil
	case "TCP":
		return OpenVpnClientProtocolTCP, nil
	}
	var t OpenVpnClientProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientProtocol) Ptr() *OpenVpnClientProtocol {
	return &o
}

// The type of authentication used by the proxy server.<br>
type OpenVpnClientProxyAuthtype string

const (
	OpenVpnClientProxyAuthtypeNone  OpenVpnClientProxyAuthtype = "none"
	OpenVpnClientProxyAuthtypeBasic OpenVpnClientProxyAuthtype = "basic"
	OpenVpnClientProxyAuthtypeNtlm  OpenVpnClientProxyAuthtype = "ntlm"
)

func NewOpenVpnClientProxyAuthtypeFromString(s string) (OpenVpnClientProxyAuthtype, error) {
	switch s {
	case "none":
		return OpenVpnClientProxyAuthtypeNone, nil
	case "basic":
		return OpenVpnClientProxyAuthtypeBasic, nil
	case "ntlm":
		return OpenVpnClientProxyAuthtypeNtlm, nil
	}
	var t OpenVpnClientProxyAuthtype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientProxyAuthtype) Ptr() *OpenVpnClientProxyAuthtype {
	return &o
}

type OpenVpnClientSpecificOverride struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OpenVpnClientSpecificOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenVpnClientSpecificOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenVpnClientSpecificOverride(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenVpnClientSpecificOverride) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OpenVpnClientSpecificOverrideRemoveOptionsItem string

const (
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveRoute           OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_route"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveIroute          OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_iroute"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveRedirectGateway OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_redirect_gateway"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveInactive        OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_inactive"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemovePing            OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_ping"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemovePingAction      OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_ping_action"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveDnsdomain       OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_dnsdomain"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveDnsservers      OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_dnsservers"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveBlockoutsidedns OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_blockoutsidedns"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveNtpservers      OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_ntpservers"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveNetbiosNtype    OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_netbios_ntype"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveNetbiosScope    OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_netbios_scope"
	OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveWins            OpenVpnClientSpecificOverrideRemoveOptionsItem = "remove_wins"
)

func NewOpenVpnClientSpecificOverrideRemoveOptionsItemFromString(s string) (OpenVpnClientSpecificOverrideRemoveOptionsItem, error) {
	switch s {
	case "remove_route":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveRoute, nil
	case "remove_iroute":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveIroute, nil
	case "remove_redirect_gateway":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveRedirectGateway, nil
	case "remove_inactive":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveInactive, nil
	case "remove_ping":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemovePing, nil
	case "remove_ping_action":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemovePingAction, nil
	case "remove_dnsdomain":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveDnsdomain, nil
	case "remove_dnsservers":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveDnsservers, nil
	case "remove_blockoutsidedns":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveBlockoutsidedns, nil
	case "remove_ntpservers":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveNtpservers, nil
	case "remove_netbios_ntype":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveNetbiosNtype, nil
	case "remove_netbios_scope":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveNetbiosScope, nil
	case "remove_wins":
		return OpenVpnClientSpecificOverrideRemoveOptionsItemRemoveWins, nil
	}
	var t OpenVpnClientSpecificOverrideRemoveOptionsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientSpecificOverrideRemoveOptionsItem) Ptr() *OpenVpnClientSpecificOverrideRemoveOptionsItem {
	return &o
}

// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
type OpenVpnClientTLSType string

const (
	OpenVpnClientTLSTypeAuth  OpenVpnClientTLSType = "auth"
	OpenVpnClientTLSTypeCrypt OpenVpnClientTLSType = "crypt"
)

func NewOpenVpnClientTLSTypeFromString(s string) (OpenVpnClientTLSType, error) {
	switch s {
	case "auth":
		return OpenVpnClientTLSTypeAuth, nil
	case "crypt":
		return OpenVpnClientTLSTypeCrypt, nil
	}
	var t OpenVpnClientTLSType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientTLSType) Ptr() *OpenVpnClientTLSType {
	return &o
}

// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
type OpenVpnClientTlsauthKeydir string

const (
	OpenVpnClientTlsauthKeydirDefault OpenVpnClientTlsauthKeydir = "default"
	OpenVpnClientTlsauthKeydirValue0  OpenVpnClientTlsauthKeydir = "value_0"
	OpenVpnClientTlsauthKeydirValue1  OpenVpnClientTlsauthKeydir = "value_1"
	OpenVpnClientTlsauthKeydirValue2  OpenVpnClientTlsauthKeydir = "value_2"
)

func NewOpenVpnClientTlsauthKeydirFromString(s string) (OpenVpnClientTlsauthKeydir, error) {
	switch s {
	case "default":
		return OpenVpnClientTlsauthKeydirDefault, nil
	case "value_0":
		return OpenVpnClientTlsauthKeydirValue0, nil
	case "value_1":
		return OpenVpnClientTlsauthKeydirValue1, nil
	case "value_2":
		return OpenVpnClientTlsauthKeydirValue2, nil
	}
	var t OpenVpnClientTlsauthKeydir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientTlsauthKeydir) Ptr() *OpenVpnClientTlsauthKeydir {
	return &o
}

// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
type OpenVpnClientTopology string

const (
	OpenVpnClientTopologySubnet OpenVpnClientTopology = "subnet"
	OpenVpnClientTopologyNet30  OpenVpnClientTopology = "net30"
)

func NewOpenVpnClientTopologyFromString(s string) (OpenVpnClientTopology, error) {
	switch s {
	case "subnet":
		return OpenVpnClientTopologySubnet, nil
	case "net30":
		return OpenVpnClientTopologyNet30, nil
	}
	var t OpenVpnClientTopology
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnClientTopology) Ptr() *OpenVpnClientTopology {
	return &o
}

type OpenVpnServer struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OpenVpnServer) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenVpnServer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenVpnServer(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenVpnServer) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
type OpenVpnServerAllowCompression string

const (
	OpenVpnServerAllowCompressionNo   OpenVpnServerAllowCompression = "no"
	OpenVpnServerAllowCompressionYes  OpenVpnServerAllowCompression = "yes"
	OpenVpnServerAllowCompressionAsym OpenVpnServerAllowCompression = "asym"
)

func NewOpenVpnServerAllowCompressionFromString(s string) (OpenVpnServerAllowCompression, error) {
	switch s {
	case "no":
		return OpenVpnServerAllowCompressionNo, nil
	case "yes":
		return OpenVpnServerAllowCompressionYes, nil
	case "asym":
		return OpenVpnServerAllowCompressionAsym, nil
	}
	var t OpenVpnServerAllowCompression
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerAllowCompression) Ptr() *OpenVpnServerAllowCompression {
	return &o
}

// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
type OpenVpnServerCreateGw string

const (
	OpenVpnServerCreateGwBoth   OpenVpnServerCreateGw = "both"
	OpenVpnServerCreateGwV4Only OpenVpnServerCreateGw = "v4only"
	OpenVpnServerCreateGwV6Only OpenVpnServerCreateGw = "v6only"
)

func NewOpenVpnServerCreateGwFromString(s string) (OpenVpnServerCreateGw, error) {
	switch s {
	case "both":
		return OpenVpnServerCreateGwBoth, nil
	case "v4only":
		return OpenVpnServerCreateGwV4Only, nil
	case "v6only":
		return OpenVpnServerCreateGwV6Only, nil
	}
	var t OpenVpnServerCreateGw
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerCreateGw) Ptr() *OpenVpnServerCreateGw {
	return &o
}

// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
type OpenVpnServerDevMode string

const (
	OpenVpnServerDevModeTun OpenVpnServerDevMode = "tun"
	OpenVpnServerDevModeTap OpenVpnServerDevMode = "tap"
)

func NewOpenVpnServerDevModeFromString(s string) (OpenVpnServerDevMode, error) {
	switch s {
	case "tun":
		return OpenVpnServerDevModeTun, nil
	case "tap":
		return OpenVpnServerDevModeTap, nil
	}
	var t OpenVpnServerDevMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerDevMode) Ptr() *OpenVpnServerDevMode {
	return &o
}

// The OpenVPN server mode.<br>
type OpenVpnServerMode string

const (
	OpenVpnServerModeP2PTLS        OpenVpnServerMode = "p2p_tls"
	OpenVpnServerModeServerTLS     OpenVpnServerMode = "server_tls"
	OpenVpnServerModeServerUser    OpenVpnServerMode = "server_user"
	OpenVpnServerModeServerTLSUser OpenVpnServerMode = "server_tls_user"
)

func NewOpenVpnServerModeFromString(s string) (OpenVpnServerMode, error) {
	switch s {
	case "p2p_tls":
		return OpenVpnServerModeP2PTLS, nil
	case "server_tls":
		return OpenVpnServerModeServerTLS, nil
	case "server_user":
		return OpenVpnServerModeServerUser, nil
	case "server_tls_user":
		return OpenVpnServerModeServerTLSUser, nil
	}
	var t OpenVpnServerMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerMode) Ptr() *OpenVpnServerMode {
	return &o
}

// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
type OpenVpnServerPingAction string

const (
	OpenVpnServerPingActionPingRestart OpenVpnServerPingAction = "ping_restart"
	OpenVpnServerPingActionPingExit    OpenVpnServerPingAction = "ping_exit"
)

func NewOpenVpnServerPingActionFromString(s string) (OpenVpnServerPingAction, error) {
	switch s {
	case "ping_restart":
		return OpenVpnServerPingActionPingRestart, nil
	case "ping_exit":
		return OpenVpnServerPingActionPingExit, nil
	}
	var t OpenVpnServerPingAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerPingAction) Ptr() *OpenVpnServerPingAction {
	return &o
}

// The method used to define ping configuration.<br>
type OpenVpnServerPingMethod string

const (
	OpenVpnServerPingMethodKeepalive OpenVpnServerPingMethod = "keepalive"
	OpenVpnServerPingMethodPing      OpenVpnServerPingMethod = "ping"
)

func NewOpenVpnServerPingMethodFromString(s string) (OpenVpnServerPingMethod, error) {
	switch s {
	case "keepalive":
		return OpenVpnServerPingMethodKeepalive, nil
	case "ping":
		return OpenVpnServerPingMethodPing, nil
	}
	var t OpenVpnServerPingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerPingMethod) Ptr() *OpenVpnServerPingMethod {
	return &o
}

// The protocol used by this OpenVPN server.<br>
type OpenVpnServerProtocol string

const (
	OpenVpnServerProtocolUDP4 OpenVpnServerProtocol = "UDP4"
	OpenVpnServerProtocolUDP6 OpenVpnServerProtocol = "UDP6"
	OpenVpnServerProtocolUDP  OpenVpnServerProtocol = "UDP"
	OpenVpnServerProtocolTCP4 OpenVpnServerProtocol = "TCP4"
	OpenVpnServerProtocolTCP6 OpenVpnServerProtocol = "TCP6"
	OpenVpnServerProtocolTCP  OpenVpnServerProtocol = "TCP"
)

func NewOpenVpnServerProtocolFromString(s string) (OpenVpnServerProtocol, error) {
	switch s {
	case "UDP4":
		return OpenVpnServerProtocolUDP4, nil
	case "UDP6":
		return OpenVpnServerProtocolUDP6, nil
	case "UDP":
		return OpenVpnServerProtocolUDP, nil
	case "TCP4":
		return OpenVpnServerProtocolTCP4, nil
	case "TCP6":
		return OpenVpnServerProtocolTCP6, nil
	case "TCP":
		return OpenVpnServerProtocolTCP, nil
	}
	var t OpenVpnServerProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerProtocol) Ptr() *OpenVpnServerProtocol {
	return &o
}

// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
type OpenVpnServerTLSType string

const (
	OpenVpnServerTLSTypeAuth  OpenVpnServerTLSType = "auth"
	OpenVpnServerTLSTypeCrypt OpenVpnServerTLSType = "crypt"
)

func NewOpenVpnServerTLSTypeFromString(s string) (OpenVpnServerTLSType, error) {
	switch s {
	case "auth":
		return OpenVpnServerTLSTypeAuth, nil
	case "crypt":
		return OpenVpnServerTLSTypeCrypt, nil
	}
	var t OpenVpnServerTLSType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerTLSType) Ptr() *OpenVpnServerTLSType {
	return &o
}

// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
type OpenVpnServerTlsauthKeydir string

const (
	OpenVpnServerTlsauthKeydirDefault OpenVpnServerTlsauthKeydir = "default"
	OpenVpnServerTlsauthKeydirValue0  OpenVpnServerTlsauthKeydir = "value_0"
	OpenVpnServerTlsauthKeydirValue1  OpenVpnServerTlsauthKeydir = "value_1"
	OpenVpnServerTlsauthKeydirValue2  OpenVpnServerTlsauthKeydir = "value_2"
)

func NewOpenVpnServerTlsauthKeydirFromString(s string) (OpenVpnServerTlsauthKeydir, error) {
	switch s {
	case "default":
		return OpenVpnServerTlsauthKeydirDefault, nil
	case "value_0":
		return OpenVpnServerTlsauthKeydirValue0, nil
	case "value_1":
		return OpenVpnServerTlsauthKeydirValue1, nil
	case "value_2":
		return OpenVpnServerTlsauthKeydirValue2, nil
	}
	var t OpenVpnServerTlsauthKeydir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerTlsauthKeydir) Ptr() *OpenVpnServerTlsauthKeydir {
	return &o
}

// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
type OpenVpnServerTopology string

const (
	OpenVpnServerTopologySubnet OpenVpnServerTopology = "subnet"
	OpenVpnServerTopologyNet30  OpenVpnServerTopology = "net30"
)

func NewOpenVpnServerTopologyFromString(s string) (OpenVpnServerTopology, error) {
	switch s {
	case "subnet":
		return OpenVpnServerTopologySubnet, nil
	case "net30":
		return OpenVpnServerTopologyNet30, nil
	}
	var t OpenVpnServerTopology
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OpenVpnServerTopology) Ptr() *OpenVpnServerTopology {
	return &o
}

type WireGuardApply struct {
	// Displays `true` when all WireGuard changes are applied and there are no pending changes left.Displays `false` when there are pending WireGuard changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardApply) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardApply(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardApply) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WireGuardPeer struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardPeer) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardPeer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardPeer(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardPeer) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WireGuardPeerAllowedIP struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardPeerAllowedIP) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardPeerAllowedIP
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardPeerAllowedIP(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardPeerAllowedIP) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WireGuardPeerAllowedipsItem struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardPeerAllowedipsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardPeerAllowedipsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardPeerAllowedipsItem(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardPeerAllowedipsItem) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WireGuardSettings struct {
	// Enables or disables WireGuard on this system. WireGuard cannot be disabled when one or more tunnels is assigned to a pfSense interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// Enables or disables keeping the WireGuard configuration when the package is uninstalled/reinstalled.<br>
	KeepConf *bool `json:"keep_conf,omitempty"`
	// Enables or disables tracking the 'Aliases Hostnames Resolve Interval' value as the `resolve_internal` value instead of specifying a value directly.<br>
	ResolveIntervalTrack *bool `json:"resolve_interval_track,omitempty"`
	// The interval (in seconds) for re-resolving endpoint host/domain names.<br><br>This field is only available when the following conditions are met:<br>- `resolve_interval_track` must be equal to `false`<br>
	ResolveInterval *int `json:"resolve_interval,omitempty"`
	// Configures which WireGuard tunnels are members of the WireGuard interface group.<br>
	InterfaceGroup *WireGuardSettingsInterfaceGroup `json:"interface_group,omitempty"`
	// Enables or disables hiding all secrets (private and pre-shared keys) in the user interface.<br>
	HideSecrets *bool `json:"hide_secrets,omitempty"`
	// Enables or disables initially hiding all peers in the user interface.<br>
	HidePeers *bool `json:"hide_peers,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardSettings(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardSettings) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Configures which WireGuard tunnels are members of the WireGuard interface group.<br>
type WireGuardSettingsInterfaceGroup string

const (
	WireGuardSettingsInterfaceGroupAll        WireGuardSettingsInterfaceGroup = "all"
	WireGuardSettingsInterfaceGroupUnassigned WireGuardSettingsInterfaceGroup = "unassigned"
	WireGuardSettingsInterfaceGroupNone       WireGuardSettingsInterfaceGroup = "none"
)

func NewWireGuardSettingsInterfaceGroupFromString(s string) (WireGuardSettingsInterfaceGroup, error) {
	switch s {
	case "all":
		return WireGuardSettingsInterfaceGroupAll, nil
	case "unassigned":
		return WireGuardSettingsInterfaceGroupUnassigned, nil
	case "none":
		return WireGuardSettingsInterfaceGroupNone, nil
	}
	var t WireGuardSettingsInterfaceGroup
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WireGuardSettingsInterfaceGroup) Ptr() *WireGuardSettingsInterfaceGroup {
	return &w
}

type WireGuardTunnel struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardTunnel) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardTunnel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardTunnel(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardTunnel) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WireGuardTunnelAddress struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardTunnelAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardTunnelAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardTunnelAddress(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardTunnelAddress) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WireGuardTunnelAddressesItem struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WireGuardTunnelAddressesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler WireGuardTunnelAddressesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WireGuardTunnelAddressesItem(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WireGuardTunnelAddressesItem) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type DeleteVpnOpenVpnClientEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnOpenVpnClientEndpointRequestIDFromInteger(value int) *DeleteVpnOpenVpnClientEndpointRequestID {
	return &DeleteVpnOpenVpnClientEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnOpenVpnClientEndpointRequestIDFromString(value string) *DeleteVpnOpenVpnClientEndpointRequestID {
	return &DeleteVpnOpenVpnClientEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnOpenVpnClientEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnOpenVpnClientEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnOpenVpnClientEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnOpenVpnClientEndpointRequestID) Accept(visitor DeleteVpnOpenVpnClientEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnOpenVpnClientEndpointResponse struct {
	Data *DeleteVpnOpenVpnClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnClientEndpointResponseData struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnClientExportConfigEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnOpenVpnClientExportConfigEndpointRequestIDFromInteger(value int) *DeleteVpnOpenVpnClientExportConfigEndpointRequestID {
	return &DeleteVpnOpenVpnClientExportConfigEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnOpenVpnClientExportConfigEndpointRequestIDFromString(value string) *DeleteVpnOpenVpnClientExportConfigEndpointRequestID {
	return &DeleteVpnOpenVpnClientExportConfigEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnOpenVpnClientExportConfigEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnOpenVpnClientExportConfigEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnOpenVpnClientExportConfigEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnOpenVpnClientExportConfigEndpointRequestID) Accept(visitor DeleteVpnOpenVpnClientExportConfigEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnOpenVpnClientExportConfigEndpointResponse struct {
	Data *DeleteVpnOpenVpnClientExportConfigEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientExportConfigEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientExportConfigEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientExportConfigEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientExportConfigEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnClientExportConfigEndpointResponseData struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientExportConfigEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientExportConfigEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientExportConfigEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientExportConfigEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnClientExportConfigsEndpointResponse struct {
	Data []*DeleteVpnOpenVpnClientExportConfigsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientExportConfigsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientExportConfigsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientExportConfigsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientExportConfigsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnClientExportConfigsEndpointResponseDataItem struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientExportConfigsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientExportConfigsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientExportConfigsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientExportConfigsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnClientsEndpointResponse struct {
	Data []*DeleteVpnOpenVpnClientsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnClientsEndpointResponseDataItem struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnClientsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnClientsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnClientsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnClientsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnOpenVpnServerEndpointRequestIDFromInteger(value int) *DeleteVpnOpenVpnServerEndpointRequestID {
	return &DeleteVpnOpenVpnServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnOpenVpnServerEndpointRequestIDFromString(value string) *DeleteVpnOpenVpnServerEndpointRequestID {
	return &DeleteVpnOpenVpnServerEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnOpenVpnServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnOpenVpnServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnOpenVpnServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnOpenVpnServerEndpointRequestID) Accept(visitor DeleteVpnOpenVpnServerEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnOpenVpnServerEndpointResponse struct {
	Data *DeleteVpnOpenVpnServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnServerEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnServerEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnServerEndpointResponseData struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnServerEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnServerEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnServersEndpointResponse struct {
	Data []*DeleteVpnOpenVpnServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnServersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnServersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpnServersEndpointResponseDataItem struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpnServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpnServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpnServersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpnServersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpncsOsEndpointResponse struct {
	Data []*DeleteVpnOpenVpncsOsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpncsOsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpncsOsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpncsOsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpncsOsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpncsOsEndpointResponseDataItem struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	ID            *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpncsOsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpncsOsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpncsOsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpncsOsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpncsoEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnOpenVpncsoEndpointRequestIDFromInteger(value int) *DeleteVpnOpenVpncsoEndpointRequestID {
	return &DeleteVpnOpenVpncsoEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnOpenVpncsoEndpointRequestIDFromString(value string) *DeleteVpnOpenVpncsoEndpointRequestID {
	return &DeleteVpnOpenVpncsoEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnOpenVpncsoEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnOpenVpncsoEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnOpenVpncsoEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnOpenVpncsoEndpointRequestID) Accept(visitor DeleteVpnOpenVpncsoEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnOpenVpncsoEndpointResponse struct {
	Data *DeleteVpnOpenVpncsoEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpncsoEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpncsoEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpncsoEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpncsoEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnOpenVpncsoEndpointResponseData struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	ID            *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnOpenVpncsoEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnOpenVpncsoEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnOpenVpncsoEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnOpenVpncsoEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeerAllowedIPsEndpointResponse struct {
	Data []*DeleteVpnWireGuardPeerAllowedIPsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeerAllowedIPsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeerAllowedIPsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeerAllowedIPsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeerAllowedIPsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeerAllowedIPsEndpointResponseDataItem struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeerAllowedIPsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeerAllowedIPsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeerAllowedIPsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeerAllowedIPsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeerAllowedIPEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnWireGuardPeerAllowedIPEndpointRequestIDFromInteger(value int) *DeleteVpnWireGuardPeerAllowedIPEndpointRequestID {
	return &DeleteVpnWireGuardPeerAllowedIPEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnWireGuardPeerAllowedIPEndpointRequestIDFromString(value string) *DeleteVpnWireGuardPeerAllowedIPEndpointRequestID {
	return &DeleteVpnWireGuardPeerAllowedIPEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnWireGuardPeerAllowedIPEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnWireGuardPeerAllowedIPEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointRequestID) Accept(visitor DeleteVpnWireGuardPeerAllowedIPEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnWireGuardPeerAllowedIPEndpointRequestParentIDFromInteger(value int) *DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID {
	return &DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteVpnWireGuardPeerAllowedIPEndpointRequestParentIDFromString(value string) *DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID {
	return &DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentID) Accept(visitor DeleteVpnWireGuardPeerAllowedIPEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnWireGuardPeerAllowedIPEndpointResponse struct {
	Data *DeleteVpnWireGuardPeerAllowedIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeerAllowedIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeerAllowedIPEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeerAllowedIPEndpointResponseData struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeerAllowedIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeerAllowedIPEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeerAllowedIPEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnWireGuardPeerEndpointRequestIDFromInteger(value int) *DeleteVpnWireGuardPeerEndpointRequestID {
	return &DeleteVpnWireGuardPeerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnWireGuardPeerEndpointRequestIDFromString(value string) *DeleteVpnWireGuardPeerEndpointRequestID {
	return &DeleteVpnWireGuardPeerEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnWireGuardPeerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnWireGuardPeerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnWireGuardPeerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnWireGuardPeerEndpointRequestID) Accept(visitor DeleteVpnWireGuardPeerEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnWireGuardPeerEndpointResponse struct {
	Data *DeleteVpnWireGuardPeerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeerEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeerEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeerEndpointResponseData struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	ID         *int                           `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeerEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeerEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeersEndpointResponse struct {
	Data []*DeleteVpnWireGuardPeersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardPeersEndpointResponseDataItem struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	ID         *int                           `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardPeersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardPeersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardPeersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardPeersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelAddressEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnWireGuardTunnelAddressEndpointRequestIDFromInteger(value int) *DeleteVpnWireGuardTunnelAddressEndpointRequestID {
	return &DeleteVpnWireGuardTunnelAddressEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnWireGuardTunnelAddressEndpointRequestIDFromString(value string) *DeleteVpnWireGuardTunnelAddressEndpointRequestID {
	return &DeleteVpnWireGuardTunnelAddressEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnWireGuardTunnelAddressEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnWireGuardTunnelAddressEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointRequestID) Accept(visitor DeleteVpnWireGuardTunnelAddressEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnWireGuardTunnelAddressEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnWireGuardTunnelAddressEndpointRequestParentIDFromInteger(value int) *DeleteVpnWireGuardTunnelAddressEndpointRequestParentID {
	return &DeleteVpnWireGuardTunnelAddressEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteVpnWireGuardTunnelAddressEndpointRequestParentIDFromString(value string) *DeleteVpnWireGuardTunnelAddressEndpointRequestParentID {
	return &DeleteVpnWireGuardTunnelAddressEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnWireGuardTunnelAddressEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnWireGuardTunnelAddressEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointRequestParentID) Accept(visitor DeleteVpnWireGuardTunnelAddressEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnWireGuardTunnelAddressEndpointResponse struct {
	Data *DeleteVpnWireGuardTunnelAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelAddressEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelAddressEndpointResponseData struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelAddressEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelAddressEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelAddressesEndpointResponse struct {
	Data []*DeleteVpnWireGuardTunnelAddressesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelAddressesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelAddressesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelAddressesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelAddressesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelAddressesEndpointResponseDataItem struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelAddressesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelAddressesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelAddressesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelAddressesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpnWireGuardTunnelEndpointRequestIDFromInteger(value int) *DeleteVpnWireGuardTunnelEndpointRequestID {
	return &DeleteVpnWireGuardTunnelEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpnWireGuardTunnelEndpointRequestIDFromString(value string) *DeleteVpnWireGuardTunnelEndpointRequestID {
	return &DeleteVpnWireGuardTunnelEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpnWireGuardTunnelEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpnWireGuardTunnelEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpnWireGuardTunnelEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpnWireGuardTunnelEndpointRequestID) Accept(visitor DeleteVpnWireGuardTunnelEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpnWireGuardTunnelEndpointResponse struct {
	Data *DeleteVpnWireGuardTunnelEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelEndpointResponseData struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	ID        *int                            `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelsEndpointResponse struct {
	Data []*DeleteVpnWireGuardTunnelsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpnWireGuardTunnelsEndpointResponseDataItem struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	ID        *int                            `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpnWireGuardTunnelsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpnWireGuardTunnelsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpnWireGuardTunnelsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpnWireGuardTunnelsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1EncryptionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpniPsecPhase1EncryptionEndpointRequestIDFromInteger(value int) *DeleteVpniPsecPhase1EncryptionEndpointRequestID {
	return &DeleteVpniPsecPhase1EncryptionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpniPsecPhase1EncryptionEndpointRequestIDFromString(value string) *DeleteVpniPsecPhase1EncryptionEndpointRequestID {
	return &DeleteVpniPsecPhase1EncryptionEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpniPsecPhase1EncryptionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpniPsecPhase1EncryptionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointRequestID) Accept(visitor DeleteVpniPsecPhase1EncryptionEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpniPsecPhase1EncryptionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpniPsecPhase1EncryptionEndpointRequestParentIDFromInteger(value int) *DeleteVpniPsecPhase1EncryptionEndpointRequestParentID {
	return &DeleteVpniPsecPhase1EncryptionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteVpniPsecPhase1EncryptionEndpointRequestParentIDFromString(value string) *DeleteVpniPsecPhase1EncryptionEndpointRequestParentID {
	return &DeleteVpniPsecPhase1EncryptionEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpniPsecPhase1EncryptionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpniPsecPhase1EncryptionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointRequestParentID) Accept(visitor DeleteVpniPsecPhase1EncryptionEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpniPsecPhase1EncryptionEndpointResponse struct {
	Data *DeleteVpniPsecPhase1EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1EncryptionEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	ParentID     *int                               `json:"parent_id,omitempty"`
	ID           *int                               `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1EncryptionEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1EncryptionEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1EncryptionsEndpointResponse struct {
	Data []*DeleteVpniPsecPhase1EncryptionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1EncryptionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1EncryptionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1EncryptionsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1EncryptionsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1EncryptionsEndpointResponseDataItem struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	ParentID     *int                               `json:"parent_id,omitempty"`
	ID           *int                               `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1EncryptionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1EncryptionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1EncryptionsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1EncryptionsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1EndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpniPsecPhase1EndpointRequestIDFromInteger(value int) *DeleteVpniPsecPhase1EndpointRequestID {
	return &DeleteVpniPsecPhase1EndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpniPsecPhase1EndpointRequestIDFromString(value string) *DeleteVpniPsecPhase1EndpointRequestID {
	return &DeleteVpniPsecPhase1EndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpniPsecPhase1EndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpniPsecPhase1EndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpniPsecPhase1EndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpniPsecPhase1EndpointRequestID) Accept(visitor DeleteVpniPsecPhase1EndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpniPsecPhase1EndpointResponse struct {
	Data *DeleteVpniPsecPhase1EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1EndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1EndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1EndpointResponseData struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	ID         *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1EndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1EndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1SEndpointResponse struct {
	Data []*DeleteVpniPsecPhase1SEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1SEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1SEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1SEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1SEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase1SEndpointResponseDataItem struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	ID         *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase1SEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase1SEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase1SEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase1SEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2EncryptionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpniPsecPhase2EncryptionEndpointRequestIDFromInteger(value int) *DeleteVpniPsecPhase2EncryptionEndpointRequestID {
	return &DeleteVpniPsecPhase2EncryptionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpniPsecPhase2EncryptionEndpointRequestIDFromString(value string) *DeleteVpniPsecPhase2EncryptionEndpointRequestID {
	return &DeleteVpniPsecPhase2EncryptionEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpniPsecPhase2EncryptionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpniPsecPhase2EncryptionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointRequestID) Accept(visitor DeleteVpniPsecPhase2EncryptionEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpniPsecPhase2EncryptionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpniPsecPhase2EncryptionEndpointRequestParentIDFromInteger(value int) *DeleteVpniPsecPhase2EncryptionEndpointRequestParentID {
	return &DeleteVpniPsecPhase2EncryptionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteVpniPsecPhase2EncryptionEndpointRequestParentIDFromString(value string) *DeleteVpniPsecPhase2EncryptionEndpointRequestParentID {
	return &DeleteVpniPsecPhase2EncryptionEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpniPsecPhase2EncryptionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpniPsecPhase2EncryptionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointRequestParentID) Accept(visitor DeleteVpniPsecPhase2EncryptionEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpniPsecPhase2EncryptionEndpointResponse struct {
	Data *DeleteVpniPsecPhase2EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2EncryptionEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen   *int `json:"keylen,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2EncryptionEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2EncryptionEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2EncryptionsEndpointResponse struct {
	Data []*DeleteVpniPsecPhase2EncryptionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2EncryptionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2EncryptionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2EncryptionsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2EncryptionsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2EncryptionsEndpointResponseDataItem struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen   *int `json:"keylen,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2EncryptionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2EncryptionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2EncryptionsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2EncryptionsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2EndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteVpniPsecPhase2EndpointRequestIDFromInteger(value int) *DeleteVpniPsecPhase2EndpointRequestID {
	return &DeleteVpniPsecPhase2EndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteVpniPsecPhase2EndpointRequestIDFromString(value string) *DeleteVpniPsecPhase2EndpointRequestID {
	return &DeleteVpniPsecPhase2EndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteVpniPsecPhase2EndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteVpniPsecPhase2EndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteVpniPsecPhase2EndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteVpniPsecPhase2EndpointRequestID) Accept(visitor DeleteVpniPsecPhase2EndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteVpniPsecPhase2EndpointResponse struct {
	Data *DeleteVpniPsecPhase2EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2EndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2EndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2EndpointResponseData struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	ID        *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2EndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2EndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2SEndpointResponse struct {
	Data []*DeleteVpniPsecPhase2SEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2SEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2SEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2SEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2SEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteVpniPsecPhase2SEndpointResponseDataItem struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	ID        *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteVpniPsecPhase2SEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteVpniPsecPhase2SEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteVpniPsecPhase2SEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteVpniPsecPhase2SEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetVpnOpenVpnClientEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnOpenVpnClientEndpointRequestIDFromInteger(value int) *GetVpnOpenVpnClientEndpointRequestID {
	return &GetVpnOpenVpnClientEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnOpenVpnClientEndpointRequestIDFromString(value string) *GetVpnOpenVpnClientEndpointRequestID {
	return &GetVpnOpenVpnClientEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnOpenVpnClientEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnOpenVpnClientEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnOpenVpnClientEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnOpenVpnClientEndpointRequestID) Accept(visitor GetVpnOpenVpnClientEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnOpenVpnClientEndpointResponse struct {
	Data *GetVpnOpenVpnClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnClientEndpointResponseData struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnClientExportConfigEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnOpenVpnClientExportConfigEndpointRequestIDFromInteger(value int) *GetVpnOpenVpnClientExportConfigEndpointRequestID {
	return &GetVpnOpenVpnClientExportConfigEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnOpenVpnClientExportConfigEndpointRequestIDFromString(value string) *GetVpnOpenVpnClientExportConfigEndpointRequestID {
	return &GetVpnOpenVpnClientExportConfigEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnOpenVpnClientExportConfigEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnOpenVpnClientExportConfigEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnOpenVpnClientExportConfigEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnOpenVpnClientExportConfigEndpointRequestID) Accept(visitor GetVpnOpenVpnClientExportConfigEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnOpenVpnClientExportConfigEndpointResponse struct {
	Data *GetVpnOpenVpnClientExportConfigEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientExportConfigEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientExportConfigEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientExportConfigEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientExportConfigEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnClientExportConfigEndpointResponseData struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientExportConfigEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientExportConfigEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientExportConfigEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientExportConfigEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags string

const (
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortRegular      GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortNumeric      GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortString       GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags = "SORT_STRING"
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortLocaleString GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortNatural      GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortFlagCase     GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsFromString(s string) (GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags) Ptr() *GetVpnOpenVpnClientExportConfigsEndpointRequestSortFlags {
	return &g
}

type GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder string

const (
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrderSortAsc  GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder = "SORT_ASC"
	GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrderSortDesc GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnOpenVpnClientExportConfigsEndpointRequestSortOrderFromString(s string) (GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder) Ptr() *GetVpnOpenVpnClientExportConfigsEndpointRequestSortOrder {
	return &g
}

type GetVpnOpenVpnClientExportConfigsEndpointResponse struct {
	Data []*GetVpnOpenVpnClientExportConfigsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientExportConfigsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientExportConfigsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientExportConfigsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientExportConfigsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnClientExportConfigsEndpointResponseDataItem struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientExportConfigsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientExportConfigsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientExportConfigsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientExportConfigsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnClientsEndpointRequestSortFlags string

const (
	GetVpnOpenVpnClientsEndpointRequestSortFlagsSortRegular      GetVpnOpenVpnClientsEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnOpenVpnClientsEndpointRequestSortFlagsSortNumeric      GetVpnOpenVpnClientsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnOpenVpnClientsEndpointRequestSortFlagsSortString       GetVpnOpenVpnClientsEndpointRequestSortFlags = "SORT_STRING"
	GetVpnOpenVpnClientsEndpointRequestSortFlagsSortLocaleString GetVpnOpenVpnClientsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnOpenVpnClientsEndpointRequestSortFlagsSortNatural      GetVpnOpenVpnClientsEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnOpenVpnClientsEndpointRequestSortFlagsSortFlagCase     GetVpnOpenVpnClientsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnOpenVpnClientsEndpointRequestSortFlagsFromString(s string) (GetVpnOpenVpnClientsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnOpenVpnClientsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnOpenVpnClientsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnOpenVpnClientsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnOpenVpnClientsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnOpenVpnClientsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnOpenVpnClientsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnOpenVpnClientsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpnClientsEndpointRequestSortFlags) Ptr() *GetVpnOpenVpnClientsEndpointRequestSortFlags {
	return &g
}

type GetVpnOpenVpnClientsEndpointRequestSortOrder string

const (
	GetVpnOpenVpnClientsEndpointRequestSortOrderSortAsc  GetVpnOpenVpnClientsEndpointRequestSortOrder = "SORT_ASC"
	GetVpnOpenVpnClientsEndpointRequestSortOrderSortDesc GetVpnOpenVpnClientsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnOpenVpnClientsEndpointRequestSortOrderFromString(s string) (GetVpnOpenVpnClientsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnOpenVpnClientsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnOpenVpnClientsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnOpenVpnClientsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpnClientsEndpointRequestSortOrder) Ptr() *GetVpnOpenVpnClientsEndpointRequestSortOrder {
	return &g
}

type GetVpnOpenVpnClientsEndpointResponse struct {
	Data []*GetVpnOpenVpnClientsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnClientsEndpointResponseDataItem struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnClientsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnClientsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnClientsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnClientsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnServerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnOpenVpnServerEndpointRequestIDFromInteger(value int) *GetVpnOpenVpnServerEndpointRequestID {
	return &GetVpnOpenVpnServerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnOpenVpnServerEndpointRequestIDFromString(value string) *GetVpnOpenVpnServerEndpointRequestID {
	return &GetVpnOpenVpnServerEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnOpenVpnServerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnOpenVpnServerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnOpenVpnServerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnOpenVpnServerEndpointRequestID) Accept(visitor GetVpnOpenVpnServerEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnOpenVpnServerEndpointResponse struct {
	Data *GetVpnOpenVpnServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnServerEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnServerEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnServerEndpointResponseData struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnServerEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnServerEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnServersEndpointRequestSortFlags string

const (
	GetVpnOpenVpnServersEndpointRequestSortFlagsSortRegular      GetVpnOpenVpnServersEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnOpenVpnServersEndpointRequestSortFlagsSortNumeric      GetVpnOpenVpnServersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnOpenVpnServersEndpointRequestSortFlagsSortString       GetVpnOpenVpnServersEndpointRequestSortFlags = "SORT_STRING"
	GetVpnOpenVpnServersEndpointRequestSortFlagsSortLocaleString GetVpnOpenVpnServersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnOpenVpnServersEndpointRequestSortFlagsSortNatural      GetVpnOpenVpnServersEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnOpenVpnServersEndpointRequestSortFlagsSortFlagCase     GetVpnOpenVpnServersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnOpenVpnServersEndpointRequestSortFlagsFromString(s string) (GetVpnOpenVpnServersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnOpenVpnServersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnOpenVpnServersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnOpenVpnServersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnOpenVpnServersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnOpenVpnServersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnOpenVpnServersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnOpenVpnServersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpnServersEndpointRequestSortFlags) Ptr() *GetVpnOpenVpnServersEndpointRequestSortFlags {
	return &g
}

type GetVpnOpenVpnServersEndpointRequestSortOrder string

const (
	GetVpnOpenVpnServersEndpointRequestSortOrderSortAsc  GetVpnOpenVpnServersEndpointRequestSortOrder = "SORT_ASC"
	GetVpnOpenVpnServersEndpointRequestSortOrderSortDesc GetVpnOpenVpnServersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnOpenVpnServersEndpointRequestSortOrderFromString(s string) (GetVpnOpenVpnServersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnOpenVpnServersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnOpenVpnServersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnOpenVpnServersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpnServersEndpointRequestSortOrder) Ptr() *GetVpnOpenVpnServersEndpointRequestSortOrder {
	return &g
}

type GetVpnOpenVpnServersEndpointResponse struct {
	Data []*GetVpnOpenVpnServersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnServersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnServersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnServersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnServersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpnServersEndpointResponseDataItem struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpnServersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpnServersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpnServersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpnServersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpncsOsEndpointRequestSortFlags string

const (
	GetVpnOpenVpncsOsEndpointRequestSortFlagsSortRegular      GetVpnOpenVpncsOsEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnOpenVpncsOsEndpointRequestSortFlagsSortNumeric      GetVpnOpenVpncsOsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnOpenVpncsOsEndpointRequestSortFlagsSortString       GetVpnOpenVpncsOsEndpointRequestSortFlags = "SORT_STRING"
	GetVpnOpenVpncsOsEndpointRequestSortFlagsSortLocaleString GetVpnOpenVpncsOsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnOpenVpncsOsEndpointRequestSortFlagsSortNatural      GetVpnOpenVpncsOsEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnOpenVpncsOsEndpointRequestSortFlagsSortFlagCase     GetVpnOpenVpncsOsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnOpenVpncsOsEndpointRequestSortFlagsFromString(s string) (GetVpnOpenVpncsOsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnOpenVpncsOsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnOpenVpncsOsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnOpenVpncsOsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnOpenVpncsOsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnOpenVpncsOsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnOpenVpncsOsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnOpenVpncsOsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpncsOsEndpointRequestSortFlags) Ptr() *GetVpnOpenVpncsOsEndpointRequestSortFlags {
	return &g
}

type GetVpnOpenVpncsOsEndpointRequestSortOrder string

const (
	GetVpnOpenVpncsOsEndpointRequestSortOrderSortAsc  GetVpnOpenVpncsOsEndpointRequestSortOrder = "SORT_ASC"
	GetVpnOpenVpncsOsEndpointRequestSortOrderSortDesc GetVpnOpenVpncsOsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnOpenVpncsOsEndpointRequestSortOrderFromString(s string) (GetVpnOpenVpncsOsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnOpenVpncsOsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnOpenVpncsOsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnOpenVpncsOsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnOpenVpncsOsEndpointRequestSortOrder) Ptr() *GetVpnOpenVpncsOsEndpointRequestSortOrder {
	return &g
}

type GetVpnOpenVpncsOsEndpointResponse struct {
	Data []*GetVpnOpenVpncsOsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpncsOsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpncsOsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpncsOsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpncsOsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpncsOsEndpointResponseDataItem struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	ID            *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpncsOsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpncsOsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpncsOsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpncsOsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpncsoEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnOpenVpncsoEndpointRequestIDFromInteger(value int) *GetVpnOpenVpncsoEndpointRequestID {
	return &GetVpnOpenVpncsoEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnOpenVpncsoEndpointRequestIDFromString(value string) *GetVpnOpenVpncsoEndpointRequestID {
	return &GetVpnOpenVpncsoEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnOpenVpncsoEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnOpenVpncsoEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnOpenVpncsoEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnOpenVpncsoEndpointRequestID) Accept(visitor GetVpnOpenVpncsoEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnOpenVpncsoEndpointResponse struct {
	Data *GetVpnOpenVpncsoEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpncsoEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpncsoEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpncsoEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpncsoEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnOpenVpncsoEndpointResponseData struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	ID            *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnOpenVpncsoEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnOpenVpncsoEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnOpenVpncsoEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnOpenVpncsoEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardApplyEndpointResponse struct {
	Data *WireGuardApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags string

const (
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortRegular      GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortNumeric      GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortString       GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags = "SORT_STRING"
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortLocaleString GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortNatural      GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortFlagCase     GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsFromString(s string) (GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags) Ptr() *GetVpnWireGuardPeerAllowedIPsEndpointRequestSortFlags {
	return &g
}

type GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder string

const (
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrderSortAsc  GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder = "SORT_ASC"
	GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrderSortDesc GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrderFromString(s string) (GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder) Ptr() *GetVpnWireGuardPeerAllowedIPsEndpointRequestSortOrder {
	return &g
}

type GetVpnWireGuardPeerAllowedIPsEndpointResponse struct {
	Data []*GetVpnWireGuardPeerAllowedIPsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeerAllowedIPsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeerAllowedIPsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeerAllowedIPsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeerAllowedIPsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeerAllowedIPsEndpointResponseDataItem struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeerAllowedIPsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeerAllowedIPsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeerAllowedIPsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeerAllowedIPsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeerAllowedIPEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnWireGuardPeerAllowedIPEndpointRequestIDFromInteger(value int) *GetVpnWireGuardPeerAllowedIPEndpointRequestID {
	return &GetVpnWireGuardPeerAllowedIPEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnWireGuardPeerAllowedIPEndpointRequestIDFromString(value string) *GetVpnWireGuardPeerAllowedIPEndpointRequestID {
	return &GetVpnWireGuardPeerAllowedIPEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnWireGuardPeerAllowedIPEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnWireGuardPeerAllowedIPEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointRequestID) Accept(visitor GetVpnWireGuardPeerAllowedIPEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnWireGuardPeerAllowedIPEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnWireGuardPeerAllowedIPEndpointRequestParentIDFromInteger(value int) *GetVpnWireGuardPeerAllowedIPEndpointRequestParentID {
	return &GetVpnWireGuardPeerAllowedIPEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetVpnWireGuardPeerAllowedIPEndpointRequestParentIDFromString(value string) *GetVpnWireGuardPeerAllowedIPEndpointRequestParentID {
	return &GetVpnWireGuardPeerAllowedIPEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnWireGuardPeerAllowedIPEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnWireGuardPeerAllowedIPEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointRequestParentID) Accept(visitor GetVpnWireGuardPeerAllowedIPEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnWireGuardPeerAllowedIPEndpointResponse struct {
	Data *GetVpnWireGuardPeerAllowedIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeerAllowedIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeerAllowedIPEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeerAllowedIPEndpointResponseData struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeerAllowedIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeerAllowedIPEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeerAllowedIPEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeerEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnWireGuardPeerEndpointRequestIDFromInteger(value int) *GetVpnWireGuardPeerEndpointRequestID {
	return &GetVpnWireGuardPeerEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnWireGuardPeerEndpointRequestIDFromString(value string) *GetVpnWireGuardPeerEndpointRequestID {
	return &GetVpnWireGuardPeerEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnWireGuardPeerEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnWireGuardPeerEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnWireGuardPeerEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnWireGuardPeerEndpointRequestID) Accept(visitor GetVpnWireGuardPeerEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnWireGuardPeerEndpointResponse struct {
	Data *GetVpnWireGuardPeerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeerEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeerEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeerEndpointResponseData struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	ID         *int                           `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeerEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeerEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeersEndpointRequestSortFlags string

const (
	GetVpnWireGuardPeersEndpointRequestSortFlagsSortRegular      GetVpnWireGuardPeersEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnWireGuardPeersEndpointRequestSortFlagsSortNumeric      GetVpnWireGuardPeersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnWireGuardPeersEndpointRequestSortFlagsSortString       GetVpnWireGuardPeersEndpointRequestSortFlags = "SORT_STRING"
	GetVpnWireGuardPeersEndpointRequestSortFlagsSortLocaleString GetVpnWireGuardPeersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnWireGuardPeersEndpointRequestSortFlagsSortNatural      GetVpnWireGuardPeersEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnWireGuardPeersEndpointRequestSortFlagsSortFlagCase     GetVpnWireGuardPeersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnWireGuardPeersEndpointRequestSortFlagsFromString(s string) (GetVpnWireGuardPeersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnWireGuardPeersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnWireGuardPeersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnWireGuardPeersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnWireGuardPeersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnWireGuardPeersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnWireGuardPeersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnWireGuardPeersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardPeersEndpointRequestSortFlags) Ptr() *GetVpnWireGuardPeersEndpointRequestSortFlags {
	return &g
}

type GetVpnWireGuardPeersEndpointRequestSortOrder string

const (
	GetVpnWireGuardPeersEndpointRequestSortOrderSortAsc  GetVpnWireGuardPeersEndpointRequestSortOrder = "SORT_ASC"
	GetVpnWireGuardPeersEndpointRequestSortOrderSortDesc GetVpnWireGuardPeersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnWireGuardPeersEndpointRequestSortOrderFromString(s string) (GetVpnWireGuardPeersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnWireGuardPeersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnWireGuardPeersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnWireGuardPeersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardPeersEndpointRequestSortOrder) Ptr() *GetVpnWireGuardPeersEndpointRequestSortOrder {
	return &g
}

type GetVpnWireGuardPeersEndpointResponse struct {
	Data []*GetVpnWireGuardPeersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardPeersEndpointResponseDataItem struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	ID         *int                           `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardPeersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardPeersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardPeersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardPeersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardSettingsEndpointResponse struct {
	Data *WireGuardSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelAddressEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnWireGuardTunnelAddressEndpointRequestIDFromInteger(value int) *GetVpnWireGuardTunnelAddressEndpointRequestID {
	return &GetVpnWireGuardTunnelAddressEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnWireGuardTunnelAddressEndpointRequestIDFromString(value string) *GetVpnWireGuardTunnelAddressEndpointRequestID {
	return &GetVpnWireGuardTunnelAddressEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnWireGuardTunnelAddressEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnWireGuardTunnelAddressEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnWireGuardTunnelAddressEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnWireGuardTunnelAddressEndpointRequestID) Accept(visitor GetVpnWireGuardTunnelAddressEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnWireGuardTunnelAddressEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnWireGuardTunnelAddressEndpointRequestParentIDFromInteger(value int) *GetVpnWireGuardTunnelAddressEndpointRequestParentID {
	return &GetVpnWireGuardTunnelAddressEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetVpnWireGuardTunnelAddressEndpointRequestParentIDFromString(value string) *GetVpnWireGuardTunnelAddressEndpointRequestParentID {
	return &GetVpnWireGuardTunnelAddressEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetVpnWireGuardTunnelAddressEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnWireGuardTunnelAddressEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnWireGuardTunnelAddressEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnWireGuardTunnelAddressEndpointRequestParentID) Accept(visitor GetVpnWireGuardTunnelAddressEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnWireGuardTunnelAddressEndpointResponse struct {
	Data *GetVpnWireGuardTunnelAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelAddressEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelAddressEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelAddressEndpointResponseData struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelAddressEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelAddressEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags string

const (
	GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortRegular      GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortNumeric      GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortString       GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags = "SORT_STRING"
	GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortLocaleString GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortNatural      GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortFlagCase     GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsFromString(s string) (GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags) Ptr() *GetVpnWireGuardTunnelAddressesEndpointRequestSortFlags {
	return &g
}

type GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder string

const (
	GetVpnWireGuardTunnelAddressesEndpointRequestSortOrderSortAsc  GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder = "SORT_ASC"
	GetVpnWireGuardTunnelAddressesEndpointRequestSortOrderSortDesc GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnWireGuardTunnelAddressesEndpointRequestSortOrderFromString(s string) (GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnWireGuardTunnelAddressesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder) Ptr() *GetVpnWireGuardTunnelAddressesEndpointRequestSortOrder {
	return &g
}

type GetVpnWireGuardTunnelAddressesEndpointResponse struct {
	Data []*GetVpnWireGuardTunnelAddressesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelAddressesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelAddressesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelAddressesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelAddressesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelAddressesEndpointResponseDataItem struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelAddressesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelAddressesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelAddressesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelAddressesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpnWireGuardTunnelEndpointRequestIDFromInteger(value int) *GetVpnWireGuardTunnelEndpointRequestID {
	return &GetVpnWireGuardTunnelEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpnWireGuardTunnelEndpointRequestIDFromString(value string) *GetVpnWireGuardTunnelEndpointRequestID {
	return &GetVpnWireGuardTunnelEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpnWireGuardTunnelEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpnWireGuardTunnelEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpnWireGuardTunnelEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpnWireGuardTunnelEndpointRequestID) Accept(visitor GetVpnWireGuardTunnelEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpnWireGuardTunnelEndpointResponse struct {
	Data *GetVpnWireGuardTunnelEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelEndpointResponseData struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	ID        *int                            `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelsEndpointRequestSortFlags string

const (
	GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortRegular      GetVpnWireGuardTunnelsEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortNumeric      GetVpnWireGuardTunnelsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortString       GetVpnWireGuardTunnelsEndpointRequestSortFlags = "SORT_STRING"
	GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortLocaleString GetVpnWireGuardTunnelsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortNatural      GetVpnWireGuardTunnelsEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortFlagCase     GetVpnWireGuardTunnelsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpnWireGuardTunnelsEndpointRequestSortFlagsFromString(s string) (GetVpnWireGuardTunnelsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpnWireGuardTunnelsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpnWireGuardTunnelsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardTunnelsEndpointRequestSortFlags) Ptr() *GetVpnWireGuardTunnelsEndpointRequestSortFlags {
	return &g
}

type GetVpnWireGuardTunnelsEndpointRequestSortOrder string

const (
	GetVpnWireGuardTunnelsEndpointRequestSortOrderSortAsc  GetVpnWireGuardTunnelsEndpointRequestSortOrder = "SORT_ASC"
	GetVpnWireGuardTunnelsEndpointRequestSortOrderSortDesc GetVpnWireGuardTunnelsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpnWireGuardTunnelsEndpointRequestSortOrderFromString(s string) (GetVpnWireGuardTunnelsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpnWireGuardTunnelsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpnWireGuardTunnelsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpnWireGuardTunnelsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpnWireGuardTunnelsEndpointRequestSortOrder) Ptr() *GetVpnWireGuardTunnelsEndpointRequestSortOrder {
	return &g
}

type GetVpnWireGuardTunnelsEndpointResponse struct {
	Data []*GetVpnWireGuardTunnelsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpnWireGuardTunnelsEndpointResponseDataItem struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	ID        *int                            `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpnWireGuardTunnelsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpnWireGuardTunnelsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpnWireGuardTunnelsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpnWireGuardTunnelsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecApplyEndpointResponse struct {
	Data *IPsecApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1EncryptionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpniPsecPhase1EncryptionEndpointRequestIDFromInteger(value int) *GetVpniPsecPhase1EncryptionEndpointRequestID {
	return &GetVpniPsecPhase1EncryptionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpniPsecPhase1EncryptionEndpointRequestIDFromString(value string) *GetVpniPsecPhase1EncryptionEndpointRequestID {
	return &GetVpniPsecPhase1EncryptionEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpniPsecPhase1EncryptionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpniPsecPhase1EncryptionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpniPsecPhase1EncryptionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpniPsecPhase1EncryptionEndpointRequestID) Accept(visitor GetVpniPsecPhase1EncryptionEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpniPsecPhase1EncryptionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpniPsecPhase1EncryptionEndpointRequestParentIDFromInteger(value int) *GetVpniPsecPhase1EncryptionEndpointRequestParentID {
	return &GetVpniPsecPhase1EncryptionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetVpniPsecPhase1EncryptionEndpointRequestParentIDFromString(value string) *GetVpniPsecPhase1EncryptionEndpointRequestParentID {
	return &GetVpniPsecPhase1EncryptionEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetVpniPsecPhase1EncryptionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpniPsecPhase1EncryptionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpniPsecPhase1EncryptionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpniPsecPhase1EncryptionEndpointRequestParentID) Accept(visitor GetVpniPsecPhase1EncryptionEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpniPsecPhase1EncryptionEndpointResponse struct {
	Data *GetVpniPsecPhase1EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1EncryptionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1EncryptionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	ParentID     *int                               `json:"parent_id,omitempty"`
	ID           *int                               `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1EncryptionEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1EncryptionEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags string

const (
	GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortRegular      GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortNumeric      GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortString       GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags = "SORT_STRING"
	GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortLocaleString GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortNatural      GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortFlagCase     GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsFromString(s string) (GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags) Ptr() *GetVpniPsecPhase1EncryptionsEndpointRequestSortFlags {
	return &g
}

type GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder string

const (
	GetVpniPsecPhase1EncryptionsEndpointRequestSortOrderSortAsc  GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder = "SORT_ASC"
	GetVpniPsecPhase1EncryptionsEndpointRequestSortOrderSortDesc GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpniPsecPhase1EncryptionsEndpointRequestSortOrderFromString(s string) (GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpniPsecPhase1EncryptionsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder) Ptr() *GetVpniPsecPhase1EncryptionsEndpointRequestSortOrder {
	return &g
}

type GetVpniPsecPhase1EncryptionsEndpointResponse struct {
	Data []*GetVpniPsecPhase1EncryptionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1EncryptionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1EncryptionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1EncryptionsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1EncryptionsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1EncryptionsEndpointResponseDataItem struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	ParentID     *int                               `json:"parent_id,omitempty"`
	ID           *int                               `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1EncryptionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1EncryptionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1EncryptionsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1EncryptionsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1EndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpniPsecPhase1EndpointRequestIDFromInteger(value int) *GetVpniPsecPhase1EndpointRequestID {
	return &GetVpniPsecPhase1EndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpniPsecPhase1EndpointRequestIDFromString(value string) *GetVpniPsecPhase1EndpointRequestID {
	return &GetVpniPsecPhase1EndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpniPsecPhase1EndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpniPsecPhase1EndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpniPsecPhase1EndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpniPsecPhase1EndpointRequestID) Accept(visitor GetVpniPsecPhase1EndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpniPsecPhase1EndpointResponse struct {
	Data *GetVpniPsecPhase1EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1EndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1EndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1EndpointResponseData struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	ID         *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1EndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1EndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1SEndpointRequestSortFlags string

const (
	GetVpniPsecPhase1SEndpointRequestSortFlagsSortRegular      GetVpniPsecPhase1SEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpniPsecPhase1SEndpointRequestSortFlagsSortNumeric      GetVpniPsecPhase1SEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpniPsecPhase1SEndpointRequestSortFlagsSortString       GetVpniPsecPhase1SEndpointRequestSortFlags = "SORT_STRING"
	GetVpniPsecPhase1SEndpointRequestSortFlagsSortLocaleString GetVpniPsecPhase1SEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpniPsecPhase1SEndpointRequestSortFlagsSortNatural      GetVpniPsecPhase1SEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpniPsecPhase1SEndpointRequestSortFlagsSortFlagCase     GetVpniPsecPhase1SEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpniPsecPhase1SEndpointRequestSortFlagsFromString(s string) (GetVpniPsecPhase1SEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpniPsecPhase1SEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpniPsecPhase1SEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpniPsecPhase1SEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpniPsecPhase1SEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpniPsecPhase1SEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpniPsecPhase1SEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpniPsecPhase1SEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase1SEndpointRequestSortFlags) Ptr() *GetVpniPsecPhase1SEndpointRequestSortFlags {
	return &g
}

type GetVpniPsecPhase1SEndpointRequestSortOrder string

const (
	GetVpniPsecPhase1SEndpointRequestSortOrderSortAsc  GetVpniPsecPhase1SEndpointRequestSortOrder = "SORT_ASC"
	GetVpniPsecPhase1SEndpointRequestSortOrderSortDesc GetVpniPsecPhase1SEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpniPsecPhase1SEndpointRequestSortOrderFromString(s string) (GetVpniPsecPhase1SEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpniPsecPhase1SEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpniPsecPhase1SEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpniPsecPhase1SEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase1SEndpointRequestSortOrder) Ptr() *GetVpniPsecPhase1SEndpointRequestSortOrder {
	return &g
}

type GetVpniPsecPhase1SEndpointResponse struct {
	Data []*GetVpniPsecPhase1SEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1SEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1SEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1SEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1SEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase1SEndpointResponseDataItem struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	ID         *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase1SEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase1SEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase1SEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase1SEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2EncryptionEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpniPsecPhase2EncryptionEndpointRequestIDFromInteger(value int) *GetVpniPsecPhase2EncryptionEndpointRequestID {
	return &GetVpniPsecPhase2EncryptionEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpniPsecPhase2EncryptionEndpointRequestIDFromString(value string) *GetVpniPsecPhase2EncryptionEndpointRequestID {
	return &GetVpniPsecPhase2EncryptionEndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpniPsecPhase2EncryptionEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpniPsecPhase2EncryptionEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpniPsecPhase2EncryptionEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpniPsecPhase2EncryptionEndpointRequestID) Accept(visitor GetVpniPsecPhase2EncryptionEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpniPsecPhase2EncryptionEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpniPsecPhase2EncryptionEndpointRequestParentIDFromInteger(value int) *GetVpniPsecPhase2EncryptionEndpointRequestParentID {
	return &GetVpniPsecPhase2EncryptionEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetVpniPsecPhase2EncryptionEndpointRequestParentIDFromString(value string) *GetVpniPsecPhase2EncryptionEndpointRequestParentID {
	return &GetVpniPsecPhase2EncryptionEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetVpniPsecPhase2EncryptionEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpniPsecPhase2EncryptionEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpniPsecPhase2EncryptionEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpniPsecPhase2EncryptionEndpointRequestParentID) Accept(visitor GetVpniPsecPhase2EncryptionEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpniPsecPhase2EncryptionEndpointResponse struct {
	Data *GetVpniPsecPhase2EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2EncryptionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2EncryptionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen   *int `json:"keylen,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2EncryptionEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2EncryptionEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags string

const (
	GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortRegular      GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortNumeric      GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortString       GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags = "SORT_STRING"
	GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortLocaleString GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortNatural      GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortFlagCase     GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsFromString(s string) (GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags) Ptr() *GetVpniPsecPhase2EncryptionsEndpointRequestSortFlags {
	return &g
}

type GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder string

const (
	GetVpniPsecPhase2EncryptionsEndpointRequestSortOrderSortAsc  GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder = "SORT_ASC"
	GetVpniPsecPhase2EncryptionsEndpointRequestSortOrderSortDesc GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpniPsecPhase2EncryptionsEndpointRequestSortOrderFromString(s string) (GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpniPsecPhase2EncryptionsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder) Ptr() *GetVpniPsecPhase2EncryptionsEndpointRequestSortOrder {
	return &g
}

type GetVpniPsecPhase2EncryptionsEndpointResponse struct {
	Data []*GetVpniPsecPhase2EncryptionsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2EncryptionsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2EncryptionsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2EncryptionsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2EncryptionsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2EncryptionsEndpointResponseDataItem struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen   *int `json:"keylen,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2EncryptionsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2EncryptionsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2EncryptionsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2EncryptionsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2EndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetVpniPsecPhase2EndpointRequestIDFromInteger(value int) *GetVpniPsecPhase2EndpointRequestID {
	return &GetVpniPsecPhase2EndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetVpniPsecPhase2EndpointRequestIDFromString(value string) *GetVpniPsecPhase2EndpointRequestID {
	return &GetVpniPsecPhase2EndpointRequestID{typeName: "string", String: value}
}

func (g *GetVpniPsecPhase2EndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetVpniPsecPhase2EndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetVpniPsecPhase2EndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetVpniPsecPhase2EndpointRequestID) Accept(visitor GetVpniPsecPhase2EndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetVpniPsecPhase2EndpointResponse struct {
	Data *GetVpniPsecPhase2EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2EndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2EndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2EndpointResponseData struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	ID        *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2EndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2EndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2SEndpointRequestSortFlags string

const (
	GetVpniPsecPhase2SEndpointRequestSortFlagsSortRegular      GetVpniPsecPhase2SEndpointRequestSortFlags = "SORT_REGULAR"
	GetVpniPsecPhase2SEndpointRequestSortFlagsSortNumeric      GetVpniPsecPhase2SEndpointRequestSortFlags = "SORT_NUMERIC"
	GetVpniPsecPhase2SEndpointRequestSortFlagsSortString       GetVpniPsecPhase2SEndpointRequestSortFlags = "SORT_STRING"
	GetVpniPsecPhase2SEndpointRequestSortFlagsSortLocaleString GetVpniPsecPhase2SEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetVpniPsecPhase2SEndpointRequestSortFlagsSortNatural      GetVpniPsecPhase2SEndpointRequestSortFlags = "SORT_NATURAL"
	GetVpniPsecPhase2SEndpointRequestSortFlagsSortFlagCase     GetVpniPsecPhase2SEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetVpniPsecPhase2SEndpointRequestSortFlagsFromString(s string) (GetVpniPsecPhase2SEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetVpniPsecPhase2SEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetVpniPsecPhase2SEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetVpniPsecPhase2SEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetVpniPsecPhase2SEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetVpniPsecPhase2SEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetVpniPsecPhase2SEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetVpniPsecPhase2SEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase2SEndpointRequestSortFlags) Ptr() *GetVpniPsecPhase2SEndpointRequestSortFlags {
	return &g
}

type GetVpniPsecPhase2SEndpointRequestSortOrder string

const (
	GetVpniPsecPhase2SEndpointRequestSortOrderSortAsc  GetVpniPsecPhase2SEndpointRequestSortOrder = "SORT_ASC"
	GetVpniPsecPhase2SEndpointRequestSortOrderSortDesc GetVpniPsecPhase2SEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetVpniPsecPhase2SEndpointRequestSortOrderFromString(s string) (GetVpniPsecPhase2SEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetVpniPsecPhase2SEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetVpniPsecPhase2SEndpointRequestSortOrderSortDesc, nil
	}
	var t GetVpniPsecPhase2SEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetVpniPsecPhase2SEndpointRequestSortOrder) Ptr() *GetVpniPsecPhase2SEndpointRequestSortOrder {
	return &g
}

type GetVpniPsecPhase2SEndpointResponse struct {
	Data []*GetVpniPsecPhase2SEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2SEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2SEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2SEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2SEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVpniPsecPhase2SEndpointResponseDataItem struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	ID        *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetVpniPsecPhase2SEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVpniPsecPhase2SEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVpniPsecPhase2SEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVpniPsecPhase2SEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PatchVpnOpenVpnClientEndpointResponse struct {
	Data *PatchVpnOpenVpnClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpnClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpnClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpnClientEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpnClientEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnOpenVpnClientEndpointResponseData struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpnClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpnClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpnClientEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpnClientEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnOpenVpnClientExportConfigEndpointResponse struct {
	Data *PatchVpnOpenVpnClientExportConfigEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpnClientExportConfigEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpnClientExportConfigEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpnClientExportConfigEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpnClientExportConfigEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnOpenVpnClientExportConfigEndpointResponseData struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpnClientExportConfigEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpnClientExportConfigEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpnClientExportConfigEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpnClientExportConfigEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnOpenVpnServerEndpointResponse struct {
	Data *PatchVpnOpenVpnServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpnServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpnServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpnServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpnServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnOpenVpnServerEndpointResponseData struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpnServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpnServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpnServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpnServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnOpenVpncsoEndpointResponse struct {
	Data *PatchVpnOpenVpncsoEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpncsoEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpncsoEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpncsoEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpncsoEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnOpenVpncsoEndpointResponseData struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	ID            *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnOpenVpncsoEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnOpenVpncsoEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnOpenVpncsoEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnOpenVpncsoEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardPeerAllowedIPEndpointResponse struct {
	Data *PatchVpnWireGuardPeerAllowedIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardPeerAllowedIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardPeerAllowedIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardPeerAllowedIPEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardPeerAllowedIPEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardPeerAllowedIPEndpointResponseData struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardPeerAllowedIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardPeerAllowedIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardPeerAllowedIPEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardPeerAllowedIPEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardPeerEndpointResponse struct {
	Data *PatchVpnWireGuardPeerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardPeerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardPeerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardPeerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardPeerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardPeerEndpointResponseData struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	ID         *int                           `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardPeerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardPeerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardPeerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardPeerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardSettingsEndpointResponse struct {
	Data *WireGuardSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardTunnelAddressEndpointResponse struct {
	Data *PatchVpnWireGuardTunnelAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardTunnelAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardTunnelAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardTunnelAddressEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardTunnelAddressEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardTunnelAddressEndpointResponseData struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardTunnelAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardTunnelAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardTunnelAddressEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardTunnelAddressEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardTunnelEndpointResponse struct {
	Data *PatchVpnWireGuardTunnelEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardTunnelEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardTunnelEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardTunnelEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardTunnelEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpnWireGuardTunnelEndpointResponseData struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	ID        *int                            `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpnWireGuardTunnelEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpnWireGuardTunnelEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpnWireGuardTunnelEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpnWireGuardTunnelEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase1EncryptionEndpointResponse struct {
	Data *PatchVpniPsecPhase1EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase1EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase1EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase1EncryptionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase1EncryptionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase1EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	ParentID     *int                               `json:"parent_id,omitempty"`
	ID           *int                               `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase1EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase1EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase1EncryptionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase1EncryptionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase1EndpointResponse struct {
	Data *PatchVpniPsecPhase1EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase1EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase1EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase1EndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase1EndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase1EndpointResponseData struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	ID         *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase1EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase1EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase1EndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase1EndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase2EncryptionEndpointResponse struct {
	Data *PatchVpniPsecPhase2EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase2EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase2EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase2EncryptionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase2EncryptionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase2EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen   *int `json:"keylen,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase2EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase2EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase2EncryptionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase2EncryptionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase2EndpointResponse struct {
	Data *PatchVpniPsecPhase2EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase2EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase2EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase2EndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase2EndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchVpniPsecPhase2EndpointResponseData struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	ID        *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchVpniPsecPhase2EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchVpniPsecPhase2EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchVpniPsecPhase2EndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchVpniPsecPhase2EndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnClientEndpointResponse struct {
	Data *PostVpnOpenVpnClientEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnClientEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnClientEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnClientEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnClientEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnClientEndpointResponseData struct {
	// The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN client.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN client.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN client mode.<br>
	Mode *OpenVpnClientMode `json:"mode,omitempty"`
	// The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnClientDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN client.<br>
	Protocol *OpenVpnClientProtocol `json:"protocol,omitempty"`
	// The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the OpenVPN server this client will connect to.<br>
	ServerAddr *string `json:"server_addr,omitempty"`
	// The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>
	ServerPort *string `json:"server_port,omitempty"`
	// The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// The address for an HTTP Proxy this client can use to connect to a remote server.<br>
	ProxyAddr *string `json:"proxy_addr,omitempty"`
	// The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>
	ProxyPort *string `json:"proxy_port,omitempty"`
	// The type of authentication used by the proxy server.<br>
	ProxyAuthtype *OpenVpnClientProxyAuthtype `json:"proxy_authtype,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyUser *string `json:"proxy_user,omitempty"`
	// The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>
	ProxyPasswd *string `json:"proxy_passwd,omitempty"`
	// The username used to authenticate with the OpenVPN server.<br>
	AuthUser *string `json:"auth_user,omitempty"`
	// The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>
	AuthPass *string `json:"auth_pass,omitempty"`
	// Disables retrying authentication if an authentication failed error is received from the server<br>
	AuthRetryNone *bool `json:"auth_retry_none,omitempty"`
	// The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TLSType *OpenVpnClientTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>
	TlsauthKeydir *OpenVpnClientTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN client.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this client and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>
	UseShaper *int `json:"use_shaper,omitempty"`
	// The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnClientAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables the servers ability to add routes to the client's routing table.<br>
	RouteNoPull *bool `json:"route_no_pull,omitempty"`
	// Enables or disables adding/removing routes automatically.<br>
	RouteNoExec *bool `json:"route_no_exec,omitempty"`
	// Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>
	DNSAdd *bool `json:"dns_add,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnClientTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnClientPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnClientPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Additional options to add to the OpenVPN client configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>
	UDPFastIo *bool `json:"udp_fast_io,omitempty"`
	// The number of times this client will attempt to send an exit notifications.<br>
	ExitNotify *OpenVpnClientExitNotify `json:"exit_notify,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnClientCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnClientEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnClientEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnClientEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnClientEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnClientExportConfigEndpointResponse struct {
	Data *PostVpnOpenVpnClientExportConfigEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnClientExportConfigEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnClientExportConfigEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnClientExportConfigEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnClientExportConfigEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnClientExportConfigEndpointResponseData struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnClientExportConfigEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnClientExportConfigEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnClientExportConfigEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnClientExportConfigEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnClientExportEndpointResponse struct {
	Data *PostVpnOpenVpnClientExportEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnClientExportEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnClientExportEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnClientExportEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnClientExportEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnClientExportEndpointResponseData struct {
	// The type of OpenVPN client export to generate. This determines the format and content of the export file.<br>
	Type *OpenVpnClientExportType `json:"type,omitempty"`
	// The reference ID of the certificate to use for this OpenVPN client export. This is only applicable for OpenVPN servers that require client certificates.<br>
	Certref *string `json:"certref,omitempty"`
	// The username of the user this client export corresponds to. This is only applicable for OpenVPN servers that use the Local Database AND client certificates.<br>
	Username *string `json:"username,omitempty"`
	// The filename used when exporting the OpenVPN client export. This value cannot be changed<br>
	Filename *string `json:"filename,omitempty"`
	// The binary data of the OpenVPN client export. This is used to store the actual exported configuration file content. When the content-type is set to "application/octet-stream", this field will contain the data of the OpenVPN client export download.<br>
	BinaryData *string `json:"binary_data,omitempty"`
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnClientExportEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnClientExportEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnClientExportEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnClientExportEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnServerEndpointResponse struct {
	Data *PostVpnOpenVpnServerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnServerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnServerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnServerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnServerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpnServerEndpointResponseData struct {
	// The unique ID for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnid *int `json:"vpnid,omitempty"`
	// The VPN interface name for this OpenVPN server. This value is assigned by the system and cannot be changed.<br>
	Vpnif *string `json:"vpnif,omitempty"`
	// The description for this OpenVPN server.<br>
	Description *string `json:"description,omitempty"`
	// Disables this OpenVPN server.<br>
	Disable *bool `json:"disable,omitempty"`
	// The OpenVPN server mode.<br>
	Mode *OpenVpnServerMode `json:"mode,omitempty"`
	// The name of the authentication server to use as the authentication backend for this OpenVPN server<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Authmode []string `json:"authmode,omitempty"`
	// The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>
	DevMode *OpenVpnServerDevMode `json:"dev_mode,omitempty"`
	// The protocol used by this OpenVPN server.<br>
	Protocol *OpenVpnServerProtocol `json:"protocol,omitempty"`
	// The interface or Virtual IP address where OpenVPN will receive client connections.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>
	Interface *string `json:"interface,omitempty"`
	// The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Enables or disables the use of a TLS key for this OpenVPN server.<br>
	UseTLS *bool `json:"use_tls,omitempty"`
	// The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLS *string `json:"tls,omitempty"`
	// The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TLSType *OpenVpnServerTLSType `json:"tls_type,omitempty"`
	// The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `use_tls` must be equal to `true`<br>
	TlsauthKeydir *OpenVpnServerTlsauthKeydir `json:"tlsauth_keydir,omitempty"`
	// The `refid` of the CA object to assume as the peer CA.<br>
	Caref *string `json:"caref,omitempty"`
	// The `refid` of the certificate object to assume as the OpenVPN server certificate.<br>
	Certref *string `json:"certref,omitempty"`
	// The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default.<br>
	CertDepth *int `json:"cert_depth,omitempty"`
	// The Diffie-Hellman (DH) parameter set used for key exchange.<br>
	DhLength *string `json:"dh_length,omitempty"`
	// The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.<br>
	EcdhCurve *string `json:"ecdh_curve,omitempty"`
	// The encryption algorithms/ciphers allowed by this OpenVPN server.<br>
	DataCiphers []string `json:"data_ciphers,omitempty"`
	// The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>
	DataCiphersFallback *string `json:"data_ciphers_fallback,omitempty"`
	// The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>
	Digest *string `json:"digest,omitempty"`
	// Enables or disables enforcing a match between the common name of the client certificate and the username given at login.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	Strictusercn *bool `json:"strictusercn,omitempty"`
	// Enables or disables requiring hosts to have a client certificate to connect.<br>
	RemoteCertTLS *bool `json:"remote_cert_tls,omitempty"`
	// The IPv4 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between this server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// Enables or disables clients on the bridge to obtain DHCP.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tap'`<br>
	ServerbridgeDhcp *bool `json:"serverbridge_dhcp,omitempty"`
	// The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeInterface *string `json:"serverbridge_interface,omitempty"`
	// Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeRoutegateway *bool `json:"serverbridge_routegateway,omitempty"`
	// The bridge DHCP range's start address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpStart *string `json:"serverbridge_dhcp_start,omitempty"`
	// The bridge DHCP range's end address.<br><br>This field is only available when the following conditions are met:<br>- `serverbridge_dhcp` must be equal to `true`<br>
	ServerbridgeDhcpEnd *string `json:"serverbridge_dhcp_end,omitempty"`
	// Enable forcing all client-generated IPv4 traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enable forcing all client-generated IPv6 traffic through the tunnel.<br>
	Gwredir6 *bool `json:"gwredir6,omitempty"`
	// The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir` must be equal to `false`<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.<br><br>This field is only available when the following conditions are met:<br>- `gwredir6` must be equal to `false`<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// The maximum number of clients allowed to concurrently connect to this server.<br>
	Maxclients *int `json:"maxclients,omitempty"`
	// The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>
	AllowCompression *OpenVpnServerAllowCompression `json:"allow_compression,omitempty"`
	// Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>
	Passtos *bool `json:"passtos,omitempty"`
	// Enables or disables allowing communication between clients connected to this server.<br>
	Client2Client *bool `json:"client2client,omitempty"`
	// Enables or disable allowing the same user to connect multiple times.<br>
	DuplicateCn *bool `json:"duplicate_cn,omitempty"`
	// The number of concurrent connections a single user can have.<br><br>This field is only available when the following conditions are met:<br>- `duplicate_cn` must be equal to `true`<br>
	Connlimit *int `json:"connlimit,omitempty"`
	// Enables or disables allowing connected clients to retain their connections if their IP address changes.<br>
	DynamicIP *bool `json:"dynamic_ip,omitempty"`
	// The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>
	Topology *OpenVpnServerTopology `json:"topology,omitempty"`
	// The amount of time (in seconds) until a client connection is closed for inactivity.<br>
	InactiveSeconds *int `json:"inactive_seconds,omitempty"`
	// The method used to define ping configuration.<br>
	PingMethod *OpenVpnServerPingMethod `json:"ping_method,omitempty"`
	// The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveInterval *int `json:"keepalive_interval,omitempty"`
	// The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>
	KeepaliveTimeout *int `json:"keepalive_timeout,omitempty"`
	// The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingSeconds *int `json:"ping_seconds,omitempty"`
	// Enables or disables push ping to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingPush *bool `json:"ping_push,omitempty"`
	// The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingAction *OpenVpnServerPingAction `json:"ping_action,omitempty"`
	// The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionSeconds *int `json:"ping_action_seconds,omitempty"`
	// Enables or disables pushing the ping action to the VPN client.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>
	PingActionPush *bool `json:"ping_action_push,omitempty"`
	// The default domain to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushBlockoutsidedns *bool `json:"push_blockoutsidedns,omitempty"`
	// Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	PushRegisterDNS *bool `json:"push_register_dns,omitempty"`
	// The primary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to clients.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional options to add to the OpenVPN server configuration.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	// Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ server_user, server_tls_user ]<br>
	UsernameAsCommonName *bool `json:"username_as_common_name,omitempty"`
	// The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>
	Sndrcvbuf *int `json:"sndrcvbuf,omitempty"`
	// The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>
	CreateGw *OpenVpnServerCreateGw `json:"create_gw,omitempty"`
	// The OpenVPN logging verbosity level.<br>
	VerbosityLevel *int `json:"verbosity_level,omitempty"`
	ID             *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpnServerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpnServerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpnServerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpnServerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpncsoEndpointResponse struct {
	Data *PostVpnOpenVpncsoEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpncsoEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpncsoEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpncsoEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpncsoEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnOpenVpncsoEndpointResponseData struct {
	// The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.<br>
	CommonName *string `json:"common_name,omitempty"`
	// Disables this client specific override.<br>
	Disable *bool `json:"disable,omitempty"`
	// Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.<br>
	Block *bool `json:"block,omitempty"`
	// The description for this client specific override.<br>
	Description *string `json:"description,omitempty"`
	// The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.<br>
	ServerList []string `json:"server_list,omitempty"`
	// The IPv4 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetwork *string `json:"tunnel_network,omitempty"`
	// The IPv6 virtual network used for private communications between the server and client hosts.<br>
	TunnelNetworkv6 *string `json:"tunnel_networkv6,omitempty"`
	// The IPv4 server-side networks that will be accessible from this particular client.<br>
	LocalNetwork []string `json:"local_network,omitempty"`
	// the IPv6 server-side networks that will be accessible from this particular client.<br>
	LocalNetworkv6 []string `json:"local_networkv6,omitempty"`
	// The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetwork []string `json:"remote_network,omitempty"`
	// The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.<br>
	RemoteNetworkv6 []string `json:"remote_networkv6,omitempty"`
	// Enable forcing all client-generated traffic through the tunnel.<br>
	Gwredir *bool `json:"gwredir,omitempty"`
	// Enables or disables preventing this client from receiving any server-defined client settings.<br>
	PushReset *bool `json:"push_reset,omitempty"`
	// Specifies the push-remove options to apply to the client<br><br>This field is only available when the following conditions are met:<br>- `push_reset` must be equal to `false`<br>
	RemoveOptions []OpenVpnClientSpecificOverrideRemoveOptionsItem `json:"remove_options,omitempty"`
	// The default domain to provide to the client.<br>
	DNSDomain *string `json:"dns_domain,omitempty"`
	// The primary DNS server to provide to the client.<br>
	DNSServer1 *string `json:"dns_server1,omitempty"`
	// The secondary DNS server to provide to the client.<br>
	DNSServer2 *string `json:"dns_server2,omitempty"`
	// The tertiary DNS server to provide to the client.<br>
	DNSServer3 *string `json:"dns_server3,omitempty"`
	// The quaternary DNS server to provide to the client.<br>
	DNSServer4 *string `json:"dns_server4,omitempty"`
	// The primary NTP server to provide to the client.<br>
	NtpServer1 *string `json:"ntp_server1,omitempty"`
	// The secondary NTP server to provide to the client.<br>
	NtpServer2 *string `json:"ntp_server2,omitempty"`
	// Enables or disables NetBIOS over TCP/IP.<br>
	NetbiosEnable *bool `json:"netbios_enable,omitempty"`
	// The NetBIOS node type.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosNtype *int `json:"netbios_ntype,omitempty"`
	// The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	NetbiosScope *string `json:"netbios_scope,omitempty"`
	// The primary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer1 *string `json:"wins_server1,omitempty"`
	// The secondary WINS server to provide to the client.<br><br>This field is only available when the following conditions are met:<br>- `netbios_enable` must be equal to `true`<br>
	WinsServer2 *string `json:"wins_server2,omitempty"`
	// Additional OpenVPN options to add for this client.<br>
	CustomOptions []string `json:"custom_options,omitempty"`
	ID            *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnOpenVpncsoEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnOpenVpncsoEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnOpenVpncsoEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnOpenVpncsoEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardApplyEndpointResponse struct {
	Data *WireGuardApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardPeerAllowedIPEndpointResponse struct {
	Data *PostVpnWireGuardPeerAllowedIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardPeerAllowedIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardPeerAllowedIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardPeerAllowedIPEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardPeerAllowedIPEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardPeerAllowedIPEndpointResponseData struct {
	// The IPv4 or IPv6 address for this peer IP.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this peer IP.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this allowed peer IP.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardPeerAllowedIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardPeerAllowedIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardPeerAllowedIPEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardPeerAllowedIPEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardPeerEndpointResponse struct {
	Data *PostVpnWireGuardPeerEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardPeerEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardPeerEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardPeerEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardPeerEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardPeerEndpointResponseData struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	ID         *int                           `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardPeerEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardPeerEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardPeerEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardPeerEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardTunnelAddressEndpointResponse struct {
	Data *PostVpnWireGuardTunnelAddressEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardTunnelAddressEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardTunnelAddressEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardTunnelAddressEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardTunnelAddressEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardTunnelAddressEndpointResponseData struct {
	// The IPv4 or IPv6 address for this WireGuard tunnel.<br>
	Address *string `json:"address,omitempty"`
	// The subnet mask for this WireGuard tunnel.<br>
	Mask *int `json:"mask,omitempty"`
	// A description for this WireGuard tunnel address entry.<br>
	Descr    *string `json:"descr,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardTunnelAddressEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardTunnelAddressEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardTunnelAddressEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardTunnelAddressEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardTunnelEndpointResponse struct {
	Data *PostVpnWireGuardTunnelEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardTunnelEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardTunnelEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardTunnelEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardTunnelEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpnWireGuardTunnelEndpointResponseData struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	ID        *int                            `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpnWireGuardTunnelEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpnWireGuardTunnelEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpnWireGuardTunnelEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpnWireGuardTunnelEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecApplyEndpointResponse struct {
	Data *IPsecApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase1EncryptionEndpointResponse struct {
	Data *PostVpniPsecPhase1EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase1EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase1EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase1EncryptionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase1EncryptionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase1EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P1 encryption item.<br>
	EncryptionAlgorithmName *IPsecPhase1EncryptionEncryptionAlgorithmName `json:"encryption_algorithm_name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	EncryptionAlgorithmKeylen *int `json:"encryption_algorithm_keylen,omitempty"`
	// The hash algorithm to use for this P1 encryption item.<br>
	HashAlgorithm *IPsecPhase1EncryptionHashAlgorithm `json:"hash_algorithm,omitempty"`
	// The Diffie-Hellman (DH) group to use for this P1 encryption item.<br>
	Dhgroup *int `json:"dhgroup,omitempty"`
	// The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled.<br>
	PrfAlgorithm *IPsecPhase1EncryptionPrfAlgorithm `json:"prf_algorithm,omitempty"`
	ParentID     *int                               `json:"parent_id,omitempty"`
	ID           *int                               `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase1EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase1EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase1EncryptionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase1EncryptionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase1EndpointResponse struct {
	Data *PostVpniPsecPhase1EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase1EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase1EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase1EndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase1EndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase1EndpointResponseData struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	ID         *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase1EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase1EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase1EndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase1EndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase2EncryptionEndpointResponse struct {
	Data *PostVpniPsecPhase2EncryptionEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase2EncryptionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase2EncryptionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase2EncryptionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase2EncryptionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase2EncryptionEndpointResponseData struct {
	// The name of the encryption algorithm to use for this P2 encryption item.<br>
	Name *IPsecPhase2EncryptionName `json:"name,omitempty"`
	// The key length for the encryption algorithm.<br><br>This field is only available when the following conditions are met:<br>- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]<br>
	Keylen   *int `json:"keylen,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase2EncryptionEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase2EncryptionEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase2EncryptionEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase2EncryptionEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase2EndpointResponse struct {
	Data *PostVpniPsecPhase2EndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase2EndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase2EndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase2EndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase2EndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostVpniPsecPhase2EndpointResponseData struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	ID        *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostVpniPsecPhase2EndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostVpniPsecPhase2EndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostVpniPsecPhase2EndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostVpniPsecPhase2EndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnOpenVpnClientExportConfigsEndpointRequestItem struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnOpenVpnClientExportConfigsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnOpenVpnClientExportConfigsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnOpenVpnClientExportConfigsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnOpenVpnClientExportConfigsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnOpenVpnClientExportConfigsEndpointResponse struct {
	Data []*PutVpnOpenVpnClientExportConfigsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnOpenVpnClientExportConfigsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnOpenVpnClientExportConfigsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnOpenVpnClientExportConfigsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnOpenVpnClientExportConfigsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnOpenVpnClientExportConfigsEndpointResponseDataItem struct {
	// The VPN ID of the OpenVPN server this client export corresponds to.<br>
	Server *int `json:"server,omitempty"`
	// The method to use for the OpenVPN server address listed in the config export.<br>
	Useaddr *OpenVpnClientExportConfigUseaddr `json:"useaddr,omitempty"`
	// The hostname to use for the OpenVPN server address.<br><br>This field is only available when the following conditions are met:<br>- `useaddr` must be equal to `'other'`<br>
	UseaddrHostname *string `json:"useaddr_hostname,omitempty"`
	// Verify the server certificate Common Name (CN) when the client connects.<br>
	Verifyservercn *OpenVpnClientExportConfigVerifyservercn `json:"verifyservercn,omitempty"`
	// Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.<br>
	Blockoutsidedns *bool `json:"blockoutsidedns,omitempty"`
	// Do not include OpenVPN 2.5 and later settings in the client configuration.<br>
	Legacy *bool `json:"legacy,omitempty"`
	// Create Windows installer for unattended deploy.<br>
	Silent *bool `json:"silent,omitempty"`
	// The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently.<br>
	Bindmode *OpenVpnClientExportConfigBindmode `json:"bindmode,omitempty"`
	// Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.<br>
	Usepkcs11 *bool `json:"usepkcs11,omitempty"`
	// The client local path to the PKCS#11 provider(s) (DLL, module)<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11Providers []string `json:"pkcs11providers,omitempty"`
	// The object's ID on the PKCS#11 device.<br><br>This field is only available when the following conditions are met:<br>- `usepkcs11` must be equal to `true`<br>
	Pkcs11ID *string `json:"pkcs11id,omitempty"`
	// Use Microsoft Certificate Storage instead of local files.<br>
	Usetoken *bool `json:"usetoken,omitempty"`
	// Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.<br>
	Usepass *bool `json:"usepass,omitempty"`
	// Password used to protect the certificate file contents.<br><br>This field is only available when the following conditions are met:<br>- `usepass` must be equal to `true`<br>
	Pass *string `json:"pass,omitempty"`
	// The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program<br>
	P12Encryption *OpenVpnClientExportConfigP12Encryption `json:"p12encryption,omitempty"`
	// Use proxy to communicate with the OpenVPN server.<br>
	Useproxy *bool `json:"useproxy,omitempty"`
	// The proxy type to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxytype *OpenVpnClientExportConfigUseproxytype `json:"useproxytype,omitempty"`
	// The IP address or hostname of the proxy server to use.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyaddr *string `json:"proxyaddr,omitempty"`
	// The port where the proxy server is listening. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Proxyport *string `json:"proxyport,omitempty"`
	// The type of authentication to use for the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>
	Useproxypass *OpenVpnClientExportConfigUseproxypass `json:"useproxypass,omitempty"`
	// The username to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxyuser *string `json:"proxyuser,omitempty"`
	// The password to use to authenticate with the proxy server.<br><br>This field is only available when the following conditions are met:<br>- `useproxy` must be equal to `true`<br>- `useproxypass` must be one of [ basic, ntlm ]<br>
	Proxypass *string `json:"proxypass,omitempty"`
	// Additional options to add to the OpenVPN client export configuration.<br>
	Advancedoptions *string `json:"advancedoptions,omitempty"`
	ID              *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnOpenVpnClientExportConfigsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnOpenVpnClientExportConfigsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnOpenVpnClientExportConfigsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnOpenVpnClientExportConfigsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnWireGuardPeersEndpointRequestItem struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnWireGuardPeersEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnWireGuardPeersEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnWireGuardPeersEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnWireGuardPeersEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnWireGuardPeersEndpointResponse struct {
	Data []*PutVpnWireGuardPeersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnWireGuardPeersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnWireGuardPeersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnWireGuardPeersEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnWireGuardPeersEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnWireGuardPeersEndpointResponseDataItem struct {
	// Enables or disables this WireGuard peer.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The WireGuard tunnel for this peer.<br>
	Tun *string `json:"tun,omitempty"`
	// The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.<br>
	Endpoint *string `json:"endpoint,omitempty"`
	// The port used by the remote peer. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `endpoint` must not be equal to `NULL`<br>
	Port *string `json:"port,omitempty"`
	// The description for this peer.<br>
	Descr *string `json:"descr,omitempty"`
	// The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.<br>
	Persistentkeepalive *int `json:"persistentkeepalive,omitempty"`
	// The public key for this peer.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The pre-shared key for this tunnel.<br>
	Presharedkey *string `json:"presharedkey,omitempty"`
	// The allowed IP/subnets for this WireGuard peer.<br>
	Allowedips []*WireGuardPeerAllowedipsItem `json:"allowedips,omitempty"`
	ID         *int                           `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnWireGuardPeersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnWireGuardPeersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnWireGuardPeersEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnWireGuardPeersEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnWireGuardTunnelsEndpointRequestItem struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnWireGuardTunnelsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnWireGuardTunnelsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnWireGuardTunnelsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnWireGuardTunnelsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnWireGuardTunnelsEndpointResponse struct {
	Data []*PutVpnWireGuardTunnelsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnWireGuardTunnelsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnWireGuardTunnelsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnWireGuardTunnelsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnWireGuardTunnelsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpnWireGuardTunnelsEndpointResponseDataItem struct {
	// The name of the WireGuard interface. This value is automatically assigned by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// Enables or disables this tunnels and any associated peers.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// A description for this WireGuard tunnel.<br>
	Descr *string `json:"descr,omitempty"`
	// The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number<br>
	Listenport *string `json:"listenport,omitempty"`
	// The public key for this tunnel. This value is automatically derived from the `privatekey` value and cannot be set manually.<br>
	Publickey *string `json:"publickey,omitempty"`
	// The private key for this tunnel.<br>
	Privatekey *string `json:"privatekey,omitempty"`
	// The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.<br>
	Mtu *int `json:"mtu,omitempty"`
	// The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.<br>
	Addresses []*WireGuardTunnelAddressesItem `json:"addresses,omitempty"`
	ID        *int                            `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpnWireGuardTunnelsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpnWireGuardTunnelsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpnWireGuardTunnelsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpnWireGuardTunnelsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpniPsecPhase1SEndpointRequestItem struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpniPsecPhase1SEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpniPsecPhase1SEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpniPsecPhase1SEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpniPsecPhase1SEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpniPsecPhase1SEndpointResponse struct {
	Data []*PutVpniPsecPhase1SEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpniPsecPhase1SEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpniPsecPhase1SEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpniPsecPhase1SEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpniPsecPhase1SEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpniPsecPhase1SEndpointResponseDataItem struct {
	// The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 1 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 1 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IKE protocol version this phase 1 entry will use.<br>
	Iketype *IPsecPhase1Iketype `json:"iketype,omitempty"`
	// The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>
	Mode *IPsecPhase1Mode `json:"mode,omitempty"`
	// The IP version this phase 1 entry will use.<br>
	Protocol *IPsecPhase1Protocol `json:"protocol,omitempty"`
	// The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP address or hostname of the remote gateway.<br>
	RemoteGateway *string `json:"remote_gateway,omitempty"`
	// The IPsec authentication method this tunnel will use.<br>
	AuthenticationMethod *IPsecPhase1AuthenticationMethod `json:"authentication_method,omitempty"`
	// The identifier type used by the local end of the tunnel.<br>
	MyidType *IPsecPhase1MyidType `json:"myid_type,omitempty"`
	// The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>
	MyidData *string `json:"myid_data,omitempty"`
	// The identifier type used by the remote end of the tunnel.<br>
	PeeridType *IPsecPhase1PeeridType `json:"peerid_type,omitempty"`
	// The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>
	PeeridData *string `json:"peerid_data,omitempty"`
	// The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>
	PreSharedKey *string `json:"pre_shared_key,omitempty"`
	// The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Certref *string `json:"certref,omitempty"`
	// The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>
	Caref *string `json:"caref,omitempty"`
	// The amount of time (in seconds) before an child SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>
	ReauthTime *int `json:"reauth_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>
	Startaction *IPsecPhase1Startaction `json:"startaction,omitempty"`
	// The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>
	Closeaction *IPsecPhase1Closeaction `json:"closeaction,omitempty"`
	// The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>
	NatTraversal *IPsecPhase1NatTraversal `json:"nat_traversal,omitempty"`
	// Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>
	GwDuplicates *bool `json:"gw_duplicates,omitempty"`
	// Enables or disables the use of MOBIKE for this tunnel.<br>
	Mobike *bool `json:"mobike,omitempty"`
	// Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>
	Splitconn *bool `json:"splitconn,omitempty"`
	// Enables or disables manual Pseudo-Random Function (PRF) selection.<br>
	PrfselectEnable *bool `json:"prfselect_enable,omitempty"`
	// The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Ikeport *string `json:"ikeport,omitempty"`
	// The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>
	Nattport *string `json:"nattport,omitempty"`
	// The delay (in seconds) between sending peer acknowledgement messages.<br>
	DpdDelay *int `json:"dpd_delay,omitempty"`
	// The number of consecutive failures allowed before disconnecting.<br>
	DpdMaxfail *int `json:"dpd_maxfail,omitempty"`
	// The encryption algorithms supported by this P1 encryption.<br>
	Encryption []*IPsecPhase1EncryptionItem `json:"encryption,omitempty"`
	ID         *int                         `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpniPsecPhase1SEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpniPsecPhase1SEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpniPsecPhase1SEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpniPsecPhase1SEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpniPsecPhase2SEndpointRequestItem struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpniPsecPhase2SEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpniPsecPhase2SEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpniPsecPhase2SEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpniPsecPhase2SEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpniPsecPhase2SEndpointResponse struct {
	Data []*PutVpniPsecPhase2SEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpniPsecPhase2SEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpniPsecPhase2SEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpniPsecPhase2SEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpniPsecPhase2SEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutVpniPsecPhase2SEndpointResponseDataItem struct {
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>
	Reqid *int `json:"reqid,omitempty"`
	// The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>
	Ikeid *int `json:"ikeid,omitempty"`
	// A description for this IPsec phase 2 entry.<br>
	Descr *string `json:"descr,omitempty"`
	// Disables this IPsec phase 2 entry.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// The IPsec phase 2 mode this entry will use.<br>
	Mode *IPsecPhase2Mode `json:"mode,omitempty"`
	// The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	LocalidType *string `json:"localid_type,omitempty"`
	// The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>
	LocalidAddress *string `json:"localid_address,omitempty"`
	// The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>
	LocalidNetbits *int `json:"localid_netbits,omitempty"`
	// The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>
	NatlocalidType *string `json:"natlocalid_type,omitempty"`
	// The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>
	NatlocalidAddress *string `json:"natlocalid_address,omitempty"`
	// The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>
	NatlocalidNetbits *int `json:"natlocalid_netbits,omitempty"`
	// The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>
	RemoteidType *string `json:"remoteid_type,omitempty"`
	// The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>
	RemoteidAddress *string `json:"remoteid_address,omitempty"`
	// The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>
	RemoteidNetbits *int `json:"remoteid_netbits,omitempty"`
	// the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>
	Protocol *IPsecPhase2Protocol `json:"protocol,omitempty"`
	// The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>
	EncryptionAlgorithmOption []*IPsecPhase2EncryptionAlgorithmOptionItem `json:"encryption_algorithm_option,omitempty"`
	// The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>
	HashAlgorithmOption []IPsecPhase2HashAlgorithmOptionItem `json:"hash_algorithm_option,omitempty"`
	// The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>
	Pfsgroup *int `json:"pfsgroup,omitempty"`
	// The amount of time (in seconds) before an IKE SA establishes new keys.<br>
	RekeyTime *int `json:"rekey_time,omitempty"`
	// A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>
	RandTime *int `json:"rand_time,omitempty"`
	// The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>
	Pinghost *string `json:"pinghost,omitempty"`
	// Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>
	Keepalive *bool `json:"keepalive,omitempty"`
	ID        *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutVpniPsecPhase2SEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutVpniPsecPhase2SEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutVpniPsecPhase2SEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutVpniPsecPhase2SEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
