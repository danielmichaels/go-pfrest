// This file was auto-generated by Fern from our API Definition.

package pfclientapi

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/danielmichaels/go-pfrest/pkg/client/core"
)

type DeleteSystemCrlEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteSystemCrlRevokedCertificateEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteSystemCrLsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteSystemCertificateAuthoritiesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteSystemCertificateAuthorityEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteSystemCertificateEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteSystemCertificatesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteSystemPackageEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteSystemPackagesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteSystemRestapiAccessListEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteSystemRestapiAccessListEntryEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteSystemTunableEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteSystemTunablesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetSystemCrlEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetSystemCrlRevokedCertificateEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetSystemCrLsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetSystemCrLsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetSystemCrLsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetSystemCertificateAuthoritiesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetSystemCertificateAuthoritiesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetSystemCertificateAuthoritiesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetSystemCertificateAuthorityEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetSystemCertificateEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetSystemCertificatesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetSystemCertificatesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetSystemCertificatesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetSystemPackageAvailableEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetSystemPackageAvailableEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetSystemPackageAvailableEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetSystemPackageEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetSystemPackagesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetSystemPackagesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetSystemPackagesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetSystemRestapiAccessListEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetSystemRestapiAccessListEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetSystemRestapiAccessListEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetSystemRestapiAccessListEntryEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetSystemTunableEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetSystemTunablesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetSystemTunablesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetSystemTunablesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type PatchSystemCrlEndpointRequest struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchSystemCrlRevokedCertificateEndpointRequest struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchSystemCertificateAuthorityEndpointRequest struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchSystemCertificateEndpointRequest struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchSystemConsoleEndpointRequest struct {
	// Enables or disables password protecting the console.<br>
	PasswdProtectConsole *bool `json:"passwd_protect_console,omitempty"`
}

type PatchSystemDNSEndpointRequest struct {
	// Allow DNS servers to be overwritten by DHCP on WAN interfaces.<br>
	Dnsallowoverride *bool `json:"dnsallowoverride,omitempty"`
	// Use local DNS server (DNS Resover or DNS Forwarder) as the primary DNS, or use only remote DNS servers specified in `dnsserver`. Set to `null` to use local DNS server as the primary and remote DNS servers as backup.<br>
	Dnslocalhost *SystemDNSDnslocalhost `json:"dnslocalhost,omitempty"`
	// The remote DNS server IPv4 or IPv6 addresses.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`
}

type PatchSystemHostnameEndpointRequest struct {
	// The hostname portion of the FQDN to assign to this system.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain portion of the FQDN to assign to this system.<br>
	Domain *string `json:"domain,omitempty"`
}

type PatchSystemNotificationsEmailSettingsEndpointRequest struct {
	// Disables SMTP notifications.<br>
	Disable *bool `json:"disable,omitempty"`
	// The IP address or hostname of the SMTP server.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The port number of the SMTP server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The timeout (in seconds) for the SMTP connection.<br>
	Timeout *int `json:"timeout,omitempty"`
	// Enables or disables SSL/TLS for the SMTP connection.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables SSL/TLS certificate validation for the SMTP connection.<br>
	Sslvalidate *bool `json:"sslvalidate,omitempty"`
	// The email address to use as the "From" address in notifications.<br>
	Fromaddress *string `json:"fromaddress,omitempty"`
	// The email address to send notifications to.<br>
	Notifyemailaddress *string `json:"notifyemailaddress,omitempty"`
	// The authentication mechanism to use for the SMTP connection.<br>
	AuthenticationMechanism *EmailNotificationSettingsAuthenticationMechanism `json:"authentication_mechanism,omitempty"`
	// The username to use for SMTP authentication.<br><br>This field is only available when the following conditions are met:<br>- `authentication_mechanism` must be equal to `'LOGIN'`<br>
	Username *string `json:"username,omitempty"`
	// The password to use for SMTP authentication.<br><br>This field is only available when the following conditions are met:<br>- `authentication_mechanism` must be equal to `'LOGIN'`<br>
	Password *string `json:"password,omitempty"`
}

type PatchSystemRestapiAccessListEntryEndpointRequest struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchSystemRestapiSettingsEndpointRequest struct {
	// Enables or disables the API. If set to `false`, the API will no longer respond to API requests
	//
	//	and can only be re-enabled via webConfigurator.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// Enables or disables read-only API access. If enabled, the API will only respond to GET requests
	//
	//	and can only be disabled via webConfigurator.<br>
	ReadOnly *bool `json:"read_only,omitempty"`
	// Enables or disables keeping a persistent backup of the API configuration that can be used
	//
	//	to restore the API configuration after package and systems updates.<br>
	KeepBackup *bool `json:"keep_backup,omitempty"`
	// Enables or disables Login Protection for API authentication. When enabled, Login Protection will
	//
	//	monitor API attempts and temporarily block clients who fail API authentication too many times within a
	//	period of time. When disabled, Login Protection will not monitor API authentication but will continue to
	//	monitor webConfigurator and SSH logins (if configured). Login Protection can be configured globally in
	//	System > Advanced.<br>
	LoginProtection *bool `json:"login_protection,omitempty"`
	// Enables or disables logging of API authentication attempts that are successful. By default, only
	//
	//	failed API authentication attempts are logged to prevent flooding the authentication logs. This field is
	//	only applicable when the API `login_protection` setting is enabled.<br>
	LogSuccessfulAuth *bool `json:"log_successful_auth,omitempty"`
	// Sets the log level for API logging. The log level determines the minimum severity of messages
	//
	//	that should be logged.<br>
	LogLevel *RestapiSettingsLogLevel `json:"log_level,omitempty"`
	// Enables or disables displaying pre-releases in available API updates. Pre-releases contain fixes
	//
	//	and features that are currently under development and may not be fully stable. Use of pre-release versions
	//	is at your own risk.<br>
	AllowPreReleases *bool `json:"allow_pre_releases,omitempty"`
	// Enables or disables HATEOAS. Enabling HATEOAS will allow the API to include links to related resources in API responses. This is primarily useful for frontend web applications and self-navigating client scripts that integrate with HAL standards. Enabling HATEOAS may increase API response times, especially on systems with large configurations.<br>
	Hateoas *bool `json:"hateoas,omitempty"`
	// Enables or disables exposing sensitive fields in API responses. When enabled, sensitive fields such as passwords, private keys, and other sensitive data will be included in API responses.<br>
	ExposeSensitiveFields *bool `json:"expose_sensitive_fields,omitempty"`
	// Specifies a list of fields (formatted as ModelName:FieldName) that should have their sensitive attribute overridden. Fields selected here will not be considered sensitive and will be included in API responses regardless of the `expose_sensitive_fields` setting.<br><br>This field is only available when the following conditions are met:<br>- `expose_sensitive_fields` must be equal to `false`<br>
	OverrideSensitiveFields []string `json:"override_sensitive_fields,omitempty"`
	// Sets the interfaces allowed to accept incoming API calls.<br>
	AllowedInterfaces []string `json:"allowed_interfaces,omitempty"`
	// Specifies how the API should represent interface names. Use `descr` to represent
	//
	//	interface objects by their description name, use `id` to represent interface objects by their
	//	internal pfSense ID (e.g. wan, lan, opt1), or use `if` to represent interface objects by their
	//	real interface name (e.g. em0, igb1, bxe3).<br>
	RepresentInterfacesAs *RestapiSettingsRepresentInterfacesAs `json:"represent_interfaces_as,omitempty"`
	// Sets the API authentication methods allowed to authenticate API calls.<br>
	AuthMethods []string `json:"auth_methods,omitempty"`
	// Sets the amount of time (in seconds) JWTs are valid for.<br>
	JwtExp *int `json:"jwt_exp,omitempty"`
	// Enables or disables syncing API settings to HA peers. When enabled, API settings from this
	//
	//	host will automatically be synced to any hosts defined in `ha_sync_hosts`.<br>
	HaSync *bool `json:"ha_sync,omitempty"`
	// Enables or disables certificate validation when syncing API configurations to HA sync peers. If
	//
	//	enabled, all hosts defined in `ha_sync_hosts` must have their webConfigurator configured with a certificate
	//	trusted by this system. It is strongly recommended this be enabled at all times to help mitigate
	//	Man-in-the-Middle attacks.<br>
	HaSyncValidateCerts *bool `json:"ha_sync_validate_certs,omitempty"`
	// Set a list of IP addresses or hostnames to sync API settings to.<br>
	HaSyncHosts []string `json:"ha_sync_hosts,omitempty"`
	// Sets the username to use when authenticating for HA sync processes. This user must be the present
	//
	//	on all hosts defined in `ha_sync_hosts`.<br>
	HaSyncUsername *string `json:"ha_sync_username,omitempty"`
	// Sets the password to use when authenticating for HA sync processes. This must be the password
	//
	//	for the user defined in `ha_sync_username` and must be the same on all hosts defined in `ha_sync_hosts`.<br>
	HaSyncPassword *string `json:"ha_sync_password,omitempty"`
}

type PatchSystemRestapiVersionEndpointRequest struct {
	// The current API version installed on this system.<br>
	CurrentVersion *string `json:"current_version,omitempty"`
	// The latest API version available to this system.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// The latest API version's release date.<br>
	LatestVersionReleaseDate *string `json:"latest_version_release_date,omitempty"`
	// Indicates if an API update is available for this system.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
	// Set the API version to update or rollback to.<br>
	InstallVersion *string `json:"install_version,omitempty"`
	// All available versions of the REST API package for this system.<br>
	AvailableVersions []string `json:"available_versions,omitempty"`
}

type PatchSystemTimezoneEndpointRequest struct {
	// Set geographic region name (Continent/Location) to determine the timezone for the firewall.<br>
	Timezone *string `json:"timezone,omitempty"`
}

type PatchSystemTunableEndpointRequest struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchSystemWebGuiSettingsEndpointRequest struct {
	// The protocol to use for the web GUI.<br>
	Protocol *WebGuiSettingsProtocol `json:"protocol,omitempty"`
	// The port on which the web GUI listens. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The SSL/TLS certificate to use for the web GUI.<br>
	Sslcertref *string `json:"sslcertref,omitempty"`
}

type PostSystemCrlEndpointRequest struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
}

type PostSystemCrlRevokedCertificateEndpointRequest struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostSystemCertificateAuthorityEndpointRequest struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
}

type PostSystemCertificateAuthorityGenerateEndpointRequest struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// Indicates if this certificate authority is an intermediate certificate authority.<br>
	IsIntermediate *bool `json:"is_intermediate,omitempty"`
	// The certificate authority to use as the parent for this intermediate certificate authority.<br><br>This field is only available when the following conditions are met:<br>- `is_intermediate` must be equal to `true`<br>
	Caref *string `json:"caref,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateAuthorityGenerateKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest algorithm to use when signing certificates.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate authority is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name for the certificate authority.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country for the certificate authority.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state for the certificate authority.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city for the certificate authority.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization for the certificate authority.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit for the certificate authority.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
}

type PostSystemCertificateAuthorityRenewEndpointRequest struct {
	// The Certificate Authority to renew.<br>
	Caref *string `json:"caref,omitempty"`
	// Reuses the existing private key when renewing the certificate authority.<br>
	Reusekey *bool `json:"reusekey,omitempty"`
	// Reuses the existing serial number when renewing the certificate authority.<br>
	Reuseserial *bool `json:"reuseserial,omitempty"`
	// Enforces strict security measures when renewing the certificate authority.<br>
	Strictsecurity *bool `json:"strictsecurity,omitempty"`
	// The old serial number of the Certificate Authority before the renewal.<br>
	Oldserial *string `json:"oldserial,omitempty"`
	// The new serial number of the Certificate Authority after the renewal.<br>
	Newserial *string `json:"newserial,omitempty"`
}

type PostSystemCertificateEndpointRequest struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
}

type PostSystemCertificateGenerateEndpointRequest struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The certificate authority to use as the parent for this certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateGenerateKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name of the certificate.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country of the certificate.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state/province of the certificate.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city of the certificate.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization of the certificate.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit of the certificate.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateGenerateType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
}

type PostSystemCertificatePkcs12ExportEndpointRequest struct {
	// The Certificate to export as a PKCS12 file.<br>
	Certref *string `json:"certref,omitempty"`
	// The level of encryption to use when exporting the PKCS#12 archive.<br>
	Encryption *CertificatePkcs12ExportEncryption `json:"encryption,omitempty"`
	// The passphrase to use when exporting the PKCS#12 archive. Leave empty for no passphrase.<br>
	Passphrase *string `json:"passphrase,omitempty"`
	// The filename used when exporting the PKCS#12 archive. This value cannot be changed and will always be certificate refid with the .p12 extension.<br>
	Filename *string `json:"filename,omitempty"`
	// The PKCS#12 archive binary data. This value cannot be changed.<br>
	BinaryData *string `json:"binary_data,omitempty"`
}

type PostSystemCertificateRenewEndpointRequest struct {
	// The `refid` of the Certificate to renew.<br>
	Certref *string `json:"certref,omitempty"`
	// Reuses the existing private key when renewing the certificate.<br>
	Reusekey *bool `json:"reusekey,omitempty"`
	// Reuses the existing serial number when renewing the certificate.<br>
	Reuseserial *bool `json:"reuseserial,omitempty"`
	// Enforces strict security measures when renewing the certificate.<br>
	Strictsecurity *bool `json:"strictsecurity,omitempty"`
	// The old serial number of the Certificate before the renewal.<br>
	Oldserial *string `json:"oldserial,omitempty"`
	// The new serial number of the Certificate after the renewal.<br>
	Newserial *string `json:"newserial,omitempty"`
}

type PostSystemCertificateSigningRequestEndpointRequest struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateSigningRequestKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name of the certificate.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country of the certificate.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state/province of the certificate.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city of the certificate.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization of the certificate.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit of the certificate.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateSigningRequestType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
	// The X509 certificate signing request string. You will need to provide this to a certificate authority to sign the certificate.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
}

type PostSystemCertificateSigningRequestSignEndpointRequest struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The certificate authority to sign the certificate with.<br>
	Caref *string `json:"caref,omitempty"`
	// The X509 certificate signing request to sign.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateSigningRequestSignType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
}

type PostSystemPackageEndpointRequest struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The version of the package currently installed.<br>
	InstalledVersion *string `json:"installed_version,omitempty"`
	// The latest version available for this package.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// Indicates whether the installed package has an update available.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
}

type PostSystemRestapiAccessListEntryEndpointRequest struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
}

type PostSystemRestapiSettingsSyncEndpointRequest struct {
	// The serialized REST API settings data to be synced.<br>
	SyncData *string `json:"sync_data,omitempty"`
}

type PostSystemTunableEndpointRequest struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
}

type AvailablePackage struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The latest version available for this package.<br>
	Version *string `json:"version,omitempty"`
	// Indicates whether the package is currently installed or not.<br>
	Installed *bool `json:"installed,omitempty"`
	// Dependencies for this package that are also installed when this package is installed.<br>
	Deps []string `json:"deps,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AvailablePackage) UnmarshalJSON(data []byte) error {
	type unmarshaler AvailablePackage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AvailablePackage(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AvailablePackage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Certificate struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Certificate) UnmarshalJSON(data []byte) error {
	type unmarshaler Certificate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Certificate(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Certificate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CertificateAuthority struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateAuthority) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateAuthority
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateAuthority(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateAuthority) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CertificateAuthorityGenerate struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// Indicates if this certificate authority is an intermediate certificate authority.<br>
	IsIntermediate *bool `json:"is_intermediate,omitempty"`
	// The certificate authority to use as the parent for this intermediate certificate authority.<br><br>This field is only available when the following conditions are met:<br>- `is_intermediate` must be equal to `true`<br>
	Caref *string `json:"caref,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateAuthorityGenerateKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest algorithm to use when signing certificates.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate authority is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name for the certificate authority.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country for the certificate authority.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state for the certificate authority.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city for the certificate authority.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization for the certificate authority.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit for the certificate authority.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateAuthorityGenerate) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateAuthorityGenerate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateAuthorityGenerate(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateAuthorityGenerate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of key pair to generate.<br>
type CertificateAuthorityGenerateKeytype string

const (
	CertificateAuthorityGenerateKeytypeRsa   CertificateAuthorityGenerateKeytype = "RSA"
	CertificateAuthorityGenerateKeytypeEcdsa CertificateAuthorityGenerateKeytype = "ECDSA"
)

func NewCertificateAuthorityGenerateKeytypeFromString(s string) (CertificateAuthorityGenerateKeytype, error) {
	switch s {
	case "RSA":
		return CertificateAuthorityGenerateKeytypeRsa, nil
	case "ECDSA":
		return CertificateAuthorityGenerateKeytypeEcdsa, nil
	}
	var t CertificateAuthorityGenerateKeytype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateAuthorityGenerateKeytype) Ptr() *CertificateAuthorityGenerateKeytype {
	return &c
}

type CertificateAuthorityRenew struct {
	// The Certificate Authority to renew.<br>
	Caref *string `json:"caref,omitempty"`
	// Reuses the existing private key when renewing the certificate authority.<br>
	Reusekey *bool `json:"reusekey,omitempty"`
	// Reuses the existing serial number when renewing the certificate authority.<br>
	Reuseserial *bool `json:"reuseserial,omitempty"`
	// Enforces strict security measures when renewing the certificate authority.<br>
	Strictsecurity *bool `json:"strictsecurity,omitempty"`
	// The old serial number of the Certificate Authority before the renewal.<br>
	Oldserial *string `json:"oldserial,omitempty"`
	// The new serial number of the Certificate Authority after the renewal.<br>
	Newserial *string `json:"newserial,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateAuthorityRenew) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateAuthorityRenew
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateAuthorityRenew(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateAuthorityRenew) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CertificateGenerate struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The certificate authority to use as the parent for this certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateGenerateKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name of the certificate.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country of the certificate.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state/province of the certificate.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city of the certificate.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization of the certificate.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit of the certificate.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateGenerateType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateGenerate) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateGenerate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateGenerate(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateGenerate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of key pair to generate.<br>
type CertificateGenerateKeytype string

const (
	CertificateGenerateKeytypeRsa   CertificateGenerateKeytype = "RSA"
	CertificateGenerateKeytypeEcdsa CertificateGenerateKeytype = "ECDSA"
)

func NewCertificateGenerateKeytypeFromString(s string) (CertificateGenerateKeytype, error) {
	switch s {
	case "RSA":
		return CertificateGenerateKeytypeRsa, nil
	case "ECDSA":
		return CertificateGenerateKeytypeEcdsa, nil
	}
	var t CertificateGenerateKeytype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateGenerateKeytype) Ptr() *CertificateGenerateKeytype {
	return &c
}

// The type of certificate to generate.<br>
type CertificateGenerateType string

const (
	CertificateGenerateTypeServer CertificateGenerateType = "server"
	CertificateGenerateTypeUser   CertificateGenerateType = "user"
)

func NewCertificateGenerateTypeFromString(s string) (CertificateGenerateType, error) {
	switch s {
	case "server":
		return CertificateGenerateTypeServer, nil
	case "user":
		return CertificateGenerateTypeUser, nil
	}
	var t CertificateGenerateType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateGenerateType) Ptr() *CertificateGenerateType {
	return &c
}

type CertificatePkcs12Export struct {
	// The Certificate to export as a PKCS12 file.<br>
	Certref *string `json:"certref,omitempty"`
	// The level of encryption to use when exporting the PKCS#12 archive.<br>
	Encryption *CertificatePkcs12ExportEncryption `json:"encryption,omitempty"`
	// The passphrase to use when exporting the PKCS#12 archive. Leave empty for no passphrase.<br>
	Passphrase *string `json:"passphrase,omitempty"`
	// The filename used when exporting the PKCS#12 archive. This value cannot be changed and will always be certificate refid with the .p12 extension.<br>
	Filename *string `json:"filename,omitempty"`
	// The PKCS#12 archive binary data. This value cannot be changed.<br>
	BinaryData *string `json:"binary_data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificatePkcs12Export) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificatePkcs12Export
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificatePkcs12Export(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificatePkcs12Export) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The level of encryption to use when exporting the PKCS#12 archive.<br>
type CertificatePkcs12ExportEncryption string

const (
	CertificatePkcs12ExportEncryptionHigh   CertificatePkcs12ExportEncryption = "high"
	CertificatePkcs12ExportEncryptionLow    CertificatePkcs12ExportEncryption = "low"
	CertificatePkcs12ExportEncryptionLegacy CertificatePkcs12ExportEncryption = "legacy"
)

func NewCertificatePkcs12ExportEncryptionFromString(s string) (CertificatePkcs12ExportEncryption, error) {
	switch s {
	case "high":
		return CertificatePkcs12ExportEncryptionHigh, nil
	case "low":
		return CertificatePkcs12ExportEncryptionLow, nil
	case "legacy":
		return CertificatePkcs12ExportEncryptionLegacy, nil
	}
	var t CertificatePkcs12ExportEncryption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificatePkcs12ExportEncryption) Ptr() *CertificatePkcs12ExportEncryption {
	return &c
}

type CertificateRenew struct {
	// The `refid` of the Certificate to renew.<br>
	Certref *string `json:"certref,omitempty"`
	// Reuses the existing private key when renewing the certificate.<br>
	Reusekey *bool `json:"reusekey,omitempty"`
	// Reuses the existing serial number when renewing the certificate.<br>
	Reuseserial *bool `json:"reuseserial,omitempty"`
	// Enforces strict security measures when renewing the certificate.<br>
	Strictsecurity *bool `json:"strictsecurity,omitempty"`
	// The old serial number of the Certificate before the renewal.<br>
	Oldserial *string `json:"oldserial,omitempty"`
	// The new serial number of the Certificate after the renewal.<br>
	Newserial *string `json:"newserial,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateRenew) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateRenew
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateRenew(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateRenew) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CertificateRevocationList struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateRevocationList) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateRevocationList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateRevocationList(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateRevocationList) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CertificateRevocationListCertItem struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateRevocationListCertItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateRevocationListCertItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateRevocationListCertItem(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateRevocationListCertItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The method used to generate this CRL.<br>
type CertificateRevocationListMethod string

const (
	CertificateRevocationListMethodExisting CertificateRevocationListMethod = "existing"
	CertificateRevocationListMethodInternal CertificateRevocationListMethod = "internal"
)

func NewCertificateRevocationListMethodFromString(s string) (CertificateRevocationListMethod, error) {
	switch s {
	case "existing":
		return CertificateRevocationListMethodExisting, nil
	case "internal":
		return CertificateRevocationListMethodInternal, nil
	}
	var t CertificateRevocationListMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateRevocationListMethod) Ptr() *CertificateRevocationListMethod {
	return &c
}

type CertificateRevocationListRevokedCertificate struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateRevocationListRevokedCertificate) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateRevocationListRevokedCertificate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateRevocationListRevokedCertificate(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateRevocationListRevokedCertificate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CertificateSigningRequest struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateSigningRequestKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name of the certificate.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country of the certificate.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state/province of the certificate.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city of the certificate.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization of the certificate.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit of the certificate.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateSigningRequestType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
	// The X509 certificate signing request string. You will need to provide this to a certificate authority to sign the certificate.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateSigningRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateSigningRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateSigningRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateSigningRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of key pair to generate.<br>
type CertificateSigningRequestKeytype string

const (
	CertificateSigningRequestKeytypeRsa   CertificateSigningRequestKeytype = "RSA"
	CertificateSigningRequestKeytypeEcdsa CertificateSigningRequestKeytype = "ECDSA"
)

func NewCertificateSigningRequestKeytypeFromString(s string) (CertificateSigningRequestKeytype, error) {
	switch s {
	case "RSA":
		return CertificateSigningRequestKeytypeRsa, nil
	case "ECDSA":
		return CertificateSigningRequestKeytypeEcdsa, nil
	}
	var t CertificateSigningRequestKeytype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateSigningRequestKeytype) Ptr() *CertificateSigningRequestKeytype {
	return &c
}

type CertificateSigningRequestSign struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The certificate authority to sign the certificate with.<br>
	Caref *string `json:"caref,omitempty"`
	// The X509 certificate signing request to sign.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateSigningRequestSignType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CertificateSigningRequestSign) UnmarshalJSON(data []byte) error {
	type unmarshaler CertificateSigningRequestSign
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CertificateSigningRequestSign(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CertificateSigningRequestSign) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of certificate to generate.<br>
type CertificateSigningRequestSignType string

const (
	CertificateSigningRequestSignTypeServer CertificateSigningRequestSignType = "server"
	CertificateSigningRequestSignTypeUser   CertificateSigningRequestSignType = "user"
)

func NewCertificateSigningRequestSignTypeFromString(s string) (CertificateSigningRequestSignType, error) {
	switch s {
	case "server":
		return CertificateSigningRequestSignTypeServer, nil
	case "user":
		return CertificateSigningRequestSignTypeUser, nil
	}
	var t CertificateSigningRequestSignType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateSigningRequestSignType) Ptr() *CertificateSigningRequestSignType {
	return &c
}

// The type of certificate to generate.<br>
type CertificateSigningRequestType string

const (
	CertificateSigningRequestTypeServer CertificateSigningRequestType = "server"
	CertificateSigningRequestTypeUser   CertificateSigningRequestType = "user"
)

func NewCertificateSigningRequestTypeFromString(s string) (CertificateSigningRequestType, error) {
	switch s {
	case "server":
		return CertificateSigningRequestTypeServer, nil
	case "user":
		return CertificateSigningRequestTypeUser, nil
	}
	var t CertificateSigningRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateSigningRequestType) Ptr() *CertificateSigningRequestType {
	return &c
}

// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
type CertificateType string

const (
	CertificateTypeServer CertificateType = "server"
	CertificateTypeUser   CertificateType = "user"
)

func NewCertificateTypeFromString(s string) (CertificateType, error) {
	switch s {
	case "server":
		return CertificateTypeServer, nil
	case "user":
		return CertificateTypeUser, nil
	}
	var t CertificateType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CertificateType) Ptr() *CertificateType {
	return &c
}

type EmailNotificationSettings struct {
	// Disables SMTP notifications.<br>
	Disable *bool `json:"disable,omitempty"`
	// The IP address or hostname of the SMTP server.<br>
	Ipaddress *string `json:"ipaddress,omitempty"`
	// The port number of the SMTP server. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The timeout (in seconds) for the SMTP connection.<br>
	Timeout *int `json:"timeout,omitempty"`
	// Enables or disables SSL/TLS for the SMTP connection.<br>
	Ssl *bool `json:"ssl,omitempty"`
	// Enables or disables SSL/TLS certificate validation for the SMTP connection.<br>
	Sslvalidate *bool `json:"sslvalidate,omitempty"`
	// The email address to use as the "From" address in notifications.<br>
	Fromaddress *string `json:"fromaddress,omitempty"`
	// The email address to send notifications to.<br>
	Notifyemailaddress *string `json:"notifyemailaddress,omitempty"`
	// The authentication mechanism to use for the SMTP connection.<br>
	AuthenticationMechanism *EmailNotificationSettingsAuthenticationMechanism `json:"authentication_mechanism,omitempty"`
	// The username to use for SMTP authentication.<br><br>This field is only available when the following conditions are met:<br>- `authentication_mechanism` must be equal to `'LOGIN'`<br>
	Username *string `json:"username,omitempty"`
	// The password to use for SMTP authentication.<br><br>This field is only available when the following conditions are met:<br>- `authentication_mechanism` must be equal to `'LOGIN'`<br>
	Password *string `json:"password,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailNotificationSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailNotificationSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailNotificationSettings(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailNotificationSettings) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The authentication mechanism to use for the SMTP connection.<br>
type EmailNotificationSettingsAuthenticationMechanism string

const (
	EmailNotificationSettingsAuthenticationMechanismPlain EmailNotificationSettingsAuthenticationMechanism = "PLAIN"
	EmailNotificationSettingsAuthenticationMechanismLogin EmailNotificationSettingsAuthenticationMechanism = "LOGIN"
)

func NewEmailNotificationSettingsAuthenticationMechanismFromString(s string) (EmailNotificationSettingsAuthenticationMechanism, error) {
	switch s {
	case "PLAIN":
		return EmailNotificationSettingsAuthenticationMechanismPlain, nil
	case "LOGIN":
		return EmailNotificationSettingsAuthenticationMechanismLogin, nil
	}
	var t EmailNotificationSettingsAuthenticationMechanism
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmailNotificationSettingsAuthenticationMechanism) Ptr() *EmailNotificationSettingsAuthenticationMechanism {
	return &e
}

type Package struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The version of the package currently installed.<br>
	InstalledVersion *string `json:"installed_version,omitempty"`
	// The latest version available for this package.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// Indicates whether the installed package has an update available.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Package) UnmarshalJSON(data []byte) error {
	type unmarshaler Package
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Package(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Package) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RestapiAccessListEntry struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RestapiAccessListEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler RestapiAccessListEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RestapiAccessListEntry(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RestapiAccessListEntry) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
type RestapiAccessListEntryType string

const (
	RestapiAccessListEntryTypeAllow RestapiAccessListEntryType = "allow"
	RestapiAccessListEntryTypeDeny  RestapiAccessListEntryType = "deny"
)

func NewRestapiAccessListEntryTypeFromString(s string) (RestapiAccessListEntryType, error) {
	switch s {
	case "allow":
		return RestapiAccessListEntryTypeAllow, nil
	case "deny":
		return RestapiAccessListEntryTypeDeny, nil
	}
	var t RestapiAccessListEntryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RestapiAccessListEntryType) Ptr() *RestapiAccessListEntryType {
	return &r
}

type RestapiSettings struct {
	// Enables or disables the API. If set to `false`, the API will no longer respond to API requests
	//
	//	and can only be re-enabled via webConfigurator.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// Enables or disables read-only API access. If enabled, the API will only respond to GET requests
	//
	//	and can only be disabled via webConfigurator.<br>
	ReadOnly *bool `json:"read_only,omitempty"`
	// Enables or disables keeping a persistent backup of the API configuration that can be used
	//
	//	to restore the API configuration after package and systems updates.<br>
	KeepBackup *bool `json:"keep_backup,omitempty"`
	// Enables or disables Login Protection for API authentication. When enabled, Login Protection will
	//
	//	monitor API attempts and temporarily block clients who fail API authentication too many times within a
	//	period of time. When disabled, Login Protection will not monitor API authentication but will continue to
	//	monitor webConfigurator and SSH logins (if configured). Login Protection can be configured globally in
	//	System > Advanced.<br>
	LoginProtection *bool `json:"login_protection,omitempty"`
	// Enables or disables logging of API authentication attempts that are successful. By default, only
	//
	//	failed API authentication attempts are logged to prevent flooding the authentication logs. This field is
	//	only applicable when the API `login_protection` setting is enabled.<br>
	LogSuccessfulAuth *bool `json:"log_successful_auth,omitempty"`
	// Sets the log level for API logging. The log level determines the minimum severity of messages
	//
	//	that should be logged.<br>
	LogLevel *RestapiSettingsLogLevel `json:"log_level,omitempty"`
	// Enables or disables displaying pre-releases in available API updates. Pre-releases contain fixes
	//
	//	and features that are currently under development and may not be fully stable. Use of pre-release versions
	//	is at your own risk.<br>
	AllowPreReleases *bool `json:"allow_pre_releases,omitempty"`
	// Enables or disables HATEOAS. Enabling HATEOAS will allow the API to include links to related resources in API responses. This is primarily useful for frontend web applications and self-navigating client scripts that integrate with HAL standards. Enabling HATEOAS may increase API response times, especially on systems with large configurations.<br>
	Hateoas *bool `json:"hateoas,omitempty"`
	// Enables or disables exposing sensitive fields in API responses. When enabled, sensitive fields such as passwords, private keys, and other sensitive data will be included in API responses.<br>
	ExposeSensitiveFields *bool `json:"expose_sensitive_fields,omitempty"`
	// Specifies a list of fields (formatted as ModelName:FieldName) that should have their sensitive attribute overridden. Fields selected here will not be considered sensitive and will be included in API responses regardless of the `expose_sensitive_fields` setting.<br><br>This field is only available when the following conditions are met:<br>- `expose_sensitive_fields` must be equal to `false`<br>
	OverrideSensitiveFields []string `json:"override_sensitive_fields,omitempty"`
	// Sets the interfaces allowed to accept incoming API calls.<br>
	AllowedInterfaces []string `json:"allowed_interfaces,omitempty"`
	// Specifies how the API should represent interface names. Use `descr` to represent
	//
	//	interface objects by their description name, use `id` to represent interface objects by their
	//	internal pfSense ID (e.g. wan, lan, opt1), or use `if` to represent interface objects by their
	//	real interface name (e.g. em0, igb1, bxe3).<br>
	RepresentInterfacesAs *RestapiSettingsRepresentInterfacesAs `json:"represent_interfaces_as,omitempty"`
	// Sets the API authentication methods allowed to authenticate API calls.<br>
	AuthMethods []string `json:"auth_methods,omitempty"`
	// Sets the amount of time (in seconds) JWTs are valid for.<br>
	JwtExp *int `json:"jwt_exp,omitempty"`
	// Enables or disables syncing API settings to HA peers. When enabled, API settings from this
	//
	//	host will automatically be synced to any hosts defined in `ha_sync_hosts`.<br>
	HaSync *bool `json:"ha_sync,omitempty"`
	// Enables or disables certificate validation when syncing API configurations to HA sync peers. If
	//
	//	enabled, all hosts defined in `ha_sync_hosts` must have their webConfigurator configured with a certificate
	//	trusted by this system. It is strongly recommended this be enabled at all times to help mitigate
	//	Man-in-the-Middle attacks.<br>
	HaSyncValidateCerts *bool `json:"ha_sync_validate_certs,omitempty"`
	// Set a list of IP addresses or hostnames to sync API settings to.<br>
	HaSyncHosts []string `json:"ha_sync_hosts,omitempty"`
	// Sets the username to use when authenticating for HA sync processes. This user must be the present
	//
	//	on all hosts defined in `ha_sync_hosts`.<br>
	HaSyncUsername *string `json:"ha_sync_username,omitempty"`
	// Sets the password to use when authenticating for HA sync processes. This must be the password
	//
	//	for the user defined in `ha_sync_username` and must be the same on all hosts defined in `ha_sync_hosts`.<br>
	HaSyncPassword *string `json:"ha_sync_password,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RestapiSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler RestapiSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RestapiSettings(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RestapiSettings) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Sets the log level for API logging. The log level determines the minimum severity of messages
//
//	that should be logged.<br>
type RestapiSettingsLogLevel string

const (
	RestapiSettingsLogLevelLogDebug   RestapiSettingsLogLevel = "LOG_DEBUG"
	RestapiSettingsLogLevelLogInfo    RestapiSettingsLogLevel = "LOG_INFO"
	RestapiSettingsLogLevelLogNotice  RestapiSettingsLogLevel = "LOG_NOTICE"
	RestapiSettingsLogLevelLogWarning RestapiSettingsLogLevel = "LOG_WARNING"
	RestapiSettingsLogLevelLogErr     RestapiSettingsLogLevel = "LOG_ERR"
	RestapiSettingsLogLevelLogCrit    RestapiSettingsLogLevel = "LOG_CRIT"
	RestapiSettingsLogLevelLogAlert   RestapiSettingsLogLevel = "LOG_ALERT"
	RestapiSettingsLogLevelLogEmerg   RestapiSettingsLogLevel = "LOG_EMERG"
)

func NewRestapiSettingsLogLevelFromString(s string) (RestapiSettingsLogLevel, error) {
	switch s {
	case "LOG_DEBUG":
		return RestapiSettingsLogLevelLogDebug, nil
	case "LOG_INFO":
		return RestapiSettingsLogLevelLogInfo, nil
	case "LOG_NOTICE":
		return RestapiSettingsLogLevelLogNotice, nil
	case "LOG_WARNING":
		return RestapiSettingsLogLevelLogWarning, nil
	case "LOG_ERR":
		return RestapiSettingsLogLevelLogErr, nil
	case "LOG_CRIT":
		return RestapiSettingsLogLevelLogCrit, nil
	case "LOG_ALERT":
		return RestapiSettingsLogLevelLogAlert, nil
	case "LOG_EMERG":
		return RestapiSettingsLogLevelLogEmerg, nil
	}
	var t RestapiSettingsLogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RestapiSettingsLogLevel) Ptr() *RestapiSettingsLogLevel {
	return &r
}

// Specifies how the API should represent interface names. Use `descr` to represent
//
//	interface objects by their description name, use `id` to represent interface objects by their
//	internal pfSense ID (e.g. wan, lan, opt1), or use `if` to represent interface objects by their
//	real interface name (e.g. em0, igb1, bxe3).<br>
type RestapiSettingsRepresentInterfacesAs string

const (
	RestapiSettingsRepresentInterfacesAsDescr RestapiSettingsRepresentInterfacesAs = "descr"
	RestapiSettingsRepresentInterfacesAsID    RestapiSettingsRepresentInterfacesAs = "id"
	RestapiSettingsRepresentInterfacesAsIf    RestapiSettingsRepresentInterfacesAs = "if"
)

func NewRestapiSettingsRepresentInterfacesAsFromString(s string) (RestapiSettingsRepresentInterfacesAs, error) {
	switch s {
	case "descr":
		return RestapiSettingsRepresentInterfacesAsDescr, nil
	case "id":
		return RestapiSettingsRepresentInterfacesAsID, nil
	case "if":
		return RestapiSettingsRepresentInterfacesAsIf, nil
	}
	var t RestapiSettingsRepresentInterfacesAs
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RestapiSettingsRepresentInterfacesAs) Ptr() *RestapiSettingsRepresentInterfacesAs {
	return &r
}

type RestapiSettingsSync struct {
	// The serialized REST API settings data to be synced.<br>
	SyncData *string `json:"sync_data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RestapiSettingsSync) UnmarshalJSON(data []byte) error {
	type unmarshaler RestapiSettingsSync
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RestapiSettingsSync(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RestapiSettingsSync) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RestapiVersion struct {
	// The current API version installed on this system.<br>
	CurrentVersion *string `json:"current_version,omitempty"`
	// The latest API version available to this system.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// The latest API version's release date.<br>
	LatestVersionReleaseDate *string `json:"latest_version_release_date,omitempty"`
	// Indicates if an API update is available for this system.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
	// Set the API version to update or rollback to.<br>
	InstallVersion *string `json:"install_version,omitempty"`
	// All available versions of the REST API package for this system.<br>
	AvailableVersions []string `json:"available_versions,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RestapiVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler RestapiVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RestapiVersion(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RestapiVersion) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SystemConsole struct {
	// Enables or disables password protecting the console.<br>
	PasswdProtectConsole *bool `json:"passwd_protect_console,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SystemConsole) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemConsole
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemConsole(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemConsole) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemDNS struct {
	// Allow DNS servers to be overwritten by DHCP on WAN interfaces.<br>
	Dnsallowoverride *bool `json:"dnsallowoverride,omitempty"`
	// Use local DNS server (DNS Resover or DNS Forwarder) as the primary DNS, or use only remote DNS servers specified in `dnsserver`. Set to `null` to use local DNS server as the primary and remote DNS servers as backup.<br>
	Dnslocalhost *SystemDNSDnslocalhost `json:"dnslocalhost,omitempty"`
	// The remote DNS server IPv4 or IPv6 addresses.<br>
	Dnsserver []string `json:"dnsserver,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SystemDNS) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemDNS
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemDNS(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemDNS) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Use local DNS server (DNS Resover or DNS Forwarder) as the primary DNS, or use only remote DNS servers specified in `dnsserver`. Set to `null` to use local DNS server as the primary and remote DNS servers as backup.<br>
type SystemDNSDnslocalhost string

const (
	SystemDNSDnslocalhostLocal  SystemDNSDnslocalhost = "local"
	SystemDNSDnslocalhostRemote SystemDNSDnslocalhost = "remote"
)

func NewSystemDNSDnslocalhostFromString(s string) (SystemDNSDnslocalhost, error) {
	switch s {
	case "local":
		return SystemDNSDnslocalhostLocal, nil
	case "remote":
		return SystemDNSDnslocalhostRemote, nil
	}
	var t SystemDNSDnslocalhost
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SystemDNSDnslocalhost) Ptr() *SystemDNSDnslocalhost {
	return &s
}

type SystemHostname struct {
	// The hostname portion of the FQDN to assign to this system.<br>
	Hostname *string `json:"hostname,omitempty"`
	// The domain portion of the FQDN to assign to this system.<br>
	Domain *string `json:"domain,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SystemHostname) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemHostname
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemHostname(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemHostname) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemTimezone struct {
	// Set geographic region name (Continent/Location) to determine the timezone for the firewall.<br>
	Timezone *string `json:"timezone,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SystemTimezone) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemTimezone
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemTimezone(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemTimezone) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemTunable struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SystemTunable) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemTunable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemTunable(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemTunable) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemVersion struct {
	// The official pfSense version release name. (e.g. X.X.X-RELEASE)<br>
	Version *string `json:"version,omitempty"`
	// The base pfSense version. For pfSense CE, this will be the major and minor version but not the patch. For pfSense Plus, this will be the version year and month but not the patch.<br>
	Base *string `json:"base,omitempty"`
	// The pfSense build's patch version.<br>
	Patch *string `json:"patch,omitempty"`
	// The datetime string of when the pfSense version was initially built.<br>
	Buildtime *string `json:"buildtime,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SystemVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler SystemVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SystemVersion(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemVersion) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type WebGuiSettings struct {
	// The protocol to use for the web GUI.<br>
	Protocol *WebGuiSettingsProtocol `json:"protocol,omitempty"`
	// The port on which the web GUI listens. Valid options are: a TCP/UDP port number<br>
	Port *string `json:"port,omitempty"`
	// The SSL/TLS certificate to use for the web GUI.<br>
	Sslcertref *string `json:"sslcertref,omitempty"`

	_rawJSON json.RawMessage
}

func (w *WebGuiSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler WebGuiSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebGuiSettings(value)
	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebGuiSettings) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// The protocol to use for the web GUI.<br>
type WebGuiSettingsProtocol string

const (
	WebGuiSettingsProtocolHTTP  WebGuiSettingsProtocol = "http"
	WebGuiSettingsProtocolHTTPS WebGuiSettingsProtocol = "https"
)

func NewWebGuiSettingsProtocolFromString(s string) (WebGuiSettingsProtocol, error) {
	switch s {
	case "http":
		return WebGuiSettingsProtocolHTTP, nil
	case "https":
		return WebGuiSettingsProtocolHTTPS, nil
	}
	var t WebGuiSettingsProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebGuiSettingsProtocol) Ptr() *WebGuiSettingsProtocol {
	return &w
}

type DeleteSystemCertificateAuthoritiesEndpointResponse struct {
	Data []*DeleteSystemCertificateAuthoritiesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificateAuthoritiesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificateAuthoritiesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificateAuthoritiesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificateAuthoritiesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCertificateAuthoritiesEndpointResponseDataItem struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificateAuthoritiesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificateAuthoritiesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificateAuthoritiesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificateAuthoritiesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCertificateAuthorityEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemCertificateAuthorityEndpointRequestIDFromInteger(value int) *DeleteSystemCertificateAuthorityEndpointRequestID {
	return &DeleteSystemCertificateAuthorityEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteSystemCertificateAuthorityEndpointRequestIDFromString(value string) *DeleteSystemCertificateAuthorityEndpointRequestID {
	return &DeleteSystemCertificateAuthorityEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteSystemCertificateAuthorityEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemCertificateAuthorityEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemCertificateAuthorityEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemCertificateAuthorityEndpointRequestID) Accept(visitor DeleteSystemCertificateAuthorityEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemCertificateAuthorityEndpointResponse struct {
	Data *DeleteSystemCertificateAuthorityEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificateAuthorityEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificateAuthorityEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificateAuthorityEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificateAuthorityEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCertificateAuthorityEndpointResponseData struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificateAuthorityEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificateAuthorityEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificateAuthorityEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificateAuthorityEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemCertificateEndpointRequestIDFromInteger(value int) *DeleteSystemCertificateEndpointRequestID {
	return &DeleteSystemCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteSystemCertificateEndpointRequestIDFromString(value string) *DeleteSystemCertificateEndpointRequestID {
	return &DeleteSystemCertificateEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteSystemCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemCertificateEndpointRequestID) Accept(visitor DeleteSystemCertificateEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemCertificateEndpointResponse struct {
	Data *DeleteSystemCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificateEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificateEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCertificateEndpointResponseData struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificateEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificateEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCertificatesEndpointResponse struct {
	Data []*DeleteSystemCertificatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificatesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificatesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCertificatesEndpointResponseDataItem struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCertificatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCertificatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCertificatesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCertificatesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCrLsEndpointResponse struct {
	Data []*DeleteSystemCrLsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCrLsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCrLsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCrLsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCrLsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCrLsEndpointResponseDataItem struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
	ID   *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCrLsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCrLsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCrLsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCrLsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCrlEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemCrlEndpointRequestIDFromInteger(value int) *DeleteSystemCrlEndpointRequestID {
	return &DeleteSystemCrlEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteSystemCrlEndpointRequestIDFromString(value string) *DeleteSystemCrlEndpointRequestID {
	return &DeleteSystemCrlEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteSystemCrlEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemCrlEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemCrlEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemCrlEndpointRequestID) Accept(visitor DeleteSystemCrlEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemCrlEndpointResponse struct {
	Data *DeleteSystemCrlEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCrlEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCrlEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCrlEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCrlEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCrlEndpointResponseData struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
	ID   *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCrlEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCrlEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCrlEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCrlEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCrlRevokedCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemCrlRevokedCertificateEndpointRequestIDFromInteger(value int) *DeleteSystemCrlRevokedCertificateEndpointRequestID {
	return &DeleteSystemCrlRevokedCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteSystemCrlRevokedCertificateEndpointRequestIDFromString(value string) *DeleteSystemCrlRevokedCertificateEndpointRequestID {
	return &DeleteSystemCrlRevokedCertificateEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteSystemCrlRevokedCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemCrlRevokedCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemCrlRevokedCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemCrlRevokedCertificateEndpointRequestID) Accept(visitor DeleteSystemCrlRevokedCertificateEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemCrlRevokedCertificateEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemCrlRevokedCertificateEndpointRequestParentIDFromInteger(value int) *DeleteSystemCrlRevokedCertificateEndpointRequestParentID {
	return &DeleteSystemCrlRevokedCertificateEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteSystemCrlRevokedCertificateEndpointRequestParentIDFromString(value string) *DeleteSystemCrlRevokedCertificateEndpointRequestParentID {
	return &DeleteSystemCrlRevokedCertificateEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteSystemCrlRevokedCertificateEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemCrlRevokedCertificateEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemCrlRevokedCertificateEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemCrlRevokedCertificateEndpointRequestParentID) Accept(visitor DeleteSystemCrlRevokedCertificateEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemCrlRevokedCertificateEndpointResponse struct {
	Data *DeleteSystemCrlRevokedCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCrlRevokedCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCrlRevokedCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCrlRevokedCertificateEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCrlRevokedCertificateEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemCrlRevokedCertificateEndpointResponseData struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv      *string `json:"prv,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemCrlRevokedCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemCrlRevokedCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemCrlRevokedCertificateEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemCrlRevokedCertificateEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemPackageEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemPackageEndpointRequestIDFromInteger(value int) *DeleteSystemPackageEndpointRequestID {
	return &DeleteSystemPackageEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteSystemPackageEndpointRequestIDFromString(value string) *DeleteSystemPackageEndpointRequestID {
	return &DeleteSystemPackageEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteSystemPackageEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemPackageEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemPackageEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemPackageEndpointRequestID) Accept(visitor DeleteSystemPackageEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemPackageEndpointResponse struct {
	Data *DeleteSystemPackageEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemPackageEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemPackageEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemPackageEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemPackageEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemPackageEndpointResponseData struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The version of the package currently installed.<br>
	InstalledVersion *string `json:"installed_version,omitempty"`
	// The latest version available for this package.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// Indicates whether the installed package has an update available.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
	ID              *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemPackageEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemPackageEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemPackageEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemPackageEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemPackagesEndpointResponse struct {
	Data []*DeleteSystemPackagesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemPackagesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemPackagesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemPackagesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemPackagesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemPackagesEndpointResponseDataItem struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The version of the package currently installed.<br>
	InstalledVersion *string `json:"installed_version,omitempty"`
	// The latest version available for this package.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// Indicates whether the installed package has an update available.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
	ID              *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemPackagesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemPackagesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemPackagesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemPackagesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemRestapiAccessListEndpointResponse struct {
	Data []*DeleteSystemRestapiAccessListEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemRestapiAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemRestapiAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemRestapiAccessListEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemRestapiAccessListEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemRestapiAccessListEndpointResponseDataItem struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemRestapiAccessListEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemRestapiAccessListEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemRestapiAccessListEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemRestapiAccessListEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemRestapiAccessListEntryEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemRestapiAccessListEntryEndpointRequestIDFromInteger(value int) *DeleteSystemRestapiAccessListEntryEndpointRequestID {
	return &DeleteSystemRestapiAccessListEntryEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteSystemRestapiAccessListEntryEndpointRequestIDFromString(value string) *DeleteSystemRestapiAccessListEntryEndpointRequestID {
	return &DeleteSystemRestapiAccessListEntryEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteSystemRestapiAccessListEntryEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemRestapiAccessListEntryEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemRestapiAccessListEntryEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemRestapiAccessListEntryEndpointRequestID) Accept(visitor DeleteSystemRestapiAccessListEntryEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemRestapiAccessListEntryEndpointResponse struct {
	Data *DeleteSystemRestapiAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemRestapiAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemRestapiAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemRestapiAccessListEntryEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemRestapiAccessListEntryEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemRestapiAccessListEntryEndpointResponseData struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemRestapiAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemRestapiAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemRestapiAccessListEntryEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemRestapiAccessListEntryEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemTunableEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteSystemTunableEndpointRequestIDFromInteger(value int) *DeleteSystemTunableEndpointRequestID {
	return &DeleteSystemTunableEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteSystemTunableEndpointRequestIDFromString(value string) *DeleteSystemTunableEndpointRequestID {
	return &DeleteSystemTunableEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteSystemTunableEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteSystemTunableEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteSystemTunableEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteSystemTunableEndpointRequestID) Accept(visitor DeleteSystemTunableEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteSystemTunableEndpointResponse struct {
	Data *DeleteSystemTunableEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemTunableEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemTunableEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemTunableEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemTunableEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemTunableEndpointResponseData struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemTunableEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemTunableEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemTunableEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemTunableEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemTunablesEndpointResponse struct {
	Data []*DeleteSystemTunablesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemTunablesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemTunablesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemTunablesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemTunablesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteSystemTunablesEndpointResponseDataItem struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteSystemTunablesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSystemTunablesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSystemTunablesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSystemTunablesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetSystemCertificateAuthoritiesEndpointRequestSortFlags string

const (
	GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortRegular      GetSystemCertificateAuthoritiesEndpointRequestSortFlags = "SORT_REGULAR"
	GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortNumeric      GetSystemCertificateAuthoritiesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortString       GetSystemCertificateAuthoritiesEndpointRequestSortFlags = "SORT_STRING"
	GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortLocaleString GetSystemCertificateAuthoritiesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortNatural      GetSystemCertificateAuthoritiesEndpointRequestSortFlags = "SORT_NATURAL"
	GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortFlagCase     GetSystemCertificateAuthoritiesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetSystemCertificateAuthoritiesEndpointRequestSortFlagsFromString(s string) (GetSystemCertificateAuthoritiesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetSystemCertificateAuthoritiesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetSystemCertificateAuthoritiesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemCertificateAuthoritiesEndpointRequestSortFlags) Ptr() *GetSystemCertificateAuthoritiesEndpointRequestSortFlags {
	return &g
}

type GetSystemCertificateAuthoritiesEndpointRequestSortOrder string

const (
	GetSystemCertificateAuthoritiesEndpointRequestSortOrderSortAsc  GetSystemCertificateAuthoritiesEndpointRequestSortOrder = "SORT_ASC"
	GetSystemCertificateAuthoritiesEndpointRequestSortOrderSortDesc GetSystemCertificateAuthoritiesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetSystemCertificateAuthoritiesEndpointRequestSortOrderFromString(s string) (GetSystemCertificateAuthoritiesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetSystemCertificateAuthoritiesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetSystemCertificateAuthoritiesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetSystemCertificateAuthoritiesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemCertificateAuthoritiesEndpointRequestSortOrder) Ptr() *GetSystemCertificateAuthoritiesEndpointRequestSortOrder {
	return &g
}

type GetSystemCertificateAuthoritiesEndpointResponse struct {
	Data []*GetSystemCertificateAuthoritiesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificateAuthoritiesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificateAuthoritiesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificateAuthoritiesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificateAuthoritiesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCertificateAuthoritiesEndpointResponseDataItem struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificateAuthoritiesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificateAuthoritiesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificateAuthoritiesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificateAuthoritiesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCertificateAuthorityEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemCertificateAuthorityEndpointRequestIDFromInteger(value int) *GetSystemCertificateAuthorityEndpointRequestID {
	return &GetSystemCertificateAuthorityEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetSystemCertificateAuthorityEndpointRequestIDFromString(value string) *GetSystemCertificateAuthorityEndpointRequestID {
	return &GetSystemCertificateAuthorityEndpointRequestID{typeName: "string", String: value}
}

func (g *GetSystemCertificateAuthorityEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemCertificateAuthorityEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemCertificateAuthorityEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemCertificateAuthorityEndpointRequestID) Accept(visitor GetSystemCertificateAuthorityEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemCertificateAuthorityEndpointResponse struct {
	Data *GetSystemCertificateAuthorityEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificateAuthorityEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificateAuthorityEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificateAuthorityEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificateAuthorityEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCertificateAuthorityEndpointResponseData struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificateAuthorityEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificateAuthorityEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificateAuthorityEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificateAuthorityEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemCertificateEndpointRequestIDFromInteger(value int) *GetSystemCertificateEndpointRequestID {
	return &GetSystemCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetSystemCertificateEndpointRequestIDFromString(value string) *GetSystemCertificateEndpointRequestID {
	return &GetSystemCertificateEndpointRequestID{typeName: "string", String: value}
}

func (g *GetSystemCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemCertificateEndpointRequestID) Accept(visitor GetSystemCertificateEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemCertificateEndpointResponse struct {
	Data *GetSystemCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificateEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificateEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCertificateEndpointResponseData struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificateEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificateEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCertificatesEndpointRequestSortFlags string

const (
	GetSystemCertificatesEndpointRequestSortFlagsSortRegular      GetSystemCertificatesEndpointRequestSortFlags = "SORT_REGULAR"
	GetSystemCertificatesEndpointRequestSortFlagsSortNumeric      GetSystemCertificatesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetSystemCertificatesEndpointRequestSortFlagsSortString       GetSystemCertificatesEndpointRequestSortFlags = "SORT_STRING"
	GetSystemCertificatesEndpointRequestSortFlagsSortLocaleString GetSystemCertificatesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetSystemCertificatesEndpointRequestSortFlagsSortNatural      GetSystemCertificatesEndpointRequestSortFlags = "SORT_NATURAL"
	GetSystemCertificatesEndpointRequestSortFlagsSortFlagCase     GetSystemCertificatesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetSystemCertificatesEndpointRequestSortFlagsFromString(s string) (GetSystemCertificatesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetSystemCertificatesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetSystemCertificatesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetSystemCertificatesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetSystemCertificatesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetSystemCertificatesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetSystemCertificatesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetSystemCertificatesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemCertificatesEndpointRequestSortFlags) Ptr() *GetSystemCertificatesEndpointRequestSortFlags {
	return &g
}

type GetSystemCertificatesEndpointRequestSortOrder string

const (
	GetSystemCertificatesEndpointRequestSortOrderSortAsc  GetSystemCertificatesEndpointRequestSortOrder = "SORT_ASC"
	GetSystemCertificatesEndpointRequestSortOrderSortDesc GetSystemCertificatesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetSystemCertificatesEndpointRequestSortOrderFromString(s string) (GetSystemCertificatesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetSystemCertificatesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetSystemCertificatesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetSystemCertificatesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemCertificatesEndpointRequestSortOrder) Ptr() *GetSystemCertificatesEndpointRequestSortOrder {
	return &g
}

type GetSystemCertificatesEndpointResponse struct {
	Data []*GetSystemCertificatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificatesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificatesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCertificatesEndpointResponseDataItem struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCertificatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCertificatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCertificatesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCertificatesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemConsoleEndpointResponse struct {
	Data *SystemConsole `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemConsoleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemConsoleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemConsoleEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemConsoleEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCrLsEndpointRequestSortFlags string

const (
	GetSystemCrLsEndpointRequestSortFlagsSortRegular      GetSystemCrLsEndpointRequestSortFlags = "SORT_REGULAR"
	GetSystemCrLsEndpointRequestSortFlagsSortNumeric      GetSystemCrLsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetSystemCrLsEndpointRequestSortFlagsSortString       GetSystemCrLsEndpointRequestSortFlags = "SORT_STRING"
	GetSystemCrLsEndpointRequestSortFlagsSortLocaleString GetSystemCrLsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetSystemCrLsEndpointRequestSortFlagsSortNatural      GetSystemCrLsEndpointRequestSortFlags = "SORT_NATURAL"
	GetSystemCrLsEndpointRequestSortFlagsSortFlagCase     GetSystemCrLsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetSystemCrLsEndpointRequestSortFlagsFromString(s string) (GetSystemCrLsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetSystemCrLsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetSystemCrLsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetSystemCrLsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetSystemCrLsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetSystemCrLsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetSystemCrLsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetSystemCrLsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemCrLsEndpointRequestSortFlags) Ptr() *GetSystemCrLsEndpointRequestSortFlags {
	return &g
}

type GetSystemCrLsEndpointRequestSortOrder string

const (
	GetSystemCrLsEndpointRequestSortOrderSortAsc  GetSystemCrLsEndpointRequestSortOrder = "SORT_ASC"
	GetSystemCrLsEndpointRequestSortOrderSortDesc GetSystemCrLsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetSystemCrLsEndpointRequestSortOrderFromString(s string) (GetSystemCrLsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetSystemCrLsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetSystemCrLsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetSystemCrLsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemCrLsEndpointRequestSortOrder) Ptr() *GetSystemCrLsEndpointRequestSortOrder {
	return &g
}

type GetSystemCrLsEndpointResponse struct {
	Data []*GetSystemCrLsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCrLsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCrLsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCrLsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCrLsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCrLsEndpointResponseDataItem struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
	ID   *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCrLsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCrLsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCrLsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCrLsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCrlEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemCrlEndpointRequestIDFromInteger(value int) *GetSystemCrlEndpointRequestID {
	return &GetSystemCrlEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetSystemCrlEndpointRequestIDFromString(value string) *GetSystemCrlEndpointRequestID {
	return &GetSystemCrlEndpointRequestID{typeName: "string", String: value}
}

func (g *GetSystemCrlEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemCrlEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemCrlEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemCrlEndpointRequestID) Accept(visitor GetSystemCrlEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemCrlEndpointResponse struct {
	Data *GetSystemCrlEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCrlEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCrlEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCrlEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCrlEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCrlEndpointResponseData struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
	ID   *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCrlEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCrlEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCrlEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCrlEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCrlRevokedCertificateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemCrlRevokedCertificateEndpointRequestIDFromInteger(value int) *GetSystemCrlRevokedCertificateEndpointRequestID {
	return &GetSystemCrlRevokedCertificateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetSystemCrlRevokedCertificateEndpointRequestIDFromString(value string) *GetSystemCrlRevokedCertificateEndpointRequestID {
	return &GetSystemCrlRevokedCertificateEndpointRequestID{typeName: "string", String: value}
}

func (g *GetSystemCrlRevokedCertificateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemCrlRevokedCertificateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemCrlRevokedCertificateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemCrlRevokedCertificateEndpointRequestID) Accept(visitor GetSystemCrlRevokedCertificateEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemCrlRevokedCertificateEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemCrlRevokedCertificateEndpointRequestParentIDFromInteger(value int) *GetSystemCrlRevokedCertificateEndpointRequestParentID {
	return &GetSystemCrlRevokedCertificateEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetSystemCrlRevokedCertificateEndpointRequestParentIDFromString(value string) *GetSystemCrlRevokedCertificateEndpointRequestParentID {
	return &GetSystemCrlRevokedCertificateEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetSystemCrlRevokedCertificateEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemCrlRevokedCertificateEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemCrlRevokedCertificateEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemCrlRevokedCertificateEndpointRequestParentID) Accept(visitor GetSystemCrlRevokedCertificateEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemCrlRevokedCertificateEndpointResponse struct {
	Data *GetSystemCrlRevokedCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCrlRevokedCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCrlRevokedCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCrlRevokedCertificateEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCrlRevokedCertificateEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemCrlRevokedCertificateEndpointResponseData struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv      *string `json:"prv,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemCrlRevokedCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemCrlRevokedCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemCrlRevokedCertificateEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemCrlRevokedCertificateEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemDNSEndpointResponse struct {
	Data *SystemDNS `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemDNSEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemDNSEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemDNSEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemDNSEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemHostnameEndpointResponse struct {
	Data *SystemHostname `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemHostnameEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemHostnameEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemHostnameEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemHostnameEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemNotificationsEmailSettingsEndpointResponse struct {
	Data *EmailNotificationSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemNotificationsEmailSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemNotificationsEmailSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemNotificationsEmailSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemNotificationsEmailSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemPackageAvailableEndpointRequestSortFlags string

const (
	GetSystemPackageAvailableEndpointRequestSortFlagsSortRegular      GetSystemPackageAvailableEndpointRequestSortFlags = "SORT_REGULAR"
	GetSystemPackageAvailableEndpointRequestSortFlagsSortNumeric      GetSystemPackageAvailableEndpointRequestSortFlags = "SORT_NUMERIC"
	GetSystemPackageAvailableEndpointRequestSortFlagsSortString       GetSystemPackageAvailableEndpointRequestSortFlags = "SORT_STRING"
	GetSystemPackageAvailableEndpointRequestSortFlagsSortLocaleString GetSystemPackageAvailableEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetSystemPackageAvailableEndpointRequestSortFlagsSortNatural      GetSystemPackageAvailableEndpointRequestSortFlags = "SORT_NATURAL"
	GetSystemPackageAvailableEndpointRequestSortFlagsSortFlagCase     GetSystemPackageAvailableEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetSystemPackageAvailableEndpointRequestSortFlagsFromString(s string) (GetSystemPackageAvailableEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetSystemPackageAvailableEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetSystemPackageAvailableEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetSystemPackageAvailableEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetSystemPackageAvailableEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetSystemPackageAvailableEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetSystemPackageAvailableEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetSystemPackageAvailableEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemPackageAvailableEndpointRequestSortFlags) Ptr() *GetSystemPackageAvailableEndpointRequestSortFlags {
	return &g
}

type GetSystemPackageAvailableEndpointRequestSortOrder string

const (
	GetSystemPackageAvailableEndpointRequestSortOrderSortAsc  GetSystemPackageAvailableEndpointRequestSortOrder = "SORT_ASC"
	GetSystemPackageAvailableEndpointRequestSortOrderSortDesc GetSystemPackageAvailableEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetSystemPackageAvailableEndpointRequestSortOrderFromString(s string) (GetSystemPackageAvailableEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetSystemPackageAvailableEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetSystemPackageAvailableEndpointRequestSortOrderSortDesc, nil
	}
	var t GetSystemPackageAvailableEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemPackageAvailableEndpointRequestSortOrder) Ptr() *GetSystemPackageAvailableEndpointRequestSortOrder {
	return &g
}

type GetSystemPackageAvailableEndpointResponse struct {
	Data []*GetSystemPackageAvailableEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemPackageAvailableEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemPackageAvailableEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemPackageAvailableEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemPackageAvailableEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemPackageAvailableEndpointResponseDataItem struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The latest version available for this package.<br>
	Version *string `json:"version,omitempty"`
	// Indicates whether the package is currently installed or not.<br>
	Installed *bool `json:"installed,omitempty"`
	// Dependencies for this package that are also installed when this package is installed.<br>
	Deps []string `json:"deps,omitempty"`
	ID   *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemPackageAvailableEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemPackageAvailableEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemPackageAvailableEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemPackageAvailableEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemPackageEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemPackageEndpointRequestIDFromInteger(value int) *GetSystemPackageEndpointRequestID {
	return &GetSystemPackageEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetSystemPackageEndpointRequestIDFromString(value string) *GetSystemPackageEndpointRequestID {
	return &GetSystemPackageEndpointRequestID{typeName: "string", String: value}
}

func (g *GetSystemPackageEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemPackageEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemPackageEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemPackageEndpointRequestID) Accept(visitor GetSystemPackageEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemPackageEndpointResponse struct {
	Data *GetSystemPackageEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemPackageEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemPackageEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemPackageEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemPackageEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemPackageEndpointResponseData struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The version of the package currently installed.<br>
	InstalledVersion *string `json:"installed_version,omitempty"`
	// The latest version available for this package.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// Indicates whether the installed package has an update available.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
	ID              *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemPackageEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemPackageEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemPackageEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemPackageEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemPackagesEndpointRequestSortFlags string

const (
	GetSystemPackagesEndpointRequestSortFlagsSortRegular      GetSystemPackagesEndpointRequestSortFlags = "SORT_REGULAR"
	GetSystemPackagesEndpointRequestSortFlagsSortNumeric      GetSystemPackagesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetSystemPackagesEndpointRequestSortFlagsSortString       GetSystemPackagesEndpointRequestSortFlags = "SORT_STRING"
	GetSystemPackagesEndpointRequestSortFlagsSortLocaleString GetSystemPackagesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetSystemPackagesEndpointRequestSortFlagsSortNatural      GetSystemPackagesEndpointRequestSortFlags = "SORT_NATURAL"
	GetSystemPackagesEndpointRequestSortFlagsSortFlagCase     GetSystemPackagesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetSystemPackagesEndpointRequestSortFlagsFromString(s string) (GetSystemPackagesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetSystemPackagesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetSystemPackagesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetSystemPackagesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetSystemPackagesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetSystemPackagesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetSystemPackagesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetSystemPackagesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemPackagesEndpointRequestSortFlags) Ptr() *GetSystemPackagesEndpointRequestSortFlags {
	return &g
}

type GetSystemPackagesEndpointRequestSortOrder string

const (
	GetSystemPackagesEndpointRequestSortOrderSortAsc  GetSystemPackagesEndpointRequestSortOrder = "SORT_ASC"
	GetSystemPackagesEndpointRequestSortOrderSortDesc GetSystemPackagesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetSystemPackagesEndpointRequestSortOrderFromString(s string) (GetSystemPackagesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetSystemPackagesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetSystemPackagesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetSystemPackagesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemPackagesEndpointRequestSortOrder) Ptr() *GetSystemPackagesEndpointRequestSortOrder {
	return &g
}

type GetSystemPackagesEndpointResponse struct {
	Data []*GetSystemPackagesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemPackagesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemPackagesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemPackagesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemPackagesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemPackagesEndpointResponseDataItem struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The version of the package currently installed.<br>
	InstalledVersion *string `json:"installed_version,omitempty"`
	// The latest version available for this package.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// Indicates whether the installed package has an update available.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
	ID              *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemPackagesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemPackagesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemPackagesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemPackagesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemRestapiAccessListEndpointRequestSortFlags string

const (
	GetSystemRestapiAccessListEndpointRequestSortFlagsSortRegular      GetSystemRestapiAccessListEndpointRequestSortFlags = "SORT_REGULAR"
	GetSystemRestapiAccessListEndpointRequestSortFlagsSortNumeric      GetSystemRestapiAccessListEndpointRequestSortFlags = "SORT_NUMERIC"
	GetSystemRestapiAccessListEndpointRequestSortFlagsSortString       GetSystemRestapiAccessListEndpointRequestSortFlags = "SORT_STRING"
	GetSystemRestapiAccessListEndpointRequestSortFlagsSortLocaleString GetSystemRestapiAccessListEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetSystemRestapiAccessListEndpointRequestSortFlagsSortNatural      GetSystemRestapiAccessListEndpointRequestSortFlags = "SORT_NATURAL"
	GetSystemRestapiAccessListEndpointRequestSortFlagsSortFlagCase     GetSystemRestapiAccessListEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetSystemRestapiAccessListEndpointRequestSortFlagsFromString(s string) (GetSystemRestapiAccessListEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetSystemRestapiAccessListEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetSystemRestapiAccessListEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetSystemRestapiAccessListEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetSystemRestapiAccessListEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetSystemRestapiAccessListEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetSystemRestapiAccessListEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetSystemRestapiAccessListEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemRestapiAccessListEndpointRequestSortFlags) Ptr() *GetSystemRestapiAccessListEndpointRequestSortFlags {
	return &g
}

type GetSystemRestapiAccessListEndpointRequestSortOrder string

const (
	GetSystemRestapiAccessListEndpointRequestSortOrderSortAsc  GetSystemRestapiAccessListEndpointRequestSortOrder = "SORT_ASC"
	GetSystemRestapiAccessListEndpointRequestSortOrderSortDesc GetSystemRestapiAccessListEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetSystemRestapiAccessListEndpointRequestSortOrderFromString(s string) (GetSystemRestapiAccessListEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetSystemRestapiAccessListEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetSystemRestapiAccessListEndpointRequestSortOrderSortDesc, nil
	}
	var t GetSystemRestapiAccessListEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemRestapiAccessListEndpointRequestSortOrder) Ptr() *GetSystemRestapiAccessListEndpointRequestSortOrder {
	return &g
}

type GetSystemRestapiAccessListEndpointResponse struct {
	Data []*GetSystemRestapiAccessListEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemRestapiAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemRestapiAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemRestapiAccessListEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemRestapiAccessListEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemRestapiAccessListEndpointResponseDataItem struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemRestapiAccessListEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemRestapiAccessListEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemRestapiAccessListEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemRestapiAccessListEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemRestapiAccessListEntryEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemRestapiAccessListEntryEndpointRequestIDFromInteger(value int) *GetSystemRestapiAccessListEntryEndpointRequestID {
	return &GetSystemRestapiAccessListEntryEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetSystemRestapiAccessListEntryEndpointRequestIDFromString(value string) *GetSystemRestapiAccessListEntryEndpointRequestID {
	return &GetSystemRestapiAccessListEntryEndpointRequestID{typeName: "string", String: value}
}

func (g *GetSystemRestapiAccessListEntryEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemRestapiAccessListEntryEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemRestapiAccessListEntryEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemRestapiAccessListEntryEndpointRequestID) Accept(visitor GetSystemRestapiAccessListEntryEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemRestapiAccessListEntryEndpointResponse struct {
	Data *GetSystemRestapiAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemRestapiAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemRestapiAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemRestapiAccessListEntryEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemRestapiAccessListEntryEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemRestapiAccessListEntryEndpointResponseData struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemRestapiAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemRestapiAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemRestapiAccessListEntryEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemRestapiAccessListEntryEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemRestapiSettingsEndpointResponse struct {
	Data *RestapiSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemRestapiSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemRestapiSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemRestapiSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemRestapiSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemRestapiVersionEndpointResponse struct {
	Data *RestapiVersion `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemRestapiVersionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemRestapiVersionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemRestapiVersionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemRestapiVersionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemTimezoneEndpointResponse struct {
	Data *SystemTimezone `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemTimezoneEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemTimezoneEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemTimezoneEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemTimezoneEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemTunableEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetSystemTunableEndpointRequestIDFromInteger(value int) *GetSystemTunableEndpointRequestID {
	return &GetSystemTunableEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetSystemTunableEndpointRequestIDFromString(value string) *GetSystemTunableEndpointRequestID {
	return &GetSystemTunableEndpointRequestID{typeName: "string", String: value}
}

func (g *GetSystemTunableEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetSystemTunableEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetSystemTunableEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetSystemTunableEndpointRequestID) Accept(visitor GetSystemTunableEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetSystemTunableEndpointResponse struct {
	Data *GetSystemTunableEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemTunableEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemTunableEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemTunableEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemTunableEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemTunableEndpointResponseData struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemTunableEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemTunableEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemTunableEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemTunableEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemTunablesEndpointRequestSortFlags string

const (
	GetSystemTunablesEndpointRequestSortFlagsSortRegular      GetSystemTunablesEndpointRequestSortFlags = "SORT_REGULAR"
	GetSystemTunablesEndpointRequestSortFlagsSortNumeric      GetSystemTunablesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetSystemTunablesEndpointRequestSortFlagsSortString       GetSystemTunablesEndpointRequestSortFlags = "SORT_STRING"
	GetSystemTunablesEndpointRequestSortFlagsSortLocaleString GetSystemTunablesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetSystemTunablesEndpointRequestSortFlagsSortNatural      GetSystemTunablesEndpointRequestSortFlags = "SORT_NATURAL"
	GetSystemTunablesEndpointRequestSortFlagsSortFlagCase     GetSystemTunablesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetSystemTunablesEndpointRequestSortFlagsFromString(s string) (GetSystemTunablesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetSystemTunablesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetSystemTunablesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetSystemTunablesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetSystemTunablesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetSystemTunablesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetSystemTunablesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetSystemTunablesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemTunablesEndpointRequestSortFlags) Ptr() *GetSystemTunablesEndpointRequestSortFlags {
	return &g
}

type GetSystemTunablesEndpointRequestSortOrder string

const (
	GetSystemTunablesEndpointRequestSortOrderSortAsc  GetSystemTunablesEndpointRequestSortOrder = "SORT_ASC"
	GetSystemTunablesEndpointRequestSortOrderSortDesc GetSystemTunablesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetSystemTunablesEndpointRequestSortOrderFromString(s string) (GetSystemTunablesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetSystemTunablesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetSystemTunablesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetSystemTunablesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetSystemTunablesEndpointRequestSortOrder) Ptr() *GetSystemTunablesEndpointRequestSortOrder {
	return &g
}

type GetSystemTunablesEndpointResponse struct {
	Data []*GetSystemTunablesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemTunablesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemTunablesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemTunablesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemTunablesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemTunablesEndpointResponseDataItem struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemTunablesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemTunablesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemTunablesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemTunablesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemVersionEndpointResponse struct {
	Data *SystemVersion `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemVersionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemVersionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemVersionEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemVersionEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSystemWebGuiSettingsEndpointResponse struct {
	Data *WebGuiSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetSystemWebGuiSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSystemWebGuiSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSystemWebGuiSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSystemWebGuiSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PatchSystemCertificateAuthorityEndpointResponse struct {
	Data *PatchSystemCertificateAuthorityEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCertificateAuthorityEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCertificateAuthorityEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCertificateAuthorityEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCertificateAuthorityEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemCertificateAuthorityEndpointResponseData struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCertificateAuthorityEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCertificateAuthorityEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCertificateAuthorityEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCertificateAuthorityEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemCertificateEndpointResponse struct {
	Data *PatchSystemCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemCertificateEndpointResponseData struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemConsoleEndpointResponse struct {
	Data *SystemConsole `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemConsoleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemConsoleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemConsoleEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemConsoleEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemCrlEndpointResponse struct {
	Data *PatchSystemCrlEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCrlEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCrlEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCrlEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCrlEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemCrlEndpointResponseData struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
	ID   *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCrlEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCrlEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCrlEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCrlEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemCrlRevokedCertificateEndpointResponse struct {
	Data *PatchSystemCrlRevokedCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCrlRevokedCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCrlRevokedCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCrlRevokedCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCrlRevokedCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemCrlRevokedCertificateEndpointResponseData struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv      *string `json:"prv,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemCrlRevokedCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemCrlRevokedCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemCrlRevokedCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemCrlRevokedCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemDNSEndpointResponse struct {
	Data *SystemDNS `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemDNSEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemDNSEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemDNSEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemDNSEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemHostnameEndpointResponse struct {
	Data *SystemHostname `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemHostnameEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemHostnameEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemHostnameEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemHostnameEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemNotificationsEmailSettingsEndpointResponse struct {
	Data *EmailNotificationSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemNotificationsEmailSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemNotificationsEmailSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemNotificationsEmailSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemNotificationsEmailSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemRestapiAccessListEntryEndpointResponse struct {
	Data *PatchSystemRestapiAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemRestapiAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemRestapiAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemRestapiAccessListEntryEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemRestapiAccessListEntryEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemRestapiAccessListEntryEndpointResponseData struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemRestapiAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemRestapiAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemRestapiAccessListEntryEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemRestapiAccessListEntryEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemRestapiSettingsEndpointResponse struct {
	Data *RestapiSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemRestapiSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemRestapiSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemRestapiSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemRestapiSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemRestapiVersionEndpointResponse struct {
	Data *RestapiVersion `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemRestapiVersionEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemRestapiVersionEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemRestapiVersionEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemRestapiVersionEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemTimezoneEndpointResponse struct {
	Data *SystemTimezone `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemTimezoneEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemTimezoneEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemTimezoneEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemTimezoneEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemTunableEndpointResponse struct {
	Data *PatchSystemTunableEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemTunableEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemTunableEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemTunableEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemTunableEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemTunableEndpointResponseData struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemTunableEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemTunableEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemTunableEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemTunableEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchSystemWebGuiSettingsEndpointResponse struct {
	Data *WebGuiSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchSystemWebGuiSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchSystemWebGuiSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchSystemWebGuiSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchSystemWebGuiSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateAuthorityEndpointResponse struct {
	Data *PostSystemCertificateAuthorityEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateAuthorityEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateAuthorityEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateAuthorityEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateAuthorityEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateAuthorityEndpointResponseData struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateAuthorityEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateAuthorityEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateAuthorityEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateAuthorityEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateAuthorityGenerateEndpointResponse struct {
	Data *PostSystemCertificateAuthorityGenerateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateAuthorityGenerateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateAuthorityGenerateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateAuthorityGenerateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateAuthorityGenerateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateAuthorityGenerateEndpointResponseData struct {
	// The descriptive name for this certificate authority.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate authority for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// Adds or removes this certificate authority from the operating system's trust stored.<br>
	Trust *bool `json:"trust,omitempty"`
	// Enables or disables the randomization of serial numbers for certificates signed by this CA.<br>
	Randomserial *bool `json:"randomserial,omitempty"`
	// The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.<br>
	Serial *int `json:"serial,omitempty"`
	// Indicates if this certificate authority is an intermediate certificate authority.<br>
	IsIntermediate *bool `json:"is_intermediate,omitempty"`
	// The certificate authority to use as the parent for this intermediate certificate authority.<br><br>This field is only available when the following conditions are met:<br>- `is_intermediate` must be equal to `true`<br>
	Caref *string `json:"caref,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateAuthorityGenerateKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest algorithm to use when signing certificates.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate authority is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name for the certificate authority.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country for the certificate authority.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state for the certificate authority.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city for the certificate authority.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization for the certificate authority.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit for the certificate authority.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateAuthorityGenerateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateAuthorityGenerateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateAuthorityGenerateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateAuthorityGenerateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateAuthorityRenewEndpointResponse struct {
	Data *CertificateAuthorityRenew `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateAuthorityRenewEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateAuthorityRenewEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateAuthorityRenewEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateAuthorityRenewEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateEndpointResponse struct {
	Data *PostSystemCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateEndpointResponseData struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the existing pfSense Certificate Authority that signed this certificate.This value is assigned by this system and cannot be changed.<br>
	Caref *string `json:"caref,omitempty"`
	// The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes.<br>
	Type *CertificateType `json:"type,omitempty"`
	// The X509 certificate signing request string if this certificate is pending an external signature.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateGenerateEndpointResponse struct {
	Data *PostSystemCertificateGenerateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateGenerateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateGenerateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateGenerateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateGenerateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateGenerateEndpointResponseData struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The certificate authority to use as the parent for this certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateGenerateKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name of the certificate.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country of the certificate.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state/province of the certificate.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city of the certificate.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization of the certificate.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit of the certificate.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateGenerateType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateGenerateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateGenerateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateGenerateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateGenerateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateRenewEndpointResponse struct {
	Data *CertificateRenew `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateRenewEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateRenewEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateRenewEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateRenewEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateSigningRequestEndpointResponse struct {
	Data *PostSystemCertificateSigningRequestEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateSigningRequestEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateSigningRequestEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateSigningRequestEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateSigningRequestEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateSigningRequestEndpointResponseData struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The type of key pair to generate.<br>
	Keytype *CertificateSigningRequestKeytype `json:"keytype,omitempty"`
	// The length of the RSA key pair to generate.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'RSA'`<br>
	Keylen *int `json:"keylen,omitempty"`
	// The name of the elliptic curve to use for the ECDSA key pair.<br><br>This field is only available when the following conditions are met:<br>- `keytype` must be equal to `'ECDSA'`<br>
	Ecname *string `json:"ecname,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The common name of the certificate.<br>
	DnCommonname *string `json:"dn_commonname,omitempty"`
	// The country of the certificate.<br>
	DnCountry *string `json:"dn_country,omitempty"`
	// The state/province of the certificate.<br>
	DnState *string `json:"dn_state,omitempty"`
	// The city of the certificate.<br>
	DnCity *string `json:"dn_city,omitempty"`
	// The organization of the certificate.<br>
	DnOrganization *string `json:"dn_organization,omitempty"`
	// The organizational unit of the certificate.<br>
	DnOrganizationalunit *string `json:"dn_organizationalunit,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateSigningRequestType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
	// The X509 certificate signing request string. You will need to provide this to a certificate authority to sign the certificate.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	ID  *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateSigningRequestEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateSigningRequestEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateSigningRequestEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateSigningRequestEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateSigningRequestSignEndpointResponse struct {
	Data *PostSystemCertificateSigningRequestSignEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateSigningRequestSignEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateSigningRequestSignEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateSigningRequestSignEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateSigningRequestSignEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCertificateSigningRequestSignEndpointResponseData struct {
	// The descriptive name for this certificate.<br>
	Descr *string `json:"descr,omitempty"`
	// The unique ID assigned to this certificate for internal system use. This value is generated by this system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The certificate authority to sign the certificate with.<br>
	Caref *string `json:"caref,omitempty"`
	// The X509 certificate signing request to sign.<br>
	Csr *string `json:"csr,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv *string `json:"prv,omitempty"`
	// The digest method used when the certificate is signed.<br>
	DigestAlg *string `json:"digest_alg,omitempty"`
	// The number of days the certificate is valid for.<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The type of certificate to generate.<br>
	Type *CertificateSigningRequestSignType `json:"type,omitempty"`
	// The DNS Subject Alternative Names (SANs) for the certificate.<br>
	DnDNSSans []string `json:"dn_dns_sans,omitempty"`
	// The Email Subject Alternative Names (SANs) for the certificate.<br>
	DnEmailSans []string `json:"dn_email_sans,omitempty"`
	// The IP Subject Alternative Names (SANs) for the certificate.<br>
	DnIPSans []string `json:"dn_ip_sans,omitempty"`
	// The URI Subject Alternative Names (SANs) for the certificate.<br>
	DnURISans []string `json:"dn_uri_sans,omitempty"`
	ID        *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCertificateSigningRequestSignEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCertificateSigningRequestSignEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCertificateSigningRequestSignEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCertificateSigningRequestSignEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCrlEndpointResponse struct {
	Data *PostSystemCrlEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCrlEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCrlEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCrlEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCrlEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCrlEndpointResponseData struct {
	// The unique ID for this CRL. This is automatically generated by the system and cannot be changed.<br>
	Refid *string `json:"refid,omitempty"`
	// The unique ID of the CA that this CRL is associated with.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The method used to generate this CRL.<br>
	Method *CertificateRevocationListMethod `json:"method,omitempty"`
	// The lifetime of this CRL in days.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Lifetime *int `json:"lifetime,omitempty"`
	// The serial number of the CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Serial *int `json:"serial,omitempty"`
	// The raw x509 CRL data.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'existing'`<br>
	Text *string `json:"text,omitempty"`
	// The list of revoked certificates in this CRL.<br><br>This field is only available when the following conditions are met:<br>- `method` must be equal to `'internal'`<br>
	Cert []*CertificateRevocationListCertItem `json:"cert,omitempty"`
	ID   *int                                 `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCrlEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCrlEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCrlEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCrlEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCrlRevokedCertificateEndpointResponse struct {
	Data *PostSystemCrlRevokedCertificateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCrlRevokedCertificateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCrlRevokedCertificateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCrlRevokedCertificateEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCrlRevokedCertificateEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemCrlRevokedCertificateEndpointResponseData struct {
	// The reference ID of the certificate to be revoked<br><br>This field is only available when the following conditions are met:<br>- `serial` must be equal to `NULL`<br>
	Certref *string `json:"certref,omitempty"`
	// The serial number of the certificate to be revoked.<br>
	Serial *string `json:"serial,omitempty"`
	// The CRL reason for revocation code.<br>
	Reason *int `json:"reason,omitempty"`
	// The unix timestamp of when the certificate was revoked.<br>
	RevokeTime *int `json:"revoke_time,omitempty"`
	// The unique ID of the CA that signed the revoked certificate.<br>
	Caref *string `json:"caref,omitempty"`
	// The unique name/description for this CRL.<br>
	Descr *string `json:"descr,omitempty"`
	// The type of the certificate to be revoked.<br>
	Type *string `json:"type,omitempty"`
	// The X509 certificate string.<br>
	Crt *string `json:"crt,omitempty"`
	// The X509 private key string.<br>
	Prv      *string `json:"prv,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemCrlRevokedCertificateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemCrlRevokedCertificateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemCrlRevokedCertificateEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemCrlRevokedCertificateEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemPackageEndpointResponse struct {
	Data *PostSystemPackageEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemPackageEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemPackageEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemPackageEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemPackageEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemPackageEndpointResponseData struct {
	// The name of the pfSense package.<br>
	Name *string `json:"name,omitempty"`
	// The package's shortname.<br>
	Shortname *string `json:"shortname,omitempty"`
	// The package's description.<br>
	Descr *string `json:"descr,omitempty"`
	// The version of the package currently installed.<br>
	InstalledVersion *string `json:"installed_version,omitempty"`
	// The latest version available for this package.<br>
	LatestVersion *string `json:"latest_version,omitempty"`
	// Indicates whether the installed package has an update available.<br>
	UpdateAvailable *bool `json:"update_available,omitempty"`
	ID              *int  `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemPackageEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemPackageEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemPackageEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemPackageEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemRestapiAccessListEntryEndpointResponse struct {
	Data *PostSystemRestapiAccessListEntryEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemRestapiAccessListEntryEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemRestapiAccessListEntryEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemRestapiAccessListEntryEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemRestapiAccessListEntryEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemRestapiAccessListEntryEndpointResponseData struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemRestapiAccessListEntryEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemRestapiAccessListEntryEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemRestapiAccessListEntryEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemRestapiAccessListEntryEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemRestapiSettingsSyncEndpointResponse struct {
	Data *RestapiSettingsSync `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemRestapiSettingsSyncEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemRestapiSettingsSyncEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemRestapiSettingsSyncEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemRestapiSettingsSyncEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemTunableEndpointResponse struct {
	Data *PostSystemTunableEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemTunableEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemTunableEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemTunableEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemTunableEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostSystemTunableEndpointResponseData struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostSystemTunableEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostSystemTunableEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostSystemTunableEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostSystemTunableEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutSystemRestapiAccessListEndpointRequestItem struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutSystemRestapiAccessListEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutSystemRestapiAccessListEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutSystemRestapiAccessListEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutSystemRestapiAccessListEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutSystemRestapiAccessListEndpointResponse struct {
	Data []*PutSystemRestapiAccessListEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutSystemRestapiAccessListEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutSystemRestapiAccessListEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutSystemRestapiAccessListEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutSystemRestapiAccessListEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutSystemRestapiAccessListEndpointResponseDataItem struct {
	// The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks.<br>
	Type *RestapiAccessListEntryType `json:"type,omitempty"`
	// The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.<br>
	Weight *int `json:"weight,omitempty"`
	// The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.<br>
	Network *string `json:"network,omitempty"`
	// The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.<br>
	Users []string `json:"users,omitempty"`
	// The firewall schedule that this entry will use. This entry will only be active during the
	//
	//	times specified in the schedule. Leave empty to apply this entry at all times.<br>
	Sched *string `json:"sched,omitempty"`
	// A description of this access list entry. This field is optional.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutSystemRestapiAccessListEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutSystemRestapiAccessListEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutSystemRestapiAccessListEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutSystemRestapiAccessListEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutSystemTunablesEndpointRequestItem struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutSystemTunablesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutSystemTunablesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutSystemTunablesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutSystemTunablesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutSystemTunablesEndpointResponse struct {
	Data []*PutSystemTunablesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutSystemTunablesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutSystemTunablesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutSystemTunablesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutSystemTunablesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutSystemTunablesEndpointResponseDataItem struct {
	// The name of the tunable to set.<br>
	Tunable *string `json:"tunable,omitempty"`
	// The value to assign this tunable.<br>
	Value *string `json:"value,omitempty"`
	// A description for this tunable.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutSystemTunablesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutSystemTunablesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutSystemTunablesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutSystemTunablesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
