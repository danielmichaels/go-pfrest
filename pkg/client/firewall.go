// This file was auto-generated by Fern from our API Definition.

package pfclientapi

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/danielmichaels/go-pfrest/pkg/client/core"
)

type DeleteFirewallAliasEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallAliasesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallNatOneToOneMappingEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallNatOneToOneMappingsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallNatOutboundMappingEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallNatOutboundMappingsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallNatPortForwardEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallNatPortForwardsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallRuleEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteFirewallRulesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallScheduleEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteFirewallScheduleTimeRangeEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteFirewallScheduleTimeRangesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallSchedulesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallStateEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteFirewallStatesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallTrafficShaperEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteFirewallTrafficShaperLimiterBandwidthsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallTrafficShaperLimiterEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallTrafficShaperLimiterQueueEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallTrafficShaperLimiterQueuesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallTrafficShaperQueueEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallTrafficShaperQueuesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallTrafficShapersEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteFirewallVirtualIPEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteFirewallVirtualIPsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallAliasEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallAliasesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallAliasesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallAliasesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallNatOneToOneMappingEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallNatOneToOneMappingsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallNatOneToOneMappingsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallNatOneToOneMappingsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallNatOutboundMappingEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallNatOutboundMappingsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallNatOutboundMappingsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallNatOutboundMappingsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallNatPortForwardEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallNatPortForwardsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallNatPortForwardsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallNatPortForwardsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallRuleEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallRulesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallRulesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallRulesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallScheduleEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallScheduleTimeRangeEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallScheduleTimeRangesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallScheduleTimeRangesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallScheduleTimeRangesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallSchedulesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallSchedulesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallSchedulesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallStateEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallStatesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallStatesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallStatesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallTrafficShaperEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallTrafficShaperLimiterBandwidthEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallTrafficShaperLimiterBandwidthsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallTrafficShaperLimiterEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallTrafficShaperLimiterQueueEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallTrafficShaperLimiterQueuesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallTrafficShaperLimitersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallTrafficShaperLimitersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallTrafficShaperLimitersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallTrafficShaperQueueEndpointRequest struct {
	// The ID of the parent this object is nested under.
	ParentID *string `json:"-"`
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallTrafficShaperQueuesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallTrafficShaperQueuesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallTrafficShaperQueuesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallTrafficShapersEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallTrafficShapersEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallTrafficShapersEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetFirewallVirtualIPEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetFirewallVirtualIPsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetFirewallVirtualIPsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetFirewallVirtualIPsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type PatchFirewallAdvancedSettingsEndpointRequest struct {
	// The interval (in seconds) at which to resolve hostnames in aliases.<br>
	Aliasesresolveinterval *int `json:"aliasesresolveinterval,omitempty"`
	// Check the certificate of URLs used in aliases.<br>
	Checkaliasesurlcert *bool `json:"checkaliasesurlcert,omitempty"`
}

type PatchFirewallAliasEndpointRequest struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallNatOneToOneMappingEndpointRequest struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallNatOutboundMappingEndpointRequest struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallNatOutboundModeEndpointRequest struct {
	// The outbound NAT mode to assign this system. Set to `automatic` to have this system automatically generate NAT rules this firewall, `hybrid` to automatically generate NAT rules AND allow manual outbound NAT mappings to be assigned, `manual` to prevent the system from automatically generating NAT rules and only allow manual outbound NAT mappings, or `disabled` to disable outbound NAT on this system entirely.<br>
	Mode *OutboundNatModeMode `json:"mode,omitempty"`
}

type PatchFirewallNatPortForwardEndpointRequest struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallRuleEndpointRequest struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallScheduleEndpointRequest struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallScheduleTimeRangeEndpointRequest struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallStatesSizeEndpointRequest struct {
	// The maximum number of firewall state entries allowed by this firewall.<br>
	Maximumstates *int `json:"maximumstates,omitempty"`
	// The default number of firewall state entries allowed by this firewall.<br>
	Defaultmaximumstates *int `json:"defaultmaximumstates,omitempty"`
	// The number of firewall state entries currently registered in the states table.<br>
	Currentstates *int `json:"currentstates,omitempty"`
}

type PatchFirewallTrafficShaperEndpointRequest struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched *string `json:"bwsched,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallTrafficShaperLimiterEndpointRequest struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallTrafficShaperLimiterQueueEndpointRequest struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallTrafficShaperQueueEndpointRequest struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchFirewallVirtualIPEndpointRequest struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PostFirewallAliasEndpointRequest struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
}

type PostFirewallApplyEndpointRequest struct {
	// Displays `true` when all firewall changes are applied and there are no pending changes left.Displays `false` when there are pending firewall changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
	// Displays the specific firewall subsystems that have pending changes.<br>
	PendingSubsystems []string `json:"pending_subsystems,omitempty"`
}

type PostFirewallNatOneToOneMappingEndpointRequest struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
}

type PostFirewallNatOutboundMappingEndpointRequest struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
}

type PostFirewallNatPortForwardEndpointRequest struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
}

type PostFirewallRuleEndpointRequest struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
}

type PostFirewallScheduleEndpointRequest struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
}

type PostFirewallScheduleTimeRangeEndpointRequest struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostFirewallTrafficShaperEndpointRequest struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
}

type PostFirewallTrafficShaperLimiterBandwidthEndpointRequest struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched *string `json:"bwsched,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostFirewallTrafficShaperLimiterEndpointRequest struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
}

type PostFirewallTrafficShaperLimiterQueueEndpointRequest struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostFirewallTrafficShaperQueueEndpointRequest struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	// The ID of the parent this object is nested under.
	ParentID int `json:"parent_id"`
}

type PostFirewallVirtualIPApplyEndpointRequest struct {
	// Displays `true` when all virtual IP changes are applied and there are no pending changes left.Displays `false` when there are pending virtual IP changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
}

type PostFirewallVirtualIPEndpointRequest struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
}

type FirewallAdvancedSettings struct {
	// The interval (in seconds) at which to resolve hostnames in aliases.<br>
	Aliasesresolveinterval *int `json:"aliasesresolveinterval,omitempty"`
	// Check the certificate of URLs used in aliases.<br>
	Checkaliasesurlcert *bool `json:"checkaliasesurlcert,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallAdvancedSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallAdvancedSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallAdvancedSettings(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallAdvancedSettings) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FirewallAlias struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallAlias) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallAlias
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallAlias(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallAlias) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Sets the type of alias this object will be. This directly impacts what values can be
//
//	specified in the `address` field.<br>
type FirewallAliasType string

const (
	FirewallAliasTypeHost    FirewallAliasType = "host"
	FirewallAliasTypeNetwork FirewallAliasType = "network"
	FirewallAliasTypePort    FirewallAliasType = "port"
)

func NewFirewallAliasTypeFromString(s string) (FirewallAliasType, error) {
	switch s {
	case "host":
		return FirewallAliasTypeHost, nil
	case "network":
		return FirewallAliasTypeNetwork, nil
	case "port":
		return FirewallAliasTypePort, nil
	}
	var t FirewallAliasType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallAliasType) Ptr() *FirewallAliasType {
	return &f
}

type FirewallApply struct {
	// Displays `true` when all firewall changes are applied and there are no pending changes left.Displays `false` when there are pending firewall changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
	// Displays the specific firewall subsystems that have pending changes.<br>
	PendingSubsystems []string `json:"pending_subsystems,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallApply) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallApply(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallApply) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FirewallRule struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallRule(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallRule) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
type FirewallRuleDirection string

const (
	FirewallRuleDirectionAny FirewallRuleDirection = "any"
	FirewallRuleDirectionIn  FirewallRuleDirection = "in"
	FirewallRuleDirectionOut FirewallRuleDirection = "out"
)

func NewFirewallRuleDirectionFromString(s string) (FirewallRuleDirection, error) {
	switch s {
	case "any":
		return FirewallRuleDirectionAny, nil
	case "in":
		return FirewallRuleDirectionIn, nil
	case "out":
		return FirewallRuleDirectionOut, nil
	}
	var t FirewallRuleDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleDirection) Ptr() *FirewallRuleDirection {
	return &f
}

type FirewallRuleIcmptypeItem string

const (
	FirewallRuleIcmptypeItemAny       FirewallRuleIcmptypeItem = "any"
	FirewallRuleIcmptypeItemAlthost   FirewallRuleIcmptypeItem = "althost"
	FirewallRuleIcmptypeItemDataconv  FirewallRuleIcmptypeItem = "dataconv"
	FirewallRuleIcmptypeItemEchorep   FirewallRuleIcmptypeItem = "echorep"
	FirewallRuleIcmptypeItemEchoreq   FirewallRuleIcmptypeItem = "echoreq"
	FirewallRuleIcmptypeItemInforep   FirewallRuleIcmptypeItem = "inforep"
	FirewallRuleIcmptypeItemInforeq   FirewallRuleIcmptypeItem = "inforeq"
	FirewallRuleIcmptypeItemIpv6Here  FirewallRuleIcmptypeItem = "ipv6-here"
	FirewallRuleIcmptypeItemIpv6Where FirewallRuleIcmptypeItem = "ipv6-where"
	FirewallRuleIcmptypeItemMaskrep   FirewallRuleIcmptypeItem = "maskrep"
	FirewallRuleIcmptypeItemMaskreq   FirewallRuleIcmptypeItem = "maskreq"
	FirewallRuleIcmptypeItemMobredir  FirewallRuleIcmptypeItem = "mobredir"
	FirewallRuleIcmptypeItemMobregrep FirewallRuleIcmptypeItem = "mobregrep"
	FirewallRuleIcmptypeItemMobregreq FirewallRuleIcmptypeItem = "mobregreq"
	FirewallRuleIcmptypeItemParamprob FirewallRuleIcmptypeItem = "paramprob"
	FirewallRuleIcmptypeItemPhoturis  FirewallRuleIcmptypeItem = "photuris"
	FirewallRuleIcmptypeItemRedir     FirewallRuleIcmptypeItem = "redir"
	FirewallRuleIcmptypeItemRouteradv FirewallRuleIcmptypeItem = "routeradv"
	FirewallRuleIcmptypeItemRoutersol FirewallRuleIcmptypeItem = "routersol"
	FirewallRuleIcmptypeItemSkip      FirewallRuleIcmptypeItem = "skip"
	FirewallRuleIcmptypeItemSquench   FirewallRuleIcmptypeItem = "squench"
	FirewallRuleIcmptypeItemTimerep   FirewallRuleIcmptypeItem = "timerep"
	FirewallRuleIcmptypeItemTimereq   FirewallRuleIcmptypeItem = "timereq"
	FirewallRuleIcmptypeItemTimex     FirewallRuleIcmptypeItem = "timex"
	FirewallRuleIcmptypeItemTrace     FirewallRuleIcmptypeItem = "trace"
	FirewallRuleIcmptypeItemUnreach   FirewallRuleIcmptypeItem = "unreach"
)

func NewFirewallRuleIcmptypeItemFromString(s string) (FirewallRuleIcmptypeItem, error) {
	switch s {
	case "any":
		return FirewallRuleIcmptypeItemAny, nil
	case "althost":
		return FirewallRuleIcmptypeItemAlthost, nil
	case "dataconv":
		return FirewallRuleIcmptypeItemDataconv, nil
	case "echorep":
		return FirewallRuleIcmptypeItemEchorep, nil
	case "echoreq":
		return FirewallRuleIcmptypeItemEchoreq, nil
	case "inforep":
		return FirewallRuleIcmptypeItemInforep, nil
	case "inforeq":
		return FirewallRuleIcmptypeItemInforeq, nil
	case "ipv6-here":
		return FirewallRuleIcmptypeItemIpv6Here, nil
	case "ipv6-where":
		return FirewallRuleIcmptypeItemIpv6Where, nil
	case "maskrep":
		return FirewallRuleIcmptypeItemMaskrep, nil
	case "maskreq":
		return FirewallRuleIcmptypeItemMaskreq, nil
	case "mobredir":
		return FirewallRuleIcmptypeItemMobredir, nil
	case "mobregrep":
		return FirewallRuleIcmptypeItemMobregrep, nil
	case "mobregreq":
		return FirewallRuleIcmptypeItemMobregreq, nil
	case "paramprob":
		return FirewallRuleIcmptypeItemParamprob, nil
	case "photuris":
		return FirewallRuleIcmptypeItemPhoturis, nil
	case "redir":
		return FirewallRuleIcmptypeItemRedir, nil
	case "routeradv":
		return FirewallRuleIcmptypeItemRouteradv, nil
	case "routersol":
		return FirewallRuleIcmptypeItemRoutersol, nil
	case "skip":
		return FirewallRuleIcmptypeItemSkip, nil
	case "squench":
		return FirewallRuleIcmptypeItemSquench, nil
	case "timerep":
		return FirewallRuleIcmptypeItemTimerep, nil
	case "timereq":
		return FirewallRuleIcmptypeItemTimereq, nil
	case "timex":
		return FirewallRuleIcmptypeItemTimex, nil
	case "trace":
		return FirewallRuleIcmptypeItemTrace, nil
	case "unreach":
		return FirewallRuleIcmptypeItemUnreach, nil
	}
	var t FirewallRuleIcmptypeItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleIcmptypeItem) Ptr() *FirewallRuleIcmptypeItem {
	return &f
}

// The IP version(s) this rule applies to.<br>
type FirewallRuleIpprotocol string

const (
	FirewallRuleIpprotocolInet   FirewallRuleIpprotocol = "inet"
	FirewallRuleIpprotocolInet6  FirewallRuleIpprotocol = "inet6"
	FirewallRuleIpprotocolInet46 FirewallRuleIpprotocol = "inet46"
)

func NewFirewallRuleIpprotocolFromString(s string) (FirewallRuleIpprotocol, error) {
	switch s {
	case "inet":
		return FirewallRuleIpprotocolInet, nil
	case "inet6":
		return FirewallRuleIpprotocolInet6, nil
	case "inet46":
		return FirewallRuleIpprotocolInet46, nil
	}
	var t FirewallRuleIpprotocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleIpprotocol) Ptr() *FirewallRuleIpprotocol {
	return &f
}

// The IP/transport protocol this rule should match.<br>
type FirewallRuleProtocol string

const (
	FirewallRuleProtocolTCP    FirewallRuleProtocol = "tcp"
	FirewallRuleProtocolUDP    FirewallRuleProtocol = "udp"
	FirewallRuleProtocolTcpUdp FirewallRuleProtocol = "tcp/udp"
	FirewallRuleProtocolIcmp   FirewallRuleProtocol = "icmp"
	FirewallRuleProtocolEsp    FirewallRuleProtocol = "esp"
	FirewallRuleProtocolAh     FirewallRuleProtocol = "ah"
	FirewallRuleProtocolGre    FirewallRuleProtocol = "gre"
	FirewallRuleProtocolIpv6   FirewallRuleProtocol = "ipv6"
	FirewallRuleProtocolIgmp   FirewallRuleProtocol = "igmp"
	FirewallRuleProtocolPim    FirewallRuleProtocol = "pim"
	FirewallRuleProtocolOspf   FirewallRuleProtocol = "ospf"
	FirewallRuleProtocolCarp   FirewallRuleProtocol = "carp"
	FirewallRuleProtocolPfsync FirewallRuleProtocol = "pfsync"
)

func NewFirewallRuleProtocolFromString(s string) (FirewallRuleProtocol, error) {
	switch s {
	case "tcp":
		return FirewallRuleProtocolTCP, nil
	case "udp":
		return FirewallRuleProtocolUDP, nil
	case "tcp/udp":
		return FirewallRuleProtocolTcpUdp, nil
	case "icmp":
		return FirewallRuleProtocolIcmp, nil
	case "esp":
		return FirewallRuleProtocolEsp, nil
	case "ah":
		return FirewallRuleProtocolAh, nil
	case "gre":
		return FirewallRuleProtocolGre, nil
	case "ipv6":
		return FirewallRuleProtocolIpv6, nil
	case "igmp":
		return FirewallRuleProtocolIgmp, nil
	case "pim":
		return FirewallRuleProtocolPim, nil
	case "ospf":
		return FirewallRuleProtocolOspf, nil
	case "carp":
		return FirewallRuleProtocolCarp, nil
	case "pfsync":
		return FirewallRuleProtocolPfsync, nil
	}
	var t FirewallRuleProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleProtocol) Ptr() *FirewallRuleProtocol {
	return &f
}

// The state mechanism to use for this firewall rule.<br>
type FirewallRuleStatetype string

const (
	FirewallRuleStatetypeKeepState     FirewallRuleStatetype = "keep state"
	FirewallRuleStatetypeSloppyState   FirewallRuleStatetype = "sloppy state"
	FirewallRuleStatetypeSynproxyState FirewallRuleStatetype = "synproxy state"
	FirewallRuleStatetypeNone          FirewallRuleStatetype = "none"
)

func NewFirewallRuleStatetypeFromString(s string) (FirewallRuleStatetype, error) {
	switch s {
	case "keep state":
		return FirewallRuleStatetypeKeepState, nil
	case "sloppy state":
		return FirewallRuleStatetypeSloppyState, nil
	case "synproxy state":
		return FirewallRuleStatetypeSynproxyState, nil
	case "none":
		return FirewallRuleStatetypeNone, nil
	}
	var t FirewallRuleStatetype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleStatetype) Ptr() *FirewallRuleStatetype {
	return &f
}

type FirewallRuleTCPFlagsOutOfItem string

const (
	FirewallRuleTCPFlagsOutOfItemFin FirewallRuleTCPFlagsOutOfItem = "fin"
	FirewallRuleTCPFlagsOutOfItemSyn FirewallRuleTCPFlagsOutOfItem = "syn"
	FirewallRuleTCPFlagsOutOfItemRst FirewallRuleTCPFlagsOutOfItem = "rst"
	FirewallRuleTCPFlagsOutOfItemPsh FirewallRuleTCPFlagsOutOfItem = "psh"
	FirewallRuleTCPFlagsOutOfItemAck FirewallRuleTCPFlagsOutOfItem = "ack"
	FirewallRuleTCPFlagsOutOfItemUrg FirewallRuleTCPFlagsOutOfItem = "urg"
	FirewallRuleTCPFlagsOutOfItemEce FirewallRuleTCPFlagsOutOfItem = "ece"
	FirewallRuleTCPFlagsOutOfItemCwr FirewallRuleTCPFlagsOutOfItem = "cwr"
)

func NewFirewallRuleTCPFlagsOutOfItemFromString(s string) (FirewallRuleTCPFlagsOutOfItem, error) {
	switch s {
	case "fin":
		return FirewallRuleTCPFlagsOutOfItemFin, nil
	case "syn":
		return FirewallRuleTCPFlagsOutOfItemSyn, nil
	case "rst":
		return FirewallRuleTCPFlagsOutOfItemRst, nil
	case "psh":
		return FirewallRuleTCPFlagsOutOfItemPsh, nil
	case "ack":
		return FirewallRuleTCPFlagsOutOfItemAck, nil
	case "urg":
		return FirewallRuleTCPFlagsOutOfItemUrg, nil
	case "ece":
		return FirewallRuleTCPFlagsOutOfItemEce, nil
	case "cwr":
		return FirewallRuleTCPFlagsOutOfItemCwr, nil
	}
	var t FirewallRuleTCPFlagsOutOfItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleTCPFlagsOutOfItem) Ptr() *FirewallRuleTCPFlagsOutOfItem {
	return &f
}

type FirewallRuleTCPFlagsSetItem string

const (
	FirewallRuleTCPFlagsSetItemFin FirewallRuleTCPFlagsSetItem = "fin"
	FirewallRuleTCPFlagsSetItemSyn FirewallRuleTCPFlagsSetItem = "syn"
	FirewallRuleTCPFlagsSetItemRst FirewallRuleTCPFlagsSetItem = "rst"
	FirewallRuleTCPFlagsSetItemPsh FirewallRuleTCPFlagsSetItem = "psh"
	FirewallRuleTCPFlagsSetItemAck FirewallRuleTCPFlagsSetItem = "ack"
	FirewallRuleTCPFlagsSetItemUrg FirewallRuleTCPFlagsSetItem = "urg"
	FirewallRuleTCPFlagsSetItemEce FirewallRuleTCPFlagsSetItem = "ece"
	FirewallRuleTCPFlagsSetItemCwr FirewallRuleTCPFlagsSetItem = "cwr"
)

func NewFirewallRuleTCPFlagsSetItemFromString(s string) (FirewallRuleTCPFlagsSetItem, error) {
	switch s {
	case "fin":
		return FirewallRuleTCPFlagsSetItemFin, nil
	case "syn":
		return FirewallRuleTCPFlagsSetItemSyn, nil
	case "rst":
		return FirewallRuleTCPFlagsSetItemRst, nil
	case "psh":
		return FirewallRuleTCPFlagsSetItemPsh, nil
	case "ack":
		return FirewallRuleTCPFlagsSetItemAck, nil
	case "urg":
		return FirewallRuleTCPFlagsSetItemUrg, nil
	case "ece":
		return FirewallRuleTCPFlagsSetItemEce, nil
	case "cwr":
		return FirewallRuleTCPFlagsSetItemCwr, nil
	}
	var t FirewallRuleTCPFlagsSetItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleTCPFlagsSetItem) Ptr() *FirewallRuleTCPFlagsSetItem {
	return &f
}

// The action to take against traffic that matches this rule.<br>
type FirewallRuleType string

const (
	FirewallRuleTypePass   FirewallRuleType = "pass"
	FirewallRuleTypeBlock  FirewallRuleType = "block"
	FirewallRuleTypeReject FirewallRuleType = "reject"
)

func NewFirewallRuleTypeFromString(s string) (FirewallRuleType, error) {
	switch s {
	case "pass":
		return FirewallRuleTypePass, nil
	case "block":
		return FirewallRuleTypeBlock, nil
	case "reject":
		return FirewallRuleTypeReject, nil
	}
	var t FirewallRuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FirewallRuleType) Ptr() *FirewallRuleType {
	return &f
}

type FirewallSchedule struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallSchedule(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallSchedule) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FirewallScheduleTimeRange struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallScheduleTimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallScheduleTimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallScheduleTimeRange(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallScheduleTimeRange) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FirewallScheduleTimerangeItem struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallScheduleTimerangeItem) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallScheduleTimerangeItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallScheduleTimerangeItem(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallScheduleTimerangeItem) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FirewallState struct {
	// The interface that initially received the traffic which registered the state.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol listed in the state.<br>
	Protocol *string `json:"protocol,omitempty"`
	// The direction of traffic listed in the state.<br>
	Direction *string `json:"direction,omitempty"`
	// The source address listed in the state. Note: Depending on the `protocol`, this value may contain the source port as well.<br>
	Source *string `json:"source,omitempty"`
	// The destination address listed in the state. Note: Depending on the `protocol`, this value may contain the destination port as well.<br>
	Destination *string `json:"destination,omitempty"`
	// The current status of the firewall state.<br>
	State *string `json:"state,omitempty"`
	// The age of the firewall state in HH:MM:SS format.<br>
	Age *string `json:"age,omitempty"`
	// The amount of time remaining until the state expires in HH:MM:SS format.<br>
	ExpiresIn *string `json:"expires_in,omitempty"`
	// The total number of packets observed by the state.<br>
	PacketsTotal *int `json:"packets_total,omitempty"`
	// The total number of inbound packets observed by the state.<br>
	PacketsIn *int `json:"packets_in,omitempty"`
	// The total number of outbound packets observed by the state.<br>
	PacketsOut *int `json:"packets_out,omitempty"`
	// The total number of traffic (in bytes) observed by the state.<br>
	BytesTotal *int `json:"bytes_total,omitempty"`
	// The total number of inbound traffic (in bytes) observed by the state.<br>
	BytesIn *int `json:"bytes_in,omitempty"`
	// The total number of outbound traffic (in bytes) observed by the state.<br>
	BytesOut *int `json:"bytes_out,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallState) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallState
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallState(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallState) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FirewallStatesSize struct {
	// The maximum number of firewall state entries allowed by this firewall.<br>
	Maximumstates *int `json:"maximumstates,omitempty"`
	// The default number of firewall state entries allowed by this firewall.<br>
	Defaultmaximumstates *int `json:"defaultmaximumstates,omitempty"`
	// The number of firewall state entries currently registered in the states table.<br>
	Currentstates *int `json:"currentstates,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FirewallStatesSize) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallStatesSize
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallStatesSize(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirewallStatesSize) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type OneToOneNatMapping struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OneToOneNatMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler OneToOneNatMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OneToOneNatMapping(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OneToOneNatMapping) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The IP version this mapping applies to.<br>
type OneToOneNatMappingIpprotocol string

const (
	OneToOneNatMappingIpprotocolInet  OneToOneNatMappingIpprotocol = "inet"
	OneToOneNatMappingIpprotocolInet6 OneToOneNatMappingIpprotocol = "inet6"
)

func NewOneToOneNatMappingIpprotocolFromString(s string) (OneToOneNatMappingIpprotocol, error) {
	switch s {
	case "inet":
		return OneToOneNatMappingIpprotocolInet, nil
	case "inet6":
		return OneToOneNatMappingIpprotocolInet6, nil
	}
	var t OneToOneNatMappingIpprotocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OneToOneNatMappingIpprotocol) Ptr() *OneToOneNatMappingIpprotocol {
	return &o
}

// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
type OneToOneNatMappingNatreflection string

const (
	OneToOneNatMappingNatreflectionEnable  OneToOneNatMappingNatreflection = "enable"
	OneToOneNatMappingNatreflectionDisable OneToOneNatMappingNatreflection = "disable"
)

func NewOneToOneNatMappingNatreflectionFromString(s string) (OneToOneNatMappingNatreflection, error) {
	switch s {
	case "enable":
		return OneToOneNatMappingNatreflectionEnable, nil
	case "disable":
		return OneToOneNatMappingNatreflectionDisable, nil
	}
	var t OneToOneNatMappingNatreflection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OneToOneNatMappingNatreflection) Ptr() *OneToOneNatMappingNatreflection {
	return &o
}

type OutboundNatMapping struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OutboundNatMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler OutboundNatMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutboundNatMapping(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OutboundNatMapping) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
type OutboundNatMappingPoolopts string

const (
	OutboundNatMappingPooloptsRoundRobin              OutboundNatMappingPoolopts = "round-robin"
	OutboundNatMappingPooloptsRoundRobinStickyAddress OutboundNatMappingPoolopts = "round-robin sticky-address"
	OutboundNatMappingPooloptsRandom                  OutboundNatMappingPoolopts = "random"
	OutboundNatMappingPooloptsRandomStickyAddress     OutboundNatMappingPoolopts = "random sticky-address"
	OutboundNatMappingPooloptsSourceHash              OutboundNatMappingPoolopts = "source-hash"
	OutboundNatMappingPooloptsBitmask                 OutboundNatMappingPoolopts = "bitmask"
)

func NewOutboundNatMappingPooloptsFromString(s string) (OutboundNatMappingPoolopts, error) {
	switch s {
	case "round-robin":
		return OutboundNatMappingPooloptsRoundRobin, nil
	case "round-robin sticky-address":
		return OutboundNatMappingPooloptsRoundRobinStickyAddress, nil
	case "random":
		return OutboundNatMappingPooloptsRandom, nil
	case "random sticky-address":
		return OutboundNatMappingPooloptsRandomStickyAddress, nil
	case "source-hash":
		return OutboundNatMappingPooloptsSourceHash, nil
	case "bitmask":
		return OutboundNatMappingPooloptsBitmask, nil
	}
	var t OutboundNatMappingPoolopts
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OutboundNatMappingPoolopts) Ptr() *OutboundNatMappingPoolopts {
	return &o
}

// The protocol this rule should match. Use `null` for any protocol.<br>
type OutboundNatMappingProtocol string

const (
	OutboundNatMappingProtocolTCP    OutboundNatMappingProtocol = "tcp"
	OutboundNatMappingProtocolUDP    OutboundNatMappingProtocol = "udp"
	OutboundNatMappingProtocolTcpUdp OutboundNatMappingProtocol = "tcp/udp"
	OutboundNatMappingProtocolIcmp   OutboundNatMappingProtocol = "icmp"
	OutboundNatMappingProtocolEsp    OutboundNatMappingProtocol = "esp"
	OutboundNatMappingProtocolAh     OutboundNatMappingProtocol = "ah"
	OutboundNatMappingProtocolGre    OutboundNatMappingProtocol = "gre"
	OutboundNatMappingProtocolIpv6   OutboundNatMappingProtocol = "ipv6"
	OutboundNatMappingProtocolIgmp   OutboundNatMappingProtocol = "igmp"
	OutboundNatMappingProtocolPim    OutboundNatMappingProtocol = "pim"
	OutboundNatMappingProtocolOspf   OutboundNatMappingProtocol = "ospf"
)

func NewOutboundNatMappingProtocolFromString(s string) (OutboundNatMappingProtocol, error) {
	switch s {
	case "tcp":
		return OutboundNatMappingProtocolTCP, nil
	case "udp":
		return OutboundNatMappingProtocolUDP, nil
	case "tcp/udp":
		return OutboundNatMappingProtocolTcpUdp, nil
	case "icmp":
		return OutboundNatMappingProtocolIcmp, nil
	case "esp":
		return OutboundNatMappingProtocolEsp, nil
	case "ah":
		return OutboundNatMappingProtocolAh, nil
	case "gre":
		return OutboundNatMappingProtocolGre, nil
	case "ipv6":
		return OutboundNatMappingProtocolIpv6, nil
	case "igmp":
		return OutboundNatMappingProtocolIgmp, nil
	case "pim":
		return OutboundNatMappingProtocolPim, nil
	case "ospf":
		return OutboundNatMappingProtocolOspf, nil
	}
	var t OutboundNatMappingProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OutboundNatMappingProtocol) Ptr() *OutboundNatMappingProtocol {
	return &o
}

type OutboundNatMode struct {
	// The outbound NAT mode to assign this system. Set to `automatic` to have this system automatically generate NAT rules this firewall, `hybrid` to automatically generate NAT rules AND allow manual outbound NAT mappings to be assigned, `manual` to prevent the system from automatically generating NAT rules and only allow manual outbound NAT mappings, or `disabled` to disable outbound NAT on this system entirely.<br>
	Mode *OutboundNatModeMode `json:"mode,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OutboundNatMode) UnmarshalJSON(data []byte) error {
	type unmarshaler OutboundNatMode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutboundNatMode(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OutboundNatMode) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The outbound NAT mode to assign this system. Set to `automatic` to have this system automatically generate NAT rules this firewall, `hybrid` to automatically generate NAT rules AND allow manual outbound NAT mappings to be assigned, `manual` to prevent the system from automatically generating NAT rules and only allow manual outbound NAT mappings, or `disabled` to disable outbound NAT on this system entirely.<br>
type OutboundNatModeMode string

const (
	OutboundNatModeModeAutomatic OutboundNatModeMode = "automatic"
	OutboundNatModeModeHybrid    OutboundNatModeMode = "hybrid"
	OutboundNatModeModeAdvanced  OutboundNatModeMode = "advanced"
	OutboundNatModeModeDisabled  OutboundNatModeMode = "disabled"
)

func NewOutboundNatModeModeFromString(s string) (OutboundNatModeMode, error) {
	switch s {
	case "automatic":
		return OutboundNatModeModeAutomatic, nil
	case "hybrid":
		return OutboundNatModeModeHybrid, nil
	case "advanced":
		return OutboundNatModeModeAdvanced, nil
	case "disabled":
		return OutboundNatModeModeDisabled, nil
	}
	var t OutboundNatModeMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OutboundNatModeMode) Ptr() *OutboundNatModeMode {
	return &o
}

type PortForward struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PortForward) UnmarshalJSON(data []byte) error {
	type unmarshaler PortForward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PortForward(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PortForward) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The IP protocol this port forward rule should match.<br>
type PortForwardIpprotocol string

const (
	PortForwardIpprotocolInet   PortForwardIpprotocol = "inet"
	PortForwardIpprotocolInet6  PortForwardIpprotocol = "inet6"
	PortForwardIpprotocolInet46 PortForwardIpprotocol = "inet46"
)

func NewPortForwardIpprotocolFromString(s string) (PortForwardIpprotocol, error) {
	switch s {
	case "inet":
		return PortForwardIpprotocolInet, nil
	case "inet6":
		return PortForwardIpprotocolInet6, nil
	case "inet46":
		return PortForwardIpprotocolInet46, nil
	}
	var t PortForwardIpprotocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PortForwardIpprotocol) Ptr() *PortForwardIpprotocol {
	return &p
}

// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
type PortForwardNatreflection string

const (
	PortForwardNatreflectionEnable  PortForwardNatreflection = "enable"
	PortForwardNatreflectionDisable PortForwardNatreflection = "disable"
	PortForwardNatreflectionPurenat PortForwardNatreflection = "purenat"
)

func NewPortForwardNatreflectionFromString(s string) (PortForwardNatreflection, error) {
	switch s {
	case "enable":
		return PortForwardNatreflectionEnable, nil
	case "disable":
		return PortForwardNatreflectionDisable, nil
	case "purenat":
		return PortForwardNatreflectionPurenat, nil
	}
	var t PortForwardNatreflection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PortForwardNatreflection) Ptr() *PortForwardNatreflection {
	return &p
}

// The IP/transport protocol this port forward rule should match.<br>
type PortForwardProtocol string

const (
	PortForwardProtocolAny    PortForwardProtocol = "any"
	PortForwardProtocolTCP    PortForwardProtocol = "tcp"
	PortForwardProtocolUDP    PortForwardProtocol = "udp"
	PortForwardProtocolTcpUdp PortForwardProtocol = "tcp/udp"
	PortForwardProtocolIcmp   PortForwardProtocol = "icmp"
	PortForwardProtocolEsp    PortForwardProtocol = "esp"
	PortForwardProtocolAh     PortForwardProtocol = "ah"
	PortForwardProtocolGre    PortForwardProtocol = "gre"
	PortForwardProtocolIpv6   PortForwardProtocol = "ipv6"
	PortForwardProtocolIgmp   PortForwardProtocol = "igmp"
	PortForwardProtocolPim    PortForwardProtocol = "pim"
	PortForwardProtocolOspf   PortForwardProtocol = "ospf"
)

func NewPortForwardProtocolFromString(s string) (PortForwardProtocol, error) {
	switch s {
	case "any":
		return PortForwardProtocolAny, nil
	case "tcp":
		return PortForwardProtocolTCP, nil
	case "udp":
		return PortForwardProtocolUDP, nil
	case "tcp/udp":
		return PortForwardProtocolTcpUdp, nil
	case "icmp":
		return PortForwardProtocolIcmp, nil
	case "esp":
		return PortForwardProtocolEsp, nil
	case "ah":
		return PortForwardProtocolAh, nil
	case "gre":
		return PortForwardProtocolGre, nil
	case "ipv6":
		return PortForwardProtocolIpv6, nil
	case "igmp":
		return PortForwardProtocolIgmp, nil
	case "pim":
		return PortForwardProtocolPim, nil
	case "ospf":
		return PortForwardProtocolOspf, nil
	}
	var t PortForwardProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PortForwardProtocol) Ptr() *PortForwardProtocol {
	return &p
}

type TrafficShaper struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaper) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaper
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaper(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaper) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The scale type of the `bandwidth` field's value.<br>
type TrafficShaperBandwidthtype string

const (
	TrafficShaperBandwidthtypeChar37 TrafficShaperBandwidthtype = "char_37"
	TrafficShaperBandwidthtypeB      TrafficShaperBandwidthtype = "b"
	TrafficShaperBandwidthtypeKb     TrafficShaperBandwidthtype = "Kb"
	TrafficShaperBandwidthtypeMb     TrafficShaperBandwidthtype = "Mb"
	TrafficShaperBandwidthtypeGb     TrafficShaperBandwidthtype = "Gb"
)

func NewTrafficShaperBandwidthtypeFromString(s string) (TrafficShaperBandwidthtype, error) {
	switch s {
	case "char_37":
		return TrafficShaperBandwidthtypeChar37, nil
	case "b":
		return TrafficShaperBandwidthtypeB, nil
	case "Kb":
		return TrafficShaperBandwidthtypeKb, nil
	case "Mb":
		return TrafficShaperBandwidthtypeMb, nil
	case "Gb":
		return TrafficShaperBandwidthtypeGb, nil
	}
	var t TrafficShaperBandwidthtype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperBandwidthtype) Ptr() *TrafficShaperBandwidthtype {
	return &t
}

type TrafficShaperLimiter struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaperLimiter) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaperLimiter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaperLimiter(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaperLimiter) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
type TrafficShaperLimiterAqm string

const (
	TrafficShaperLimiterAqmDroptail TrafficShaperLimiterAqm = "droptail"
	TrafficShaperLimiterAqmCodel    TrafficShaperLimiterAqm = "codel"
	TrafficShaperLimiterAqmPie      TrafficShaperLimiterAqm = "pie"
	TrafficShaperLimiterAqmRed      TrafficShaperLimiterAqm = "red"
	TrafficShaperLimiterAqmGred     TrafficShaperLimiterAqm = "gred"
)

func NewTrafficShaperLimiterAqmFromString(s string) (TrafficShaperLimiterAqm, error) {
	switch s {
	case "droptail":
		return TrafficShaperLimiterAqmDroptail, nil
	case "codel":
		return TrafficShaperLimiterAqmCodel, nil
	case "pie":
		return TrafficShaperLimiterAqmPie, nil
	case "red":
		return TrafficShaperLimiterAqmRed, nil
	case "gred":
		return TrafficShaperLimiterAqmGred, nil
	}
	var t TrafficShaperLimiterAqm
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperLimiterAqm) Ptr() *TrafficShaperLimiterAqm {
	return &t
}

type TrafficShaperLimiterBandwidth struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched *string `json:"bwsched,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaperLimiterBandwidth) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaperLimiterBandwidth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaperLimiterBandwidth(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaperLimiterBandwidth) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The scale factor of the `bw` fields value.<br>
type TrafficShaperLimiterBandwidthBwscale string

const (
	TrafficShaperLimiterBandwidthBwscaleB  TrafficShaperLimiterBandwidthBwscale = "b"
	TrafficShaperLimiterBandwidthBwscaleKb TrafficShaperLimiterBandwidthBwscale = "Kb"
	TrafficShaperLimiterBandwidthBwscaleMb TrafficShaperLimiterBandwidthBwscale = "Mb"
)

func NewTrafficShaperLimiterBandwidthBwscaleFromString(s string) (TrafficShaperLimiterBandwidthBwscale, error) {
	switch s {
	case "b":
		return TrafficShaperLimiterBandwidthBwscaleB, nil
	case "Kb":
		return TrafficShaperLimiterBandwidthBwscaleKb, nil
	case "Mb":
		return TrafficShaperLimiterBandwidthBwscaleMb, nil
	}
	var t TrafficShaperLimiterBandwidthBwscale
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperLimiterBandwidthBwscale) Ptr() *TrafficShaperLimiterBandwidthBwscale {
	return &t
}

type TrafficShaperLimiterBandwidthItem struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched *string `json:"bwsched,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaperLimiterBandwidthItem) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaperLimiterBandwidthItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaperLimiterBandwidthItem(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaperLimiterBandwidthItem) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
type TrafficShaperLimiterMask string

const (
	TrafficShaperLimiterMaskNone       TrafficShaperLimiterMask = "none"
	TrafficShaperLimiterMaskSrcaddress TrafficShaperLimiterMask = "srcaddress"
	TrafficShaperLimiterMaskDstaddress TrafficShaperLimiterMask = "dstaddress"
)

func NewTrafficShaperLimiterMaskFromString(s string) (TrafficShaperLimiterMask, error) {
	switch s {
	case "none":
		return TrafficShaperLimiterMaskNone, nil
	case "srcaddress":
		return TrafficShaperLimiterMaskSrcaddress, nil
	case "dstaddress":
		return TrafficShaperLimiterMaskDstaddress, nil
	}
	var t TrafficShaperLimiterMask
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperLimiterMask) Ptr() *TrafficShaperLimiterMask {
	return &t
}

type TrafficShaperLimiterQueue struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaperLimiterQueue) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaperLimiterQueue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaperLimiterQueue(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaperLimiterQueue) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
type TrafficShaperLimiterQueueAqm string

const (
	TrafficShaperLimiterQueueAqmDroptail TrafficShaperLimiterQueueAqm = "droptail"
	TrafficShaperLimiterQueueAqmCodel    TrafficShaperLimiterQueueAqm = "codel"
	TrafficShaperLimiterQueueAqmPie      TrafficShaperLimiterQueueAqm = "pie"
	TrafficShaperLimiterQueueAqmRed      TrafficShaperLimiterQueueAqm = "red"
	TrafficShaperLimiterQueueAqmGred     TrafficShaperLimiterQueueAqm = "gred"
)

func NewTrafficShaperLimiterQueueAqmFromString(s string) (TrafficShaperLimiterQueueAqm, error) {
	switch s {
	case "droptail":
		return TrafficShaperLimiterQueueAqmDroptail, nil
	case "codel":
		return TrafficShaperLimiterQueueAqmCodel, nil
	case "pie":
		return TrafficShaperLimiterQueueAqmPie, nil
	case "red":
		return TrafficShaperLimiterQueueAqmRed, nil
	case "gred":
		return TrafficShaperLimiterQueueAqmGred, nil
	}
	var t TrafficShaperLimiterQueueAqm
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperLimiterQueueAqm) Ptr() *TrafficShaperLimiterQueueAqm {
	return &t
}

type TrafficShaperLimiterQueueItem struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaperLimiterQueueItem) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaperLimiterQueueItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaperLimiterQueueItem(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaperLimiterQueueItem) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
type TrafficShaperLimiterQueueMask string

const (
	TrafficShaperLimiterQueueMaskNone       TrafficShaperLimiterQueueMask = "none"
	TrafficShaperLimiterQueueMaskSrcaddress TrafficShaperLimiterQueueMask = "srcaddress"
	TrafficShaperLimiterQueueMaskDstaddress TrafficShaperLimiterQueueMask = "dstaddress"
)

func NewTrafficShaperLimiterQueueMaskFromString(s string) (TrafficShaperLimiterQueueMask, error) {
	switch s {
	case "none":
		return TrafficShaperLimiterQueueMaskNone, nil
	case "srcaddress":
		return TrafficShaperLimiterQueueMaskSrcaddress, nil
	case "dstaddress":
		return TrafficShaperLimiterQueueMaskDstaddress, nil
	}
	var t TrafficShaperLimiterQueueMask
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperLimiterQueueMask) Ptr() *TrafficShaperLimiterQueueMask {
	return &t
}

// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
type TrafficShaperLimiterSched string

const (
	TrafficShaperLimiterSchedWf2Q    TrafficShaperLimiterSched = "wf2q+"
	TrafficShaperLimiterSchedFifo    TrafficShaperLimiterSched = "fifo"
	TrafficShaperLimiterSchedQfq     TrafficShaperLimiterSched = "qfq"
	TrafficShaperLimiterSchedRr      TrafficShaperLimiterSched = "rr"
	TrafficShaperLimiterSchedPrio    TrafficShaperLimiterSched = "prio"
	TrafficShaperLimiterSchedFqCodel TrafficShaperLimiterSched = "fq_codel"
	TrafficShaperLimiterSchedFqPie   TrafficShaperLimiterSched = "fq_pie"
)

func NewTrafficShaperLimiterSchedFromString(s string) (TrafficShaperLimiterSched, error) {
	switch s {
	case "wf2q+":
		return TrafficShaperLimiterSchedWf2Q, nil
	case "fifo":
		return TrafficShaperLimiterSchedFifo, nil
	case "qfq":
		return TrafficShaperLimiterSchedQfq, nil
	case "rr":
		return TrafficShaperLimiterSchedRr, nil
	case "prio":
		return TrafficShaperLimiterSchedPrio, nil
	case "fq_codel":
		return TrafficShaperLimiterSchedFqCodel, nil
	case "fq_pie":
		return TrafficShaperLimiterSchedFqPie, nil
	}
	var t TrafficShaperLimiterSched
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperLimiterSched) Ptr() *TrafficShaperLimiterSched {
	return &t
}

type TrafficShaperQueue struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaperQueue) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaperQueue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaperQueue(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaperQueue) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
type TrafficShaperQueueBandwidthtype string

const (
	TrafficShaperQueueBandwidthtypeChar37 TrafficShaperQueueBandwidthtype = "char_37"
	TrafficShaperQueueBandwidthtypeB      TrafficShaperQueueBandwidthtype = "b"
	TrafficShaperQueueBandwidthtypeKb     TrafficShaperQueueBandwidthtype = "Kb"
	TrafficShaperQueueBandwidthtypeMb     TrafficShaperQueueBandwidthtype = "Mb"
	TrafficShaperQueueBandwidthtypeGb     TrafficShaperQueueBandwidthtype = "Gb"
)

func NewTrafficShaperQueueBandwidthtypeFromString(s string) (TrafficShaperQueueBandwidthtype, error) {
	switch s {
	case "char_37":
		return TrafficShaperQueueBandwidthtypeChar37, nil
	case "b":
		return TrafficShaperQueueBandwidthtypeB, nil
	case "Kb":
		return TrafficShaperQueueBandwidthtypeKb, nil
	case "Mb":
		return TrafficShaperQueueBandwidthtypeMb, nil
	case "Gb":
		return TrafficShaperQueueBandwidthtypeGb, nil
	}
	var t TrafficShaperQueueBandwidthtype
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperQueueBandwidthtype) Ptr() *TrafficShaperQueueBandwidthtype {
	return &t
}

type TrafficShaperQueueItem struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TrafficShaperQueueItem) UnmarshalJSON(data []byte) error {
	type unmarshaler TrafficShaperQueueItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TrafficShaperQueueItem(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TrafficShaperQueueItem) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
type TrafficShaperScheduler string

const (
	TrafficShaperSchedulerHfsc   TrafficShaperScheduler = "HFSC"
	TrafficShaperSchedulerCbq    TrafficShaperScheduler = "CBQ"
	TrafficShaperSchedulerFairq  TrafficShaperScheduler = "FAIRQ"
	TrafficShaperSchedulerCodelq TrafficShaperScheduler = "CODELQ"
	TrafficShaperSchedulerPriq   TrafficShaperScheduler = "PRIQ"
)

func NewTrafficShaperSchedulerFromString(s string) (TrafficShaperScheduler, error) {
	switch s {
	case "HFSC":
		return TrafficShaperSchedulerHfsc, nil
	case "CBQ":
		return TrafficShaperSchedulerCbq, nil
	case "FAIRQ":
		return TrafficShaperSchedulerFairq, nil
	case "CODELQ":
		return TrafficShaperSchedulerCodelq, nil
	case "PRIQ":
		return TrafficShaperSchedulerPriq, nil
	}
	var t TrafficShaperScheduler
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrafficShaperScheduler) Ptr() *TrafficShaperScheduler {
	return &t
}

type VirtualIP struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VirtualIP) UnmarshalJSON(data []byte) error {
	type unmarshaler VirtualIP
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VirtualIP(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VirtualIP) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VirtualIPApply struct {
	// Displays `true` when all virtual IP changes are applied and there are no pending changes left.Displays `false` when there are pending virtual IP changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VirtualIPApply) UnmarshalJSON(data []byte) error {
	type unmarshaler VirtualIPApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VirtualIPApply(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VirtualIPApply) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
type VirtualIPCarpMode string

const (
	VirtualIPCarpModeMcast VirtualIPCarpMode = "mcast"
	VirtualIPCarpModeUcast VirtualIPCarpMode = "ucast"
)

func NewVirtualIPCarpModeFromString(s string) (VirtualIPCarpMode, error) {
	switch s {
	case "mcast":
		return VirtualIPCarpModeMcast, nil
	case "ucast":
		return VirtualIPCarpModeUcast, nil
	}
	var t VirtualIPCarpMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VirtualIPCarpMode) Ptr() *VirtualIPCarpMode {
	return &v
}

// The virtual IP mode to use for this virtual IP.<br>
type VirtualIPMode string

const (
	VirtualIPModeIpalias  VirtualIPMode = "ipalias"
	VirtualIPModeProxyarp VirtualIPMode = "proxyarp"
	VirtualIPModeCarp     VirtualIPMode = "carp"
	VirtualIPModeOther    VirtualIPMode = "other"
)

func NewVirtualIPModeFromString(s string) (VirtualIPMode, error) {
	switch s {
	case "ipalias":
		return VirtualIPModeIpalias, nil
	case "proxyarp":
		return VirtualIPModeProxyarp, nil
	case "carp":
		return VirtualIPModeCarp, nil
	case "other":
		return VirtualIPModeOther, nil
	}
	var t VirtualIPMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VirtualIPMode) Ptr() *VirtualIPMode {
	return &v
}

// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
type VirtualIPType string

const (
	VirtualIPTypeSingle  VirtualIPType = "single"
	VirtualIPTypeNetwork VirtualIPType = "network"
)

func NewVirtualIPTypeFromString(s string) (VirtualIPType, error) {
	switch s {
	case "single":
		return VirtualIPTypeSingle, nil
	case "network":
		return VirtualIPTypeNetwork, nil
	}
	var t VirtualIPType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VirtualIPType) Ptr() *VirtualIPType {
	return &v
}

type DeleteFirewallAliasEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallAliasEndpointRequestIDFromInteger(value int) *DeleteFirewallAliasEndpointRequestID {
	return &DeleteFirewallAliasEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallAliasEndpointRequestIDFromString(value string) *DeleteFirewallAliasEndpointRequestID {
	return &DeleteFirewallAliasEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallAliasEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallAliasEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallAliasEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallAliasEndpointRequestID) Accept(visitor DeleteFirewallAliasEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallAliasEndpointResponse struct {
	Data *DeleteFirewallAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallAliasEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallAliasEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallAliasEndpointResponseData struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	ID     *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallAliasEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallAliasEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallAliasesEndpointResponse struct {
	Data []*DeleteFirewallAliasesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallAliasesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallAliasesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallAliasesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallAliasesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallAliasesEndpointResponseDataItem struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	ID     *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallAliasesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallAliasesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallAliasesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallAliasesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOneToOneMappingEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallNatOneToOneMappingEndpointRequestIDFromInteger(value int) *DeleteFirewallNatOneToOneMappingEndpointRequestID {
	return &DeleteFirewallNatOneToOneMappingEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallNatOneToOneMappingEndpointRequestIDFromString(value string) *DeleteFirewallNatOneToOneMappingEndpointRequestID {
	return &DeleteFirewallNatOneToOneMappingEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallNatOneToOneMappingEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallNatOneToOneMappingEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallNatOneToOneMappingEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallNatOneToOneMappingEndpointRequestID) Accept(visitor DeleteFirewallNatOneToOneMappingEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallNatOneToOneMappingEndpointResponse struct {
	Data *DeleteFirewallNatOneToOneMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOneToOneMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOneToOneMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOneToOneMappingEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOneToOneMappingEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOneToOneMappingEndpointResponseData struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOneToOneMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOneToOneMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOneToOneMappingEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOneToOneMappingEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOneToOneMappingsEndpointResponse struct {
	Data []*DeleteFirewallNatOneToOneMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOneToOneMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOneToOneMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOneToOneMappingsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOneToOneMappingsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOneToOneMappingsEndpointResponseDataItem struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOneToOneMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOneToOneMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOneToOneMappingsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOneToOneMappingsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOutboundMappingEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallNatOutboundMappingEndpointRequestIDFromInteger(value int) *DeleteFirewallNatOutboundMappingEndpointRequestID {
	return &DeleteFirewallNatOutboundMappingEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallNatOutboundMappingEndpointRequestIDFromString(value string) *DeleteFirewallNatOutboundMappingEndpointRequestID {
	return &DeleteFirewallNatOutboundMappingEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallNatOutboundMappingEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallNatOutboundMappingEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallNatOutboundMappingEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallNatOutboundMappingEndpointRequestID) Accept(visitor DeleteFirewallNatOutboundMappingEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallNatOutboundMappingEndpointResponse struct {
	Data *DeleteFirewallNatOutboundMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOutboundMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOutboundMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOutboundMappingEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOutboundMappingEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOutboundMappingEndpointResponseData struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOutboundMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOutboundMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOutboundMappingEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOutboundMappingEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOutboundMappingsEndpointResponse struct {
	Data []*DeleteFirewallNatOutboundMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOutboundMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOutboundMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOutboundMappingsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOutboundMappingsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatOutboundMappingsEndpointResponseDataItem struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatOutboundMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatOutboundMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatOutboundMappingsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatOutboundMappingsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatPortForwardEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallNatPortForwardEndpointRequestIDFromInteger(value int) *DeleteFirewallNatPortForwardEndpointRequestID {
	return &DeleteFirewallNatPortForwardEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallNatPortForwardEndpointRequestIDFromString(value string) *DeleteFirewallNatPortForwardEndpointRequestID {
	return &DeleteFirewallNatPortForwardEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallNatPortForwardEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallNatPortForwardEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallNatPortForwardEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallNatPortForwardEndpointRequestID) Accept(visitor DeleteFirewallNatPortForwardEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallNatPortForwardEndpointResponse struct {
	Data *DeleteFirewallNatPortForwardEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatPortForwardEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatPortForwardEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatPortForwardEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatPortForwardEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatPortForwardEndpointResponseData struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatPortForwardEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatPortForwardEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatPortForwardEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatPortForwardEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatPortForwardsEndpointResponse struct {
	Data []*DeleteFirewallNatPortForwardsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatPortForwardsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatPortForwardsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatPortForwardsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatPortForwardsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallNatPortForwardsEndpointResponseDataItem struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallNatPortForwardsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallNatPortForwardsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallNatPortForwardsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallNatPortForwardsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallRuleEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallRuleEndpointRequestIDFromInteger(value int) *DeleteFirewallRuleEndpointRequestID {
	return &DeleteFirewallRuleEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallRuleEndpointRequestIDFromString(value string) *DeleteFirewallRuleEndpointRequestID {
	return &DeleteFirewallRuleEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallRuleEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallRuleEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallRuleEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallRuleEndpointRequestID) Accept(visitor DeleteFirewallRuleEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallRuleEndpointResponse struct {
	Data *DeleteFirewallRuleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallRuleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallRuleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallRuleEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallRuleEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallRuleEndpointResponseData struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallRuleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallRuleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallRuleEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallRuleEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallRulesEndpointResponse struct {
	Data []*DeleteFirewallRulesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallRulesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallRulesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallRulesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallRulesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallRulesEndpointResponseDataItem struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallRulesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallRulesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallRulesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallRulesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallScheduleEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallScheduleEndpointRequestIDFromInteger(value int) *DeleteFirewallScheduleEndpointRequestID {
	return &DeleteFirewallScheduleEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallScheduleEndpointRequestIDFromString(value string) *DeleteFirewallScheduleEndpointRequestID {
	return &DeleteFirewallScheduleEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallScheduleEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallScheduleEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallScheduleEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallScheduleEndpointRequestID) Accept(visitor DeleteFirewallScheduleEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallScheduleEndpointResponse struct {
	Data *DeleteFirewallScheduleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallScheduleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallScheduleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallScheduleEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallScheduleEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallScheduleEndpointResponseData struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	ID        *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallScheduleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallScheduleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallScheduleEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallScheduleEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallScheduleTimeRangeEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallScheduleTimeRangeEndpointRequestIDFromInteger(value int) *DeleteFirewallScheduleTimeRangeEndpointRequestID {
	return &DeleteFirewallScheduleTimeRangeEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallScheduleTimeRangeEndpointRequestIDFromString(value string) *DeleteFirewallScheduleTimeRangeEndpointRequestID {
	return &DeleteFirewallScheduleTimeRangeEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallScheduleTimeRangeEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallScheduleTimeRangeEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallScheduleTimeRangeEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallScheduleTimeRangeEndpointRequestID) Accept(visitor DeleteFirewallScheduleTimeRangeEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallScheduleTimeRangeEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallScheduleTimeRangeEndpointRequestParentIDFromInteger(value int) *DeleteFirewallScheduleTimeRangeEndpointRequestParentID {
	return &DeleteFirewallScheduleTimeRangeEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallScheduleTimeRangeEndpointRequestParentIDFromString(value string) *DeleteFirewallScheduleTimeRangeEndpointRequestParentID {
	return &DeleteFirewallScheduleTimeRangeEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteFirewallScheduleTimeRangeEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallScheduleTimeRangeEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallScheduleTimeRangeEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallScheduleTimeRangeEndpointRequestParentID) Accept(visitor DeleteFirewallScheduleTimeRangeEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallScheduleTimeRangeEndpointResponse struct {
	Data *DeleteFirewallScheduleTimeRangeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallScheduleTimeRangeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallScheduleTimeRangeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallScheduleTimeRangeEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallScheduleTimeRangeEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallScheduleTimeRangeEndpointResponseData struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	ParentID   *int    `json:"parent_id,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallScheduleTimeRangeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallScheduleTimeRangeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallScheduleTimeRangeEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallScheduleTimeRangeEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallScheduleTimeRangesEndpointResponse struct {
	Data []*DeleteFirewallScheduleTimeRangesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallScheduleTimeRangesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallScheduleTimeRangesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallScheduleTimeRangesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallScheduleTimeRangesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallScheduleTimeRangesEndpointResponseDataItem struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	ParentID   *int    `json:"parent_id,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallScheduleTimeRangesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallScheduleTimeRangesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallScheduleTimeRangesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallScheduleTimeRangesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallSchedulesEndpointResponse struct {
	Data []*DeleteFirewallSchedulesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallSchedulesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallSchedulesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallSchedulesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallSchedulesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallSchedulesEndpointResponseDataItem struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	ID        *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallSchedulesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallSchedulesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallSchedulesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallSchedulesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallStateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallStateEndpointRequestIDFromInteger(value int) *DeleteFirewallStateEndpointRequestID {
	return &DeleteFirewallStateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallStateEndpointRequestIDFromString(value string) *DeleteFirewallStateEndpointRequestID {
	return &DeleteFirewallStateEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallStateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallStateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallStateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallStateEndpointRequestID) Accept(visitor DeleteFirewallStateEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallStateEndpointResponse struct {
	Data *DeleteFirewallStateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallStateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallStateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallStateEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallStateEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallStateEndpointResponseData struct {
	// The interface that initially received the traffic which registered the state.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol listed in the state.<br>
	Protocol *string `json:"protocol,omitempty"`
	// The direction of traffic listed in the state.<br>
	Direction *string `json:"direction,omitempty"`
	// The source address listed in the state. Note: Depending on the `protocol`, this value may contain the source port as well.<br>
	Source *string `json:"source,omitempty"`
	// The destination address listed in the state. Note: Depending on the `protocol`, this value may contain the destination port as well.<br>
	Destination *string `json:"destination,omitempty"`
	// The current status of the firewall state.<br>
	State *string `json:"state,omitempty"`
	// The age of the firewall state in HH:MM:SS format.<br>
	Age *string `json:"age,omitempty"`
	// The amount of time remaining until the state expires in HH:MM:SS format.<br>
	ExpiresIn *string `json:"expires_in,omitempty"`
	// The total number of packets observed by the state.<br>
	PacketsTotal *int `json:"packets_total,omitempty"`
	// The total number of inbound packets observed by the state.<br>
	PacketsIn *int `json:"packets_in,omitempty"`
	// The total number of outbound packets observed by the state.<br>
	PacketsOut *int `json:"packets_out,omitempty"`
	// The total number of traffic (in bytes) observed by the state.<br>
	BytesTotal *int `json:"bytes_total,omitempty"`
	// The total number of inbound traffic (in bytes) observed by the state.<br>
	BytesIn *int `json:"bytes_in,omitempty"`
	// The total number of outbound traffic (in bytes) observed by the state.<br>
	BytesOut *int `json:"bytes_out,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallStateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallStateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallStateEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallStateEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallStatesEndpointResponse struct {
	Data []*DeleteFirewallStatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallStatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallStatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallStatesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallStatesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallStatesEndpointResponseDataItem struct {
	// The interface that initially received the traffic which registered the state.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol listed in the state.<br>
	Protocol *string `json:"protocol,omitempty"`
	// The direction of traffic listed in the state.<br>
	Direction *string `json:"direction,omitempty"`
	// The source address listed in the state. Note: Depending on the `protocol`, this value may contain the source port as well.<br>
	Source *string `json:"source,omitempty"`
	// The destination address listed in the state. Note: Depending on the `protocol`, this value may contain the destination port as well.<br>
	Destination *string `json:"destination,omitempty"`
	// The current status of the firewall state.<br>
	State *string `json:"state,omitempty"`
	// The age of the firewall state in HH:MM:SS format.<br>
	Age *string `json:"age,omitempty"`
	// The amount of time remaining until the state expires in HH:MM:SS format.<br>
	ExpiresIn *string `json:"expires_in,omitempty"`
	// The total number of packets observed by the state.<br>
	PacketsTotal *int `json:"packets_total,omitempty"`
	// The total number of inbound packets observed by the state.<br>
	PacketsIn *int `json:"packets_in,omitempty"`
	// The total number of outbound packets observed by the state.<br>
	PacketsOut *int `json:"packets_out,omitempty"`
	// The total number of traffic (in bytes) observed by the state.<br>
	BytesTotal *int `json:"bytes_total,omitempty"`
	// The total number of inbound traffic (in bytes) observed by the state.<br>
	BytesIn *int `json:"bytes_in,omitempty"`
	// The total number of outbound traffic (in bytes) observed by the state.<br>
	BytesOut *int `json:"bytes_out,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallStatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallStatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallStatesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallStatesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperEndpointRequestIDFromInteger(value int) *DeleteFirewallTrafficShaperEndpointRequestID {
	return &DeleteFirewallTrafficShaperEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperEndpointRequestIDFromString(value string) *DeleteFirewallTrafficShaperEndpointRequestID {
	return &DeleteFirewallTrafficShaperEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperEndpointRequestID) Accept(visitor DeleteFirewallTrafficShaperEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperEndpointResponse struct {
	Data *DeleteFirewallTrafficShaperEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperEndpointResponseData struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	ID    *int                      `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestIDFromInteger(value int) *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID {
	return &DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestIDFromString(value string) *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID {
	return &DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestID) Accept(visitor DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDFromInteger(value int) *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID {
	return &DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDFromString(value string) *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID {
	return &DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID) Accept(visitor DeleteFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponse struct {
	Data *DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponseData struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched  *string `json:"bwsched,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponse struct {
	Data []*DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched  *string `json:"bwsched,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperLimiterEndpointRequestIDFromInteger(value int) *DeleteFirewallTrafficShaperLimiterEndpointRequestID {
	return &DeleteFirewallTrafficShaperLimiterEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperLimiterEndpointRequestIDFromString(value string) *DeleteFirewallTrafficShaperLimiterEndpointRequestID {
	return &DeleteFirewallTrafficShaperLimiterEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperLimiterEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperLimiterEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperLimiterEndpointRequestID) Accept(visitor DeleteFirewallTrafficShaperLimiterEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterEndpointResponse struct {
	Data *DeleteFirewallTrafficShaperLimiterEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterEndpointResponseData struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
	ID    *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperLimiterQueueEndpointRequestIDFromInteger(value int) *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID {
	return &DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperLimiterQueueEndpointRequestIDFromString(value string) *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID {
	return &DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterQueueEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestID) Accept(visitor DeleteFirewallTrafficShaperLimiterQueueEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentIDFromInteger(value int) *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID {
	return &DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentIDFromString(value string) *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID {
	return &DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentID) Accept(visitor DeleteFirewallTrafficShaperLimiterQueueEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperLimiterQueueEndpointResponse struct {
	Data *DeleteFirewallTrafficShaperLimiterQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterQueueEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterQueueEndpointResponseData struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets  *int `json:"buckets,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterQueueEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterQueueEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterQueuesEndpointResponse struct {
	Data []*DeleteFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterQueuesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterQueuesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterQueuesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterQueuesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets  *int `json:"buckets,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperQueueEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperQueueEndpointRequestIDFromInteger(value int) *DeleteFirewallTrafficShaperQueueEndpointRequestID {
	return &DeleteFirewallTrafficShaperQueueEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperQueueEndpointRequestIDFromString(value string) *DeleteFirewallTrafficShaperQueueEndpointRequestID {
	return &DeleteFirewallTrafficShaperQueueEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperQueueEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperQueueEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperQueueEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperQueueEndpointRequestID) Accept(visitor DeleteFirewallTrafficShaperQueueEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperQueueEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallTrafficShaperQueueEndpointRequestParentIDFromInteger(value int) *DeleteFirewallTrafficShaperQueueEndpointRequestParentID {
	return &DeleteFirewallTrafficShaperQueueEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallTrafficShaperQueueEndpointRequestParentIDFromString(value string) *DeleteFirewallTrafficShaperQueueEndpointRequestParentID {
	return &DeleteFirewallTrafficShaperQueueEndpointRequestParentID{typeName: "string", String: value}
}

func (d *DeleteFirewallTrafficShaperQueueEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallTrafficShaperQueueEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallTrafficShaperQueueEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallTrafficShaperQueueEndpointRequestParentID) Accept(visitor DeleteFirewallTrafficShaperQueueEndpointRequestParentIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallTrafficShaperQueueEndpointResponse struct {
	Data *DeleteFirewallTrafficShaperQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperQueueEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperQueueEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperQueueEndpointResponseData struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperQueueEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperQueueEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperQueuesEndpointResponse struct {
	Data []*DeleteFirewallTrafficShaperQueuesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperQueuesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperQueuesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperQueuesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperQueuesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShaperQueuesEndpointResponseDataItem struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShaperQueuesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShaperQueuesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShaperQueuesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShaperQueuesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShapersEndpointResponse struct {
	Data []*DeleteFirewallTrafficShapersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShapersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShapersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShapersEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShapersEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallTrafficShapersEndpointResponseDataItem struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	ID    *int                      `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallTrafficShapersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallTrafficShapersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallTrafficShapersEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallTrafficShapersEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallVirtualIPsEndpointResponse struct {
	Data []*DeleteFirewallVirtualIPsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallVirtualIPsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallVirtualIPsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallVirtualIPsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallVirtualIPsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallVirtualIPsEndpointResponseDataItem struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallVirtualIPsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallVirtualIPsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallVirtualIPsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallVirtualIPsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallVirtualIPEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteFirewallVirtualIPEndpointRequestIDFromInteger(value int) *DeleteFirewallVirtualIPEndpointRequestID {
	return &DeleteFirewallVirtualIPEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteFirewallVirtualIPEndpointRequestIDFromString(value string) *DeleteFirewallVirtualIPEndpointRequestID {
	return &DeleteFirewallVirtualIPEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteFirewallVirtualIPEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteFirewallVirtualIPEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteFirewallVirtualIPEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteFirewallVirtualIPEndpointRequestID) Accept(visitor DeleteFirewallVirtualIPEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteFirewallVirtualIPEndpointResponse struct {
	Data *DeleteFirewallVirtualIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallVirtualIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallVirtualIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallVirtualIPEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallVirtualIPEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteFirewallVirtualIPEndpointResponseData struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteFirewallVirtualIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteFirewallVirtualIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteFirewallVirtualIPEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteFirewallVirtualIPEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetFirewallAdvancedSettingsEndpointResponse struct {
	Data *FirewallAdvancedSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallAdvancedSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallAdvancedSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallAdvancedSettingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallAdvancedSettingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallAliasEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallAliasEndpointRequestIDFromInteger(value int) *GetFirewallAliasEndpointRequestID {
	return &GetFirewallAliasEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallAliasEndpointRequestIDFromString(value string) *GetFirewallAliasEndpointRequestID {
	return &GetFirewallAliasEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallAliasEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallAliasEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallAliasEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallAliasEndpointRequestID) Accept(visitor GetFirewallAliasEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallAliasEndpointResponse struct {
	Data *GetFirewallAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallAliasEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallAliasEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallAliasEndpointResponseData struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	ID     *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallAliasEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallAliasEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallAliasesEndpointRequestSortFlags string

const (
	GetFirewallAliasesEndpointRequestSortFlagsSortRegular      GetFirewallAliasesEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallAliasesEndpointRequestSortFlagsSortNumeric      GetFirewallAliasesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallAliasesEndpointRequestSortFlagsSortString       GetFirewallAliasesEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallAliasesEndpointRequestSortFlagsSortLocaleString GetFirewallAliasesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallAliasesEndpointRequestSortFlagsSortNatural      GetFirewallAliasesEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallAliasesEndpointRequestSortFlagsSortFlagCase     GetFirewallAliasesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallAliasesEndpointRequestSortFlagsFromString(s string) (GetFirewallAliasesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallAliasesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallAliasesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallAliasesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallAliasesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallAliasesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallAliasesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallAliasesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallAliasesEndpointRequestSortFlags) Ptr() *GetFirewallAliasesEndpointRequestSortFlags {
	return &g
}

type GetFirewallAliasesEndpointRequestSortOrder string

const (
	GetFirewallAliasesEndpointRequestSortOrderSortAsc  GetFirewallAliasesEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallAliasesEndpointRequestSortOrderSortDesc GetFirewallAliasesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallAliasesEndpointRequestSortOrderFromString(s string) (GetFirewallAliasesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallAliasesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallAliasesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallAliasesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallAliasesEndpointRequestSortOrder) Ptr() *GetFirewallAliasesEndpointRequestSortOrder {
	return &g
}

type GetFirewallAliasesEndpointResponse struct {
	Data []*GetFirewallAliasesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallAliasesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallAliasesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallAliasesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallAliasesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallAliasesEndpointResponseDataItem struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	ID     *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallAliasesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallAliasesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallAliasesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallAliasesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallApplyEndpointResponse struct {
	Data *FirewallApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOneToOneMappingEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallNatOneToOneMappingEndpointRequestIDFromInteger(value int) *GetFirewallNatOneToOneMappingEndpointRequestID {
	return &GetFirewallNatOneToOneMappingEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallNatOneToOneMappingEndpointRequestIDFromString(value string) *GetFirewallNatOneToOneMappingEndpointRequestID {
	return &GetFirewallNatOneToOneMappingEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallNatOneToOneMappingEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallNatOneToOneMappingEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallNatOneToOneMappingEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallNatOneToOneMappingEndpointRequestID) Accept(visitor GetFirewallNatOneToOneMappingEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallNatOneToOneMappingEndpointResponse struct {
	Data *GetFirewallNatOneToOneMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOneToOneMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOneToOneMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOneToOneMappingEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOneToOneMappingEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOneToOneMappingEndpointResponseData struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOneToOneMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOneToOneMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOneToOneMappingEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOneToOneMappingEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOneToOneMappingsEndpointRequestSortFlags string

const (
	GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortRegular      GetFirewallNatOneToOneMappingsEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortNumeric      GetFirewallNatOneToOneMappingsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortString       GetFirewallNatOneToOneMappingsEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortLocaleString GetFirewallNatOneToOneMappingsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortNatural      GetFirewallNatOneToOneMappingsEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortFlagCase     GetFirewallNatOneToOneMappingsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallNatOneToOneMappingsEndpointRequestSortFlagsFromString(s string) (GetFirewallNatOneToOneMappingsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallNatOneToOneMappingsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallNatOneToOneMappingsEndpointRequestSortFlags) Ptr() *GetFirewallNatOneToOneMappingsEndpointRequestSortFlags {
	return &g
}

type GetFirewallNatOneToOneMappingsEndpointRequestSortOrder string

const (
	GetFirewallNatOneToOneMappingsEndpointRequestSortOrderSortAsc  GetFirewallNatOneToOneMappingsEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallNatOneToOneMappingsEndpointRequestSortOrderSortDesc GetFirewallNatOneToOneMappingsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallNatOneToOneMappingsEndpointRequestSortOrderFromString(s string) (GetFirewallNatOneToOneMappingsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallNatOneToOneMappingsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallNatOneToOneMappingsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallNatOneToOneMappingsEndpointRequestSortOrder) Ptr() *GetFirewallNatOneToOneMappingsEndpointRequestSortOrder {
	return &g
}

type GetFirewallNatOneToOneMappingsEndpointResponse struct {
	Data []*GetFirewallNatOneToOneMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOneToOneMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOneToOneMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOneToOneMappingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOneToOneMappingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOneToOneMappingsEndpointResponseDataItem struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOneToOneMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOneToOneMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOneToOneMappingsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOneToOneMappingsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOutboundMappingEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallNatOutboundMappingEndpointRequestIDFromInteger(value int) *GetFirewallNatOutboundMappingEndpointRequestID {
	return &GetFirewallNatOutboundMappingEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallNatOutboundMappingEndpointRequestIDFromString(value string) *GetFirewallNatOutboundMappingEndpointRequestID {
	return &GetFirewallNatOutboundMappingEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallNatOutboundMappingEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallNatOutboundMappingEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallNatOutboundMappingEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallNatOutboundMappingEndpointRequestID) Accept(visitor GetFirewallNatOutboundMappingEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallNatOutboundMappingEndpointResponse struct {
	Data *GetFirewallNatOutboundMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOutboundMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOutboundMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOutboundMappingEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOutboundMappingEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOutboundMappingEndpointResponseData struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOutboundMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOutboundMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOutboundMappingEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOutboundMappingEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOutboundMappingsEndpointRequestSortFlags string

const (
	GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortRegular      GetFirewallNatOutboundMappingsEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortNumeric      GetFirewallNatOutboundMappingsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortString       GetFirewallNatOutboundMappingsEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortLocaleString GetFirewallNatOutboundMappingsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortNatural      GetFirewallNatOutboundMappingsEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortFlagCase     GetFirewallNatOutboundMappingsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallNatOutboundMappingsEndpointRequestSortFlagsFromString(s string) (GetFirewallNatOutboundMappingsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallNatOutboundMappingsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallNatOutboundMappingsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallNatOutboundMappingsEndpointRequestSortFlags) Ptr() *GetFirewallNatOutboundMappingsEndpointRequestSortFlags {
	return &g
}

type GetFirewallNatOutboundMappingsEndpointRequestSortOrder string

const (
	GetFirewallNatOutboundMappingsEndpointRequestSortOrderSortAsc  GetFirewallNatOutboundMappingsEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallNatOutboundMappingsEndpointRequestSortOrderSortDesc GetFirewallNatOutboundMappingsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallNatOutboundMappingsEndpointRequestSortOrderFromString(s string) (GetFirewallNatOutboundMappingsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallNatOutboundMappingsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallNatOutboundMappingsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallNatOutboundMappingsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallNatOutboundMappingsEndpointRequestSortOrder) Ptr() *GetFirewallNatOutboundMappingsEndpointRequestSortOrder {
	return &g
}

type GetFirewallNatOutboundMappingsEndpointResponse struct {
	Data []*GetFirewallNatOutboundMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOutboundMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOutboundMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOutboundMappingsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOutboundMappingsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOutboundMappingsEndpointResponseDataItem struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOutboundMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOutboundMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOutboundMappingsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOutboundMappingsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatOutboundModeEndpointResponse struct {
	Data *OutboundNatMode `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatOutboundModeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatOutboundModeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatOutboundModeEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatOutboundModeEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatPortForwardEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallNatPortForwardEndpointRequestIDFromInteger(value int) *GetFirewallNatPortForwardEndpointRequestID {
	return &GetFirewallNatPortForwardEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallNatPortForwardEndpointRequestIDFromString(value string) *GetFirewallNatPortForwardEndpointRequestID {
	return &GetFirewallNatPortForwardEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallNatPortForwardEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallNatPortForwardEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallNatPortForwardEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallNatPortForwardEndpointRequestID) Accept(visitor GetFirewallNatPortForwardEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallNatPortForwardEndpointResponse struct {
	Data *GetFirewallNatPortForwardEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatPortForwardEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatPortForwardEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatPortForwardEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatPortForwardEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatPortForwardEndpointResponseData struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatPortForwardEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatPortForwardEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatPortForwardEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatPortForwardEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatPortForwardsEndpointRequestSortFlags string

const (
	GetFirewallNatPortForwardsEndpointRequestSortFlagsSortRegular      GetFirewallNatPortForwardsEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallNatPortForwardsEndpointRequestSortFlagsSortNumeric      GetFirewallNatPortForwardsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallNatPortForwardsEndpointRequestSortFlagsSortString       GetFirewallNatPortForwardsEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallNatPortForwardsEndpointRequestSortFlagsSortLocaleString GetFirewallNatPortForwardsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallNatPortForwardsEndpointRequestSortFlagsSortNatural      GetFirewallNatPortForwardsEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallNatPortForwardsEndpointRequestSortFlagsSortFlagCase     GetFirewallNatPortForwardsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallNatPortForwardsEndpointRequestSortFlagsFromString(s string) (GetFirewallNatPortForwardsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallNatPortForwardsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallNatPortForwardsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallNatPortForwardsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallNatPortForwardsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallNatPortForwardsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallNatPortForwardsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallNatPortForwardsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallNatPortForwardsEndpointRequestSortFlags) Ptr() *GetFirewallNatPortForwardsEndpointRequestSortFlags {
	return &g
}

type GetFirewallNatPortForwardsEndpointRequestSortOrder string

const (
	GetFirewallNatPortForwardsEndpointRequestSortOrderSortAsc  GetFirewallNatPortForwardsEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallNatPortForwardsEndpointRequestSortOrderSortDesc GetFirewallNatPortForwardsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallNatPortForwardsEndpointRequestSortOrderFromString(s string) (GetFirewallNatPortForwardsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallNatPortForwardsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallNatPortForwardsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallNatPortForwardsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallNatPortForwardsEndpointRequestSortOrder) Ptr() *GetFirewallNatPortForwardsEndpointRequestSortOrder {
	return &g
}

type GetFirewallNatPortForwardsEndpointResponse struct {
	Data []*GetFirewallNatPortForwardsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatPortForwardsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatPortForwardsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatPortForwardsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatPortForwardsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallNatPortForwardsEndpointResponseDataItem struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallNatPortForwardsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallNatPortForwardsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallNatPortForwardsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallNatPortForwardsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallRuleEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallRuleEndpointRequestIDFromInteger(value int) *GetFirewallRuleEndpointRequestID {
	return &GetFirewallRuleEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallRuleEndpointRequestIDFromString(value string) *GetFirewallRuleEndpointRequestID {
	return &GetFirewallRuleEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallRuleEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallRuleEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallRuleEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallRuleEndpointRequestID) Accept(visitor GetFirewallRuleEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallRuleEndpointResponse struct {
	Data *GetFirewallRuleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallRuleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallRuleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallRuleEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallRuleEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallRuleEndpointResponseData struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallRuleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallRuleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallRuleEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallRuleEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallRulesEndpointRequestSortFlags string

const (
	GetFirewallRulesEndpointRequestSortFlagsSortRegular      GetFirewallRulesEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallRulesEndpointRequestSortFlagsSortNumeric      GetFirewallRulesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallRulesEndpointRequestSortFlagsSortString       GetFirewallRulesEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallRulesEndpointRequestSortFlagsSortLocaleString GetFirewallRulesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallRulesEndpointRequestSortFlagsSortNatural      GetFirewallRulesEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallRulesEndpointRequestSortFlagsSortFlagCase     GetFirewallRulesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallRulesEndpointRequestSortFlagsFromString(s string) (GetFirewallRulesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallRulesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallRulesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallRulesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallRulesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallRulesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallRulesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallRulesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallRulesEndpointRequestSortFlags) Ptr() *GetFirewallRulesEndpointRequestSortFlags {
	return &g
}

type GetFirewallRulesEndpointRequestSortOrder string

const (
	GetFirewallRulesEndpointRequestSortOrderSortAsc  GetFirewallRulesEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallRulesEndpointRequestSortOrderSortDesc GetFirewallRulesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallRulesEndpointRequestSortOrderFromString(s string) (GetFirewallRulesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallRulesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallRulesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallRulesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallRulesEndpointRequestSortOrder) Ptr() *GetFirewallRulesEndpointRequestSortOrder {
	return &g
}

type GetFirewallRulesEndpointResponse struct {
	Data []*GetFirewallRulesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallRulesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallRulesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallRulesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallRulesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallRulesEndpointResponseDataItem struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallRulesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallRulesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallRulesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallRulesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallScheduleEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallScheduleEndpointRequestIDFromInteger(value int) *GetFirewallScheduleEndpointRequestID {
	return &GetFirewallScheduleEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallScheduleEndpointRequestIDFromString(value string) *GetFirewallScheduleEndpointRequestID {
	return &GetFirewallScheduleEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallScheduleEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallScheduleEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallScheduleEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallScheduleEndpointRequestID) Accept(visitor GetFirewallScheduleEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallScheduleEndpointResponse struct {
	Data *GetFirewallScheduleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallScheduleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallScheduleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallScheduleEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallScheduleEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallScheduleEndpointResponseData struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	ID        *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallScheduleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallScheduleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallScheduleEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallScheduleEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallScheduleTimeRangeEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallScheduleTimeRangeEndpointRequestIDFromInteger(value int) *GetFirewallScheduleTimeRangeEndpointRequestID {
	return &GetFirewallScheduleTimeRangeEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallScheduleTimeRangeEndpointRequestIDFromString(value string) *GetFirewallScheduleTimeRangeEndpointRequestID {
	return &GetFirewallScheduleTimeRangeEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallScheduleTimeRangeEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallScheduleTimeRangeEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallScheduleTimeRangeEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallScheduleTimeRangeEndpointRequestID) Accept(visitor GetFirewallScheduleTimeRangeEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallScheduleTimeRangeEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallScheduleTimeRangeEndpointRequestParentIDFromInteger(value int) *GetFirewallScheduleTimeRangeEndpointRequestParentID {
	return &GetFirewallScheduleTimeRangeEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetFirewallScheduleTimeRangeEndpointRequestParentIDFromString(value string) *GetFirewallScheduleTimeRangeEndpointRequestParentID {
	return &GetFirewallScheduleTimeRangeEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetFirewallScheduleTimeRangeEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallScheduleTimeRangeEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallScheduleTimeRangeEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallScheduleTimeRangeEndpointRequestParentID) Accept(visitor GetFirewallScheduleTimeRangeEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallScheduleTimeRangeEndpointResponse struct {
	Data *GetFirewallScheduleTimeRangeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallScheduleTimeRangeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallScheduleTimeRangeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallScheduleTimeRangeEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallScheduleTimeRangeEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallScheduleTimeRangeEndpointResponseData struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	ParentID   *int    `json:"parent_id,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallScheduleTimeRangeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallScheduleTimeRangeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallScheduleTimeRangeEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallScheduleTimeRangeEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallScheduleTimeRangesEndpointRequestSortFlags string

const (
	GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortRegular      GetFirewallScheduleTimeRangesEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortNumeric      GetFirewallScheduleTimeRangesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortString       GetFirewallScheduleTimeRangesEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortLocaleString GetFirewallScheduleTimeRangesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortNatural      GetFirewallScheduleTimeRangesEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortFlagCase     GetFirewallScheduleTimeRangesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallScheduleTimeRangesEndpointRequestSortFlagsFromString(s string) (GetFirewallScheduleTimeRangesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallScheduleTimeRangesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallScheduleTimeRangesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallScheduleTimeRangesEndpointRequestSortFlags) Ptr() *GetFirewallScheduleTimeRangesEndpointRequestSortFlags {
	return &g
}

type GetFirewallScheduleTimeRangesEndpointRequestSortOrder string

const (
	GetFirewallScheduleTimeRangesEndpointRequestSortOrderSortAsc  GetFirewallScheduleTimeRangesEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallScheduleTimeRangesEndpointRequestSortOrderSortDesc GetFirewallScheduleTimeRangesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallScheduleTimeRangesEndpointRequestSortOrderFromString(s string) (GetFirewallScheduleTimeRangesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallScheduleTimeRangesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallScheduleTimeRangesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallScheduleTimeRangesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallScheduleTimeRangesEndpointRequestSortOrder) Ptr() *GetFirewallScheduleTimeRangesEndpointRequestSortOrder {
	return &g
}

type GetFirewallScheduleTimeRangesEndpointResponse struct {
	Data []*GetFirewallScheduleTimeRangesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallScheduleTimeRangesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallScheduleTimeRangesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallScheduleTimeRangesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallScheduleTimeRangesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallScheduleTimeRangesEndpointResponseDataItem struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	ParentID   *int    `json:"parent_id,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallScheduleTimeRangesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallScheduleTimeRangesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallScheduleTimeRangesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallScheduleTimeRangesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallSchedulesEndpointRequestSortFlags string

const (
	GetFirewallSchedulesEndpointRequestSortFlagsSortRegular      GetFirewallSchedulesEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallSchedulesEndpointRequestSortFlagsSortNumeric      GetFirewallSchedulesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallSchedulesEndpointRequestSortFlagsSortString       GetFirewallSchedulesEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallSchedulesEndpointRequestSortFlagsSortLocaleString GetFirewallSchedulesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallSchedulesEndpointRequestSortFlagsSortNatural      GetFirewallSchedulesEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallSchedulesEndpointRequestSortFlagsSortFlagCase     GetFirewallSchedulesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallSchedulesEndpointRequestSortFlagsFromString(s string) (GetFirewallSchedulesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallSchedulesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallSchedulesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallSchedulesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallSchedulesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallSchedulesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallSchedulesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallSchedulesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallSchedulesEndpointRequestSortFlags) Ptr() *GetFirewallSchedulesEndpointRequestSortFlags {
	return &g
}

type GetFirewallSchedulesEndpointRequestSortOrder string

const (
	GetFirewallSchedulesEndpointRequestSortOrderSortAsc  GetFirewallSchedulesEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallSchedulesEndpointRequestSortOrderSortDesc GetFirewallSchedulesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallSchedulesEndpointRequestSortOrderFromString(s string) (GetFirewallSchedulesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallSchedulesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallSchedulesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallSchedulesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallSchedulesEndpointRequestSortOrder) Ptr() *GetFirewallSchedulesEndpointRequestSortOrder {
	return &g
}

type GetFirewallSchedulesEndpointResponse struct {
	Data []*GetFirewallSchedulesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallSchedulesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallSchedulesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallSchedulesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallSchedulesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallSchedulesEndpointResponseDataItem struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	ID        *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallSchedulesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallSchedulesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallSchedulesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallSchedulesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallStateEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallStateEndpointRequestIDFromInteger(value int) *GetFirewallStateEndpointRequestID {
	return &GetFirewallStateEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallStateEndpointRequestIDFromString(value string) *GetFirewallStateEndpointRequestID {
	return &GetFirewallStateEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallStateEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallStateEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallStateEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallStateEndpointRequestID) Accept(visitor GetFirewallStateEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallStateEndpointResponse struct {
	Data *GetFirewallStateEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallStateEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallStateEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallStateEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallStateEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallStateEndpointResponseData struct {
	// The interface that initially received the traffic which registered the state.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol listed in the state.<br>
	Protocol *string `json:"protocol,omitempty"`
	// The direction of traffic listed in the state.<br>
	Direction *string `json:"direction,omitempty"`
	// The source address listed in the state. Note: Depending on the `protocol`, this value may contain the source port as well.<br>
	Source *string `json:"source,omitempty"`
	// The destination address listed in the state. Note: Depending on the `protocol`, this value may contain the destination port as well.<br>
	Destination *string `json:"destination,omitempty"`
	// The current status of the firewall state.<br>
	State *string `json:"state,omitempty"`
	// The age of the firewall state in HH:MM:SS format.<br>
	Age *string `json:"age,omitempty"`
	// The amount of time remaining until the state expires in HH:MM:SS format.<br>
	ExpiresIn *string `json:"expires_in,omitempty"`
	// The total number of packets observed by the state.<br>
	PacketsTotal *int `json:"packets_total,omitempty"`
	// The total number of inbound packets observed by the state.<br>
	PacketsIn *int `json:"packets_in,omitempty"`
	// The total number of outbound packets observed by the state.<br>
	PacketsOut *int `json:"packets_out,omitempty"`
	// The total number of traffic (in bytes) observed by the state.<br>
	BytesTotal *int `json:"bytes_total,omitempty"`
	// The total number of inbound traffic (in bytes) observed by the state.<br>
	BytesIn *int `json:"bytes_in,omitempty"`
	// The total number of outbound traffic (in bytes) observed by the state.<br>
	BytesOut *int `json:"bytes_out,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallStateEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallStateEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallStateEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallStateEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallStatesEndpointRequestSortFlags string

const (
	GetFirewallStatesEndpointRequestSortFlagsSortRegular      GetFirewallStatesEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallStatesEndpointRequestSortFlagsSortNumeric      GetFirewallStatesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallStatesEndpointRequestSortFlagsSortString       GetFirewallStatesEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallStatesEndpointRequestSortFlagsSortLocaleString GetFirewallStatesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallStatesEndpointRequestSortFlagsSortNatural      GetFirewallStatesEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallStatesEndpointRequestSortFlagsSortFlagCase     GetFirewallStatesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallStatesEndpointRequestSortFlagsFromString(s string) (GetFirewallStatesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallStatesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallStatesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallStatesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallStatesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallStatesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallStatesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallStatesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallStatesEndpointRequestSortFlags) Ptr() *GetFirewallStatesEndpointRequestSortFlags {
	return &g
}

type GetFirewallStatesEndpointRequestSortOrder string

const (
	GetFirewallStatesEndpointRequestSortOrderSortAsc  GetFirewallStatesEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallStatesEndpointRequestSortOrderSortDesc GetFirewallStatesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallStatesEndpointRequestSortOrderFromString(s string) (GetFirewallStatesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallStatesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallStatesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallStatesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallStatesEndpointRequestSortOrder) Ptr() *GetFirewallStatesEndpointRequestSortOrder {
	return &g
}

type GetFirewallStatesEndpointResponse struct {
	Data []*GetFirewallStatesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallStatesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallStatesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallStatesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallStatesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallStatesEndpointResponseDataItem struct {
	// The interface that initially received the traffic which registered the state.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol listed in the state.<br>
	Protocol *string `json:"protocol,omitempty"`
	// The direction of traffic listed in the state.<br>
	Direction *string `json:"direction,omitempty"`
	// The source address listed in the state. Note: Depending on the `protocol`, this value may contain the source port as well.<br>
	Source *string `json:"source,omitempty"`
	// The destination address listed in the state. Note: Depending on the `protocol`, this value may contain the destination port as well.<br>
	Destination *string `json:"destination,omitempty"`
	// The current status of the firewall state.<br>
	State *string `json:"state,omitempty"`
	// The age of the firewall state in HH:MM:SS format.<br>
	Age *string `json:"age,omitempty"`
	// The amount of time remaining until the state expires in HH:MM:SS format.<br>
	ExpiresIn *string `json:"expires_in,omitempty"`
	// The total number of packets observed by the state.<br>
	PacketsTotal *int `json:"packets_total,omitempty"`
	// The total number of inbound packets observed by the state.<br>
	PacketsIn *int `json:"packets_in,omitempty"`
	// The total number of outbound packets observed by the state.<br>
	PacketsOut *int `json:"packets_out,omitempty"`
	// The total number of traffic (in bytes) observed by the state.<br>
	BytesTotal *int `json:"bytes_total,omitempty"`
	// The total number of inbound traffic (in bytes) observed by the state.<br>
	BytesIn *int `json:"bytes_in,omitempty"`
	// The total number of outbound traffic (in bytes) observed by the state.<br>
	BytesOut *int `json:"bytes_out,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallStatesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallStatesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallStatesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallStatesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallStatesSizeEndpointResponse struct {
	Data *FirewallStatesSize `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallStatesSizeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallStatesSizeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallStatesSizeEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallStatesSizeEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperEndpointRequestIDFromInteger(value int) *GetFirewallTrafficShaperEndpointRequestID {
	return &GetFirewallTrafficShaperEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperEndpointRequestIDFromString(value string) *GetFirewallTrafficShaperEndpointRequestID {
	return &GetFirewallTrafficShaperEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperEndpointRequestID) Accept(visitor GetFirewallTrafficShaperEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperEndpointResponse struct {
	Data *GetFirewallTrafficShaperEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperEndpointResponseData struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	ID    *int                      `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperLimiterBandwidthEndpointRequestIDFromInteger(value int) *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID {
	return &GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperLimiterBandwidthEndpointRequestIDFromString(value string) *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID {
	return &GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperLimiterBandwidthEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestID) Accept(visitor GetFirewallTrafficShaperLimiterBandwidthEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDFromInteger(value int) *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID {
	return &GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDFromString(value string) *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID {
	return &GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentID) Accept(visitor GetFirewallTrafficShaperLimiterBandwidthEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperLimiterBandwidthEndpointResponse struct {
	Data *GetFirewallTrafficShaperLimiterBandwidthEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterBandwidthEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterBandwidthEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterBandwidthEndpointResponseData struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched  *string `json:"bwsched,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterBandwidthEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterBandwidthEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterBandwidthEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags string

const (
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortRegular      GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortNumeric      GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortString       GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortLocaleString GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortNatural      GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortFlagCase     GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsFromString(s string) (GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags) Ptr() *GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortFlags {
	return &g
}

type GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder string

const (
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrderSortAsc  GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrderSortDesc GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrderFromString(s string) (GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder) Ptr() *GetFirewallTrafficShaperLimiterBandwidthsEndpointRequestSortOrder {
	return &g
}

type GetFirewallTrafficShaperLimiterBandwidthsEndpointResponse struct {
	Data []*GetFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterBandwidthsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterBandwidthsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterBandwidthsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterBandwidthsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched  *string `json:"bwsched,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterBandwidthsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperLimiterEndpointRequestIDFromInteger(value int) *GetFirewallTrafficShaperLimiterEndpointRequestID {
	return &GetFirewallTrafficShaperLimiterEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperLimiterEndpointRequestIDFromString(value string) *GetFirewallTrafficShaperLimiterEndpointRequestID {
	return &GetFirewallTrafficShaperLimiterEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperLimiterEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperLimiterEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperLimiterEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperLimiterEndpointRequestID) Accept(visitor GetFirewallTrafficShaperLimiterEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperLimiterEndpointResponse struct {
	Data *GetFirewallTrafficShaperLimiterEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterEndpointResponseData struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
	ID    *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterQueueEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperLimiterQueueEndpointRequestIDFromInteger(value int) *GetFirewallTrafficShaperLimiterQueueEndpointRequestID {
	return &GetFirewallTrafficShaperLimiterQueueEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperLimiterQueueEndpointRequestIDFromString(value string) *GetFirewallTrafficShaperLimiterQueueEndpointRequestID {
	return &GetFirewallTrafficShaperLimiterQueueEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperLimiterQueueEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperLimiterQueueEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointRequestID) Accept(visitor GetFirewallTrafficShaperLimiterQueueEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperLimiterQueueEndpointRequestParentIDFromInteger(value int) *GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID {
	return &GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperLimiterQueueEndpointRequestParentIDFromString(value string) *GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID {
	return &GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperLimiterQueueEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointRequestParentID) Accept(visitor GetFirewallTrafficShaperLimiterQueueEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperLimiterQueueEndpointResponse struct {
	Data *GetFirewallTrafficShaperLimiterQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterQueueEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterQueueEndpointResponseData struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets  *int `json:"buckets,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterQueueEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterQueueEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags string

const (
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortRegular      GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortNumeric      GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortString       GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortLocaleString GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortNatural      GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortFlagCase     GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsFromString(s string) (GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags) Ptr() *GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortFlags {
	return &g
}

type GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder string

const (
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrderSortAsc  GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrderSortDesc GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrderFromString(s string) (GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder) Ptr() *GetFirewallTrafficShaperLimiterQueuesEndpointRequestSortOrder {
	return &g
}

type GetFirewallTrafficShaperLimiterQueuesEndpointResponse struct {
	Data []*GetFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterQueuesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterQueuesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterQueuesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterQueuesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets  *int `json:"buckets,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimiterQueuesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimitersEndpointRequestSortFlags string

const (
	GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortRegular      GetFirewallTrafficShaperLimitersEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortNumeric      GetFirewallTrafficShaperLimitersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortString       GetFirewallTrafficShaperLimitersEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortLocaleString GetFirewallTrafficShaperLimitersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortNatural      GetFirewallTrafficShaperLimitersEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortFlagCase     GetFirewallTrafficShaperLimitersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallTrafficShaperLimitersEndpointRequestSortFlagsFromString(s string) (GetFirewallTrafficShaperLimitersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallTrafficShaperLimitersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperLimitersEndpointRequestSortFlags) Ptr() *GetFirewallTrafficShaperLimitersEndpointRequestSortFlags {
	return &g
}

type GetFirewallTrafficShaperLimitersEndpointRequestSortOrder string

const (
	GetFirewallTrafficShaperLimitersEndpointRequestSortOrderSortAsc  GetFirewallTrafficShaperLimitersEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallTrafficShaperLimitersEndpointRequestSortOrderSortDesc GetFirewallTrafficShaperLimitersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallTrafficShaperLimitersEndpointRequestSortOrderFromString(s string) (GetFirewallTrafficShaperLimitersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallTrafficShaperLimitersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallTrafficShaperLimitersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperLimitersEndpointRequestSortOrder) Ptr() *GetFirewallTrafficShaperLimitersEndpointRequestSortOrder {
	return &g
}

type GetFirewallTrafficShaperLimitersEndpointResponse struct {
	Data []*GetFirewallTrafficShaperLimitersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimitersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimitersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimitersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimitersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperLimitersEndpointResponseDataItem struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
	ID    *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperLimitersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperLimitersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperLimitersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperLimitersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperQueueEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperQueueEndpointRequestIDFromInteger(value int) *GetFirewallTrafficShaperQueueEndpointRequestID {
	return &GetFirewallTrafficShaperQueueEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperQueueEndpointRequestIDFromString(value string) *GetFirewallTrafficShaperQueueEndpointRequestID {
	return &GetFirewallTrafficShaperQueueEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperQueueEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperQueueEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperQueueEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperQueueEndpointRequestID) Accept(visitor GetFirewallTrafficShaperQueueEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperQueueEndpointRequestParentID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallTrafficShaperQueueEndpointRequestParentIDFromInteger(value int) *GetFirewallTrafficShaperQueueEndpointRequestParentID {
	return &GetFirewallTrafficShaperQueueEndpointRequestParentID{typeName: "integer", Integer: value}
}

func NewGetFirewallTrafficShaperQueueEndpointRequestParentIDFromString(value string) *GetFirewallTrafficShaperQueueEndpointRequestParentID {
	return &GetFirewallTrafficShaperQueueEndpointRequestParentID{typeName: "string", String: value}
}

func (g *GetFirewallTrafficShaperQueueEndpointRequestParentID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallTrafficShaperQueueEndpointRequestParentID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallTrafficShaperQueueEndpointRequestParentIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallTrafficShaperQueueEndpointRequestParentID) Accept(visitor GetFirewallTrafficShaperQueueEndpointRequestParentIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallTrafficShaperQueueEndpointResponse struct {
	Data *GetFirewallTrafficShaperQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperQueueEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperQueueEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperQueueEndpointResponseData struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperQueueEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperQueueEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperQueuesEndpointRequestSortFlags string

const (
	GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortRegular      GetFirewallTrafficShaperQueuesEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortNumeric      GetFirewallTrafficShaperQueuesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortString       GetFirewallTrafficShaperQueuesEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortLocaleString GetFirewallTrafficShaperQueuesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortNatural      GetFirewallTrafficShaperQueuesEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortFlagCase     GetFirewallTrafficShaperQueuesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallTrafficShaperQueuesEndpointRequestSortFlagsFromString(s string) (GetFirewallTrafficShaperQueuesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallTrafficShaperQueuesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperQueuesEndpointRequestSortFlags) Ptr() *GetFirewallTrafficShaperQueuesEndpointRequestSortFlags {
	return &g
}

type GetFirewallTrafficShaperQueuesEndpointRequestSortOrder string

const (
	GetFirewallTrafficShaperQueuesEndpointRequestSortOrderSortAsc  GetFirewallTrafficShaperQueuesEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallTrafficShaperQueuesEndpointRequestSortOrderSortDesc GetFirewallTrafficShaperQueuesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallTrafficShaperQueuesEndpointRequestSortOrderFromString(s string) (GetFirewallTrafficShaperQueuesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallTrafficShaperQueuesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallTrafficShaperQueuesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShaperQueuesEndpointRequestSortOrder) Ptr() *GetFirewallTrafficShaperQueuesEndpointRequestSortOrder {
	return &g
}

type GetFirewallTrafficShaperQueuesEndpointResponse struct {
	Data []*GetFirewallTrafficShaperQueuesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperQueuesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperQueuesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperQueuesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperQueuesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShaperQueuesEndpointResponseDataItem struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShaperQueuesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShaperQueuesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShaperQueuesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShaperQueuesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShapersEndpointRequestSortFlags string

const (
	GetFirewallTrafficShapersEndpointRequestSortFlagsSortRegular      GetFirewallTrafficShapersEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallTrafficShapersEndpointRequestSortFlagsSortNumeric      GetFirewallTrafficShapersEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallTrafficShapersEndpointRequestSortFlagsSortString       GetFirewallTrafficShapersEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallTrafficShapersEndpointRequestSortFlagsSortLocaleString GetFirewallTrafficShapersEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallTrafficShapersEndpointRequestSortFlagsSortNatural      GetFirewallTrafficShapersEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallTrafficShapersEndpointRequestSortFlagsSortFlagCase     GetFirewallTrafficShapersEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallTrafficShapersEndpointRequestSortFlagsFromString(s string) (GetFirewallTrafficShapersEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallTrafficShapersEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallTrafficShapersEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallTrafficShapersEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallTrafficShapersEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallTrafficShapersEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallTrafficShapersEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallTrafficShapersEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShapersEndpointRequestSortFlags) Ptr() *GetFirewallTrafficShapersEndpointRequestSortFlags {
	return &g
}

type GetFirewallTrafficShapersEndpointRequestSortOrder string

const (
	GetFirewallTrafficShapersEndpointRequestSortOrderSortAsc  GetFirewallTrafficShapersEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallTrafficShapersEndpointRequestSortOrderSortDesc GetFirewallTrafficShapersEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallTrafficShapersEndpointRequestSortOrderFromString(s string) (GetFirewallTrafficShapersEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallTrafficShapersEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallTrafficShapersEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallTrafficShapersEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallTrafficShapersEndpointRequestSortOrder) Ptr() *GetFirewallTrafficShapersEndpointRequestSortOrder {
	return &g
}

type GetFirewallTrafficShapersEndpointResponse struct {
	Data []*GetFirewallTrafficShapersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShapersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShapersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShapersEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShapersEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallTrafficShapersEndpointResponseDataItem struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	ID    *int                      `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallTrafficShapersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallTrafficShapersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallTrafficShapersEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallTrafficShapersEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallVirtualIPsEndpointRequestSortFlags string

const (
	GetFirewallVirtualIPsEndpointRequestSortFlagsSortRegular      GetFirewallVirtualIPsEndpointRequestSortFlags = "SORT_REGULAR"
	GetFirewallVirtualIPsEndpointRequestSortFlagsSortNumeric      GetFirewallVirtualIPsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetFirewallVirtualIPsEndpointRequestSortFlagsSortString       GetFirewallVirtualIPsEndpointRequestSortFlags = "SORT_STRING"
	GetFirewallVirtualIPsEndpointRequestSortFlagsSortLocaleString GetFirewallVirtualIPsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetFirewallVirtualIPsEndpointRequestSortFlagsSortNatural      GetFirewallVirtualIPsEndpointRequestSortFlags = "SORT_NATURAL"
	GetFirewallVirtualIPsEndpointRequestSortFlagsSortFlagCase     GetFirewallVirtualIPsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetFirewallVirtualIPsEndpointRequestSortFlagsFromString(s string) (GetFirewallVirtualIPsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetFirewallVirtualIPsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetFirewallVirtualIPsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetFirewallVirtualIPsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetFirewallVirtualIPsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetFirewallVirtualIPsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetFirewallVirtualIPsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetFirewallVirtualIPsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallVirtualIPsEndpointRequestSortFlags) Ptr() *GetFirewallVirtualIPsEndpointRequestSortFlags {
	return &g
}

type GetFirewallVirtualIPsEndpointRequestSortOrder string

const (
	GetFirewallVirtualIPsEndpointRequestSortOrderSortAsc  GetFirewallVirtualIPsEndpointRequestSortOrder = "SORT_ASC"
	GetFirewallVirtualIPsEndpointRequestSortOrderSortDesc GetFirewallVirtualIPsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetFirewallVirtualIPsEndpointRequestSortOrderFromString(s string) (GetFirewallVirtualIPsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetFirewallVirtualIPsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetFirewallVirtualIPsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetFirewallVirtualIPsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetFirewallVirtualIPsEndpointRequestSortOrder) Ptr() *GetFirewallVirtualIPsEndpointRequestSortOrder {
	return &g
}

type GetFirewallVirtualIPsEndpointResponse struct {
	Data []*GetFirewallVirtualIPsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallVirtualIPsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallVirtualIPsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallVirtualIPsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallVirtualIPsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallVirtualIPsEndpointResponseDataItem struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallVirtualIPsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallVirtualIPsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallVirtualIPsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallVirtualIPsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallVirtualIPApplyEndpointResponse struct {
	Data *VirtualIPApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallVirtualIPApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallVirtualIPApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallVirtualIPApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallVirtualIPApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallVirtualIPEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetFirewallVirtualIPEndpointRequestIDFromInteger(value int) *GetFirewallVirtualIPEndpointRequestID {
	return &GetFirewallVirtualIPEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetFirewallVirtualIPEndpointRequestIDFromString(value string) *GetFirewallVirtualIPEndpointRequestID {
	return &GetFirewallVirtualIPEndpointRequestID{typeName: "string", String: value}
}

func (g *GetFirewallVirtualIPEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetFirewallVirtualIPEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetFirewallVirtualIPEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetFirewallVirtualIPEndpointRequestID) Accept(visitor GetFirewallVirtualIPEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetFirewallVirtualIPEndpointResponse struct {
	Data *GetFirewallVirtualIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallVirtualIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallVirtualIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallVirtualIPEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallVirtualIPEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetFirewallVirtualIPEndpointResponseData struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetFirewallVirtualIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetFirewallVirtualIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetFirewallVirtualIPEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetFirewallVirtualIPEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PatchFirewallAdvancedSettingsEndpointResponse struct {
	Data *FirewallAdvancedSettings `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallAdvancedSettingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallAdvancedSettingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallAdvancedSettingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallAdvancedSettingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallAliasEndpointResponse struct {
	Data *PatchFirewallAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallAliasEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallAliasEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallAliasEndpointResponseData struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	ID     *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallAliasEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallAliasEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallNatOneToOneMappingEndpointResponse struct {
	Data *PatchFirewallNatOneToOneMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallNatOneToOneMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallNatOneToOneMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallNatOneToOneMappingEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallNatOneToOneMappingEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallNatOneToOneMappingEndpointResponseData struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallNatOneToOneMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallNatOneToOneMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallNatOneToOneMappingEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallNatOneToOneMappingEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallNatOutboundMappingEndpointResponse struct {
	Data *PatchFirewallNatOutboundMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallNatOutboundMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallNatOutboundMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallNatOutboundMappingEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallNatOutboundMappingEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallNatOutboundMappingEndpointResponseData struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallNatOutboundMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallNatOutboundMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallNatOutboundMappingEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallNatOutboundMappingEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallNatOutboundModeEndpointResponse struct {
	Data *OutboundNatMode `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallNatOutboundModeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallNatOutboundModeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallNatOutboundModeEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallNatOutboundModeEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallNatPortForwardEndpointResponse struct {
	Data *PatchFirewallNatPortForwardEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallNatPortForwardEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallNatPortForwardEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallNatPortForwardEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallNatPortForwardEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallNatPortForwardEndpointResponseData struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallNatPortForwardEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallNatPortForwardEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallNatPortForwardEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallNatPortForwardEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallRuleEndpointResponse struct {
	Data *PatchFirewallRuleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallRuleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallRuleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallRuleEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallRuleEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallRuleEndpointResponseData struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallRuleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallRuleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallRuleEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallRuleEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallScheduleEndpointResponse struct {
	Data *PatchFirewallScheduleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallScheduleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallScheduleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallScheduleEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallScheduleEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallScheduleEndpointResponseData struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	ID        *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallScheduleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallScheduleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallScheduleEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallScheduleEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallScheduleTimeRangeEndpointResponse struct {
	Data *PatchFirewallScheduleTimeRangeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallScheduleTimeRangeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallScheduleTimeRangeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallScheduleTimeRangeEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallScheduleTimeRangeEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallScheduleTimeRangeEndpointResponseData struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	ParentID   *int    `json:"parent_id,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallScheduleTimeRangeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallScheduleTimeRangeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallScheduleTimeRangeEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallScheduleTimeRangeEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallStatesSizeEndpointResponse struct {
	Data *FirewallStatesSize `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallStatesSizeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallStatesSizeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallStatesSizeEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallStatesSizeEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperEndpointResponse struct {
	Data *PatchFirewallTrafficShaperEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperEndpointResponseData struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	ID    *int                      `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperLimiterBandwidthEndpointResponse struct {
	Data *PatchFirewallTrafficShaperLimiterBandwidthEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperLimiterBandwidthEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperLimiterBandwidthEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperLimiterBandwidthEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperLimiterBandwidthEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperLimiterBandwidthEndpointResponseData struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched  *string `json:"bwsched,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperLimiterBandwidthEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperLimiterBandwidthEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperLimiterBandwidthEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperLimiterBandwidthEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperLimiterEndpointResponse struct {
	Data *PatchFirewallTrafficShaperLimiterEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperLimiterEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperLimiterEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperLimiterEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperLimiterEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperLimiterEndpointResponseData struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
	ID    *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperLimiterEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperLimiterEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperLimiterEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperLimiterEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperLimiterQueueEndpointResponse struct {
	Data *PatchFirewallTrafficShaperLimiterQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperLimiterQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperLimiterQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperLimiterQueueEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperLimiterQueueEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperLimiterQueueEndpointResponseData struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets  *int `json:"buckets,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperLimiterQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperLimiterQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperLimiterQueueEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperLimiterQueueEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperQueueEndpointResponse struct {
	Data *PatchFirewallTrafficShaperQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperQueueEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperQueueEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallTrafficShaperQueueEndpointResponseData struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallTrafficShaperQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallTrafficShaperQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallTrafficShaperQueueEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallTrafficShaperQueueEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallVirtualIPEndpointResponse struct {
	Data *PatchFirewallVirtualIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallVirtualIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallVirtualIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallVirtualIPEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallVirtualIPEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchFirewallVirtualIPEndpointResponseData struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchFirewallVirtualIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchFirewallVirtualIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchFirewallVirtualIPEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchFirewallVirtualIPEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallAliasEndpointResponse struct {
	Data *PostFirewallAliasEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallAliasEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallAliasEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallAliasEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallAliasEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallAliasEndpointResponseData struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	ID     *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallAliasEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallAliasEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallAliasEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallAliasEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallApplyEndpointResponse struct {
	Data *FirewallApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallNatOneToOneMappingEndpointResponse struct {
	Data *PostFirewallNatOneToOneMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallNatOneToOneMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallNatOneToOneMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallNatOneToOneMappingEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallNatOneToOneMappingEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallNatOneToOneMappingEndpointResponseData struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallNatOneToOneMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallNatOneToOneMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallNatOneToOneMappingEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallNatOneToOneMappingEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallNatOutboundMappingEndpointResponse struct {
	Data *PostFirewallNatOutboundMappingEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallNatOutboundMappingEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallNatOutboundMappingEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallNatOutboundMappingEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallNatOutboundMappingEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallNatOutboundMappingEndpointResponseData struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallNatOutboundMappingEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallNatOutboundMappingEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallNatOutboundMappingEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallNatOutboundMappingEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallNatPortForwardEndpointResponse struct {
	Data *PostFirewallNatPortForwardEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallNatPortForwardEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallNatPortForwardEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallNatPortForwardEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallNatPortForwardEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallNatPortForwardEndpointResponseData struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallNatPortForwardEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallNatPortForwardEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallNatPortForwardEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallNatPortForwardEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallRuleEndpointResponse struct {
	Data *PostFirewallRuleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallRuleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallRuleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallRuleEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallRuleEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallRuleEndpointResponseData struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallRuleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallRuleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallRuleEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallRuleEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallScheduleEndpointResponse struct {
	Data *PostFirewallScheduleEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallScheduleEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallScheduleEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallScheduleEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallScheduleEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallScheduleEndpointResponseData struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	ID        *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallScheduleEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallScheduleEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallScheduleEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallScheduleEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallScheduleTimeRangeEndpointResponse struct {
	Data *PostFirewallScheduleTimeRangeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallScheduleTimeRangeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallScheduleTimeRangeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallScheduleTimeRangeEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallScheduleTimeRangeEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallScheduleTimeRangeEndpointResponseData struct {
	// The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.<br>
	Position []int `json:"position,omitempty"`
	// The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Month []int `json:"month,omitempty"`
	// The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.<br><br>This field is only available when the following conditions are met:<br>- `position` must be equal to `NULL`<br>
	Day []int `json:"day,omitempty"`
	// The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).<br>
	Hour *string `json:"hour,omitempty"`
	// A description detailing this firewall schedule time range's purpose.<br>
	Rangedescr *string `json:"rangedescr,omitempty"`
	ParentID   *int    `json:"parent_id,omitempty"`
	ID         *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallScheduleTimeRangeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallScheduleTimeRangeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallScheduleTimeRangeEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallScheduleTimeRangeEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperEndpointResponse struct {
	Data *PostFirewallTrafficShaperEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperEndpointResponseData struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	ID    *int                      `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperLimiterBandwidthEndpointResponse struct {
	Data *PostFirewallTrafficShaperLimiterBandwidthEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperLimiterBandwidthEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperLimiterBandwidthEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperLimiterBandwidthEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperLimiterBandwidthEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperLimiterBandwidthEndpointResponseData struct {
	// The amount of bandwidth this profile allows.<br>
	Bw *int `json:"bw,omitempty"`
	// The scale factor of the `bw` fields value.<br>
	Bwscale *TrafficShaperLimiterBandwidthBwscale `json:"bwscale,omitempty"`
	// The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.<br>
	Bwsched  *string `json:"bwsched,omitempty"`
	ParentID *int    `json:"parent_id,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperLimiterBandwidthEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperLimiterBandwidthEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperLimiterBandwidthEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperLimiterBandwidthEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperLimiterEndpointResponse struct {
	Data *PostFirewallTrafficShaperLimiterEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperLimiterEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperLimiterEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperLimiterEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperLimiterEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperLimiterEndpointResponseData struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
	ID    *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperLimiterEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperLimiterEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperLimiterEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperLimiterEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperLimiterQueueEndpointResponse struct {
	Data *PostFirewallTrafficShaperLimiterQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperLimiterQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperLimiterQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperLimiterQueueEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperLimiterQueueEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperLimiterQueueEndpointResponseData struct {
	// The unique name for this limiter queue.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterQueueMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter queue.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterQueueAqm `json:"aqm,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The share of the parent limiter this queue gets.<br>
	Weight *int `json:"weight,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through this limiter queue.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter queue's bucket size (slots).<br>
	Buckets  *int `json:"buckets,omitempty"`
	ParentID *int `json:"parent_id,omitempty"`
	ID       *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperLimiterQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperLimiterQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperLimiterQueueEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperLimiterQueueEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperQueueEndpointResponse struct {
	Data *PostFirewallTrafficShaperQueueEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperQueueEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperQueueEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperQueueEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperQueueEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallTrafficShaperQueueEndpointResponseData struct {
	// The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>
	Interface *string `json:"interface,omitempty"`
	// Enables or disables the traffic shaper queue.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The name to assign this traffic shaper queue.<br>
	Name *string `json:"name,omitempty"`
	// The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>
	Priority *int `json:"priority,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// A description for this traffic shaper queue.<br>
	Description *string `json:"description,omitempty"`
	// Mark this traffic shaper queue as the default queue.<br>
	Default *bool `json:"default,omitempty"`
	// Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>
	Red *bool `json:"red,omitempty"`
	// Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>
	Rio *bool `json:"rio,omitempty"`
	// Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>
	Ecn *bool `json:"ecn,omitempty"`
	// Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>
	Codel *bool `json:"codel,omitempty"`
	// The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidthtype *TrafficShaperQueueBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// <br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>
	Hogs *int `json:"hogs,omitempty"`
	// Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>
	Borrow *bool `json:"borrow,omitempty"`
	// Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Upperlimit *bool `json:"upperlimit,omitempty"`
	// The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM1 *string `json:"upperlimit_m1,omitempty"`
	// The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitD *int `json:"upperlimit_d,omitempty"`
	// The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>
	UpperlimitM2 *string `json:"upperlimit_m2,omitempty"`
	// Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Realtime *bool `json:"realtime,omitempty"`
	// The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM1 *string `json:"realtime_m1,omitempty"`
	// The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeD *int `json:"realtime_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>
	RealtimeM2 *string `json:"realtime_m2,omitempty"`
	// Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>
	Linkshare *bool `json:"linkshare,omitempty"`
	// The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM1 *string `json:"linkshare_m1,omitempty"`
	// The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareD *int `json:"linkshare_d,omitempty"`
	// The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>
	LinkshareM2 *string `json:"linkshare_m2,omitempty"`
	ParentID    *int    `json:"parent_id,omitempty"`
	ID          *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallTrafficShaperQueueEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallTrafficShaperQueueEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallTrafficShaperQueueEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallTrafficShaperQueueEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallVirtualIPApplyEndpointResponse struct {
	Data *VirtualIPApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallVirtualIPApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallVirtualIPApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallVirtualIPApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallVirtualIPApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallVirtualIPEndpointResponse struct {
	Data *PostFirewallVirtualIPEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallVirtualIPEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallVirtualIPEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallVirtualIPEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallVirtualIPEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostFirewallVirtualIPEndpointResponseData struct {
	// The unique ID for this virtual IP.<br>
	Uniqid *string `json:"uniqid,omitempty"`
	// The virtual IP mode to use for this virtual IP.<br>
	Mode *VirtualIPMode `json:"mode,omitempty"`
	// The interface this virtual IP will apply to.<br>
	Interface *string `json:"interface,omitempty"`
	// The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes.<br>
	Type *VirtualIPType `json:"type,omitempty"`
	// The address for this virtual IP.<br>
	Subnet *string `json:"subnet,omitempty"`
	// The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask<br>
	SubnetBits *int `json:"subnet_bits,omitempty"`
	// A description for administrative reference<br>
	Descr *string `json:"descr,omitempty"`
	// Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)<br><br>This field is only available when the following conditions are met:<br>- `mode` must be one of [ proxyarp, other ]<br>
	Noexpand *bool `json:"noexpand,omitempty"`
	// The VHID group that the machines will share.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Vhid *int `json:"vhid,omitempty"`
	// The base frequency that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advbase *int `json:"advbase,omitempty"`
	// The frequency skew that this machine will advertise.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Advskew *int `json:"advskew,omitempty"`
	// The VHID group password shared by all CARP members.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	Password *string `json:"password,omitempty"`
	// The current CARP status of this virtual IP. This will display show whether this CARP node is the primary or backup peer.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpStatus *string `json:"carp_status,omitempty"`
	// The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `mode` must be equal to `'carp'`<br>
	CarpMode *VirtualIPCarpMode `json:"carp_mode,omitempty"`
	// The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.<br><br>This field is only available when the following conditions are met:<br>- `carp_mode` must be equal to `'ucast'`<br>
	CarpPeer *string `json:"carp_peer,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostFirewallVirtualIPEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostFirewallVirtualIPEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostFirewallVirtualIPEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostFirewallVirtualIPEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallAliasesEndpointRequestItem struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallAliasesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallAliasesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallAliasesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallAliasesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallAliasesEndpointResponse struct {
	Data []*PutFirewallAliasesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallAliasesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallAliasesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallAliasesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallAliasesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallAliasesEndpointResponseDataItem struct {
	// Sets the name for the alias. This name must be unique from all other aliases.<br>
	Name *string `json:"name,omitempty"`
	// Sets the type of alias this object will be. This directly impacts what values can be
	//
	//	specified in the `address` field.<br>
	Type *FirewallAliasType `json:"type,omitempty"`
	// Sets a description to help specify the purpose or contents of the alias.<br>
	Descr *string `json:"descr,omitempty"`
	// Sets the host, network or port entries for the alias. When `type` is set to `host`, each
	//
	//	entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid
	//	network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You
	//	may also specify an existing alias's `name` as an entry to created nested aliases.<br>
	Address []string `json:"address,omitempty"`
	// Sets descriptions for each alias `address`. Values must match the order of the `address`
	//
	//	value it relates to. For example, the first value specified here is the description for the first
	//	value specified in the `address` field. This value cannot contain <br>
	Detail []string `json:"detail,omitempty"`
	ID     *int     `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallAliasesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallAliasesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallAliasesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallAliasesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatOneToOneMappingsEndpointRequestItem struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatOneToOneMappingsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatOneToOneMappingsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatOneToOneMappingsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatOneToOneMappingsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatOneToOneMappingsEndpointResponse struct {
	Data []*PutFirewallNatOneToOneMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatOneToOneMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatOneToOneMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatOneToOneMappingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatOneToOneMappingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatOneToOneMappingsEndpointResponseDataItem struct {
	// The interface this 1:1 NAT mapping applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// Disables this 1:1 NAT mapping.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Exclude traffic matching this mapping from a later, more general, mapping.<br>
	Nobinat *bool `json:"nobinat,omitempty"`
	// Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default.<br>
	Natreflection *OneToOneNatMappingNatreflection `json:"natreflection,omitempty"`
	// The IP version this mapping applies to.<br>
	Ipprotocol *OneToOneNatMappingIpprotocol `json:"ipprotocol,omitempty"`
	// The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	External *string `json:"external,omitempty"`
	// The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// A description for this 1:1 NAT mapping<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatOneToOneMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatOneToOneMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatOneToOneMappingsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatOneToOneMappingsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatOutboundMappingsEndpointRequestItem struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatOutboundMappingsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatOutboundMappingsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatOutboundMappingsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatOutboundMappingsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatOutboundMappingsEndpointResponse struct {
	Data []*PutFirewallNatOutboundMappingsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatOutboundMappingsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatOutboundMappingsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatOutboundMappingsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatOutboundMappingsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatOutboundMappingsEndpointResponseDataItem struct {
	// The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.<br>
	Interface *string `json:"interface,omitempty"`
	// The protocol this rule should match. Use `null` for any protocol.<br>
	Protocol *OutboundNatMappingProtocol `json:"protocol,omitempty"`
	// Disable this outbound NAT rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Do not NAT traffic matching this rule.<br>
	Nonat *bool `json:"nonat,omitempty"`
	// Do not sync this rule to HA peers.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Target *string `json:"target,omitempty"`
	// The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	TargetSubnet *int `json:"target_subnet,omitempty"`
	// The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`<br><br>This field is only available when the following conditions are met:<br>- `static_nat_port` must be equal to `false`<br>- `nonat` must be equal to `false`<br>
	NatPort *string `json:"nat_port,omitempty"`
	// Do not rewrite source port for traffic matching this rule.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	StaticNatPort *bool `json:"static_nat_port,omitempty"`
	// The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.<br><br>This field is only available when the following conditions are met:<br>- `nonat` must be equal to `false`<br>
	Poolopts *OutboundNatMappingPoolopts `json:"poolopts,omitempty"`
	// The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generated<br><br>This field is only available when the following conditions are met:<br>- `poolopts` must be equal to `'source-hash'`<br>- `nonat` must be equal to `false`<br>
	SourceHashKey *string `json:"source_hash_key,omitempty"`
	// A description for the outbound NAT mapping.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatOutboundMappingsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatOutboundMappingsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatOutboundMappingsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatOutboundMappingsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatPortForwardsEndpointRequestItem struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatPortForwardsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatPortForwardsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatPortForwardsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatPortForwardsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatPortForwardsEndpointResponse struct {
	Data []*PutFirewallNatPortForwardsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatPortForwardsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatPortForwardsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatPortForwardsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatPortForwardsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallNatPortForwardsEndpointResponseDataItem struct {
	// The interface this port forward rule applies to.<br>
	Interface *string `json:"interface,omitempty"`
	// The IP protocol this port forward rule should match.<br>
	Ipprotocol *PortForwardIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this port forward rule should match.<br>
	Protocol *PortForwardProtocol `json:"protocol,omitempty"`
	// The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Target *string `json:"target,omitempty"`
	// The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	LocalPort *string `json:"local_port,omitempty"`
	// Disables this port forward rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Disables redirection for traffic matching this rule.<br>
	Nordr *bool `json:"nordr,omitempty"`
	// Prevents this port forward rule from being synced to non-primary CARP members.<br>
	Nosync *bool `json:"nosync,omitempty"`
	// A description for this port forward rule.<br>
	Descr *string `json:"descr,omitempty"`
	// The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default.<br>
	Natreflection *PortForwardNatreflection `json:"natreflection,omitempty"`
	// The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule.   Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this port forward rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this port forward rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this port forward rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallNatPortForwardsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallNatPortForwardsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallNatPortForwardsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallNatPortForwardsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallRulesEndpointRequestItem struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallRulesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallRulesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallRulesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallRulesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallRulesEndpointResponse struct {
	Data []*PutFirewallRulesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallRulesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallRulesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallRulesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallRulesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallRulesEndpointResponseDataItem struct {
	// The action to take against traffic that matches this rule.<br>
	Type *FirewallRuleType `json:"type,omitempty"`
	// The interface where packets must originate to match this rule.<br>
	Interface []string `json:"interface,omitempty"`
	// The IP version(s) this rule applies to.<br>
	Ipprotocol *FirewallRuleIpprotocol `json:"ipprotocol,omitempty"`
	// The IP/transport protocol this rule should match.<br>
	Protocol *FirewallRuleProtocol `json:"protocol,omitempty"`
	// Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>
	Icmptype []FirewallRuleIcmptypeItem `json:"icmptype,omitempty"`
	// The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Source *string `json:"source,omitempty"`
	// The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	SourcePort *string `json:"source_port,omitempty"`
	// The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>
	Destination *string `json:"destination,omitempty"`
	// The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>
	DestinationPort *string `json:"destination_port,omitempty"`
	// A description detailing the purpose or justification of this firewall rule.<br>
	Descr *string `json:"descr,omitempty"`
	// Enable or disable this firewall rule.<br>
	Disabled *bool `json:"disabled,omitempty"`
	// Enable or disable logging of traffic that matches this rule.<br>
	Log *bool `json:"log,omitempty"`
	// A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>
	Tag *string `json:"tag,omitempty"`
	// The state mechanism to use for this firewall rule.<br>
	Statetype *FirewallRuleStatetype `json:"statetype,omitempty"`
	// Allow any TCP flags.<br>
	TCPFlagsAny *bool `json:"tcp_flags_any,omitempty"`
	// The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsOutOf []FirewallRuleTCPFlagsOutOfItem `json:"tcp_flags_out_of,omitempty"`
	// The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>
	TCPFlagsSet []FirewallRuleTCPFlagsSetItem `json:"tcp_flags_set,omitempty"`
	// The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>
	Gateway *string `json:"gateway,omitempty"`
	// The name of an existing firewall schedule to assign to this firewall rule.<br>
	Sched *string `json:"sched,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>
	Dnpipe *string `json:"dnpipe,omitempty"`
	// The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>
	Pdnpipe *string `json:"pdnpipe,omitempty"`
	// The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>
	Defaultqueue *string `json:"defaultqueue,omitempty"`
	// The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>
	Ackqueue *string `json:"ackqueue,omitempty"`
	// Mark this rule as a floating firewall rule.<br>
	Floating *bool `json:"floating,omitempty"`
	// Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Quick *bool `json:"quick,omitempty"`
	// The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>
	Direction *FirewallRuleDirection `json:"direction,omitempty"`
	// The internal tracking ID for this firewall rule.<br>
	Tracker *int `json:"tracker,omitempty"`
	// The internal rule ID for the NAT rule associated with this rule.<br>
	AssociatedRuleID *string `json:"associated_rule_id,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	CreatedTime *int `json:"created_time,omitempty"`
	// The username and IP of the user who originally created this firewall rule.<br>
	CreatedBy *string `json:"created_by,omitempty"`
	// The unix timestamp of when this firewall rule was original created.<br>
	UpdatedTime *int `json:"updated_time,omitempty"`
	// The username and IP of the user who last updated this firewall rule.<br>
	UpdatedBy *string `json:"updated_by,omitempty"`
	ID        *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallRulesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallRulesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallRulesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallRulesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallSchedulesEndpointRequestItem struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallSchedulesEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallSchedulesEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallSchedulesEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallSchedulesEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallSchedulesEndpointResponse struct {
	Data []*PutFirewallSchedulesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallSchedulesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallSchedulesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallSchedulesEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallSchedulesEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallSchedulesEndpointResponseDataItem struct {
	// A unique ID for this schedule used internally by the system.<br>
	Schedlabel *string `json:"schedlabel,omitempty"`
	// The unique name to assign this schedule.<br>
	Name *string `json:"name,omitempty"`
	// A description of this schedules purpose.<br>
	Descr *string `json:"descr,omitempty"`
	// Displays whether the schedule is currently active or not.<br>
	Active *bool `json:"active,omitempty"`
	// The date/times this firewall schedule will be active.<br>
	Timerange []*FirewallScheduleTimerangeItem `json:"timerange,omitempty"`
	ID        *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallSchedulesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallSchedulesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallSchedulesEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallSchedulesEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallTrafficShaperLimitersEndpointRequestItem struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallTrafficShaperLimitersEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallTrafficShaperLimitersEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallTrafficShaperLimitersEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallTrafficShaperLimitersEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallTrafficShaperLimitersEndpointResponse struct {
	Data []*PutFirewallTrafficShaperLimitersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallTrafficShaperLimitersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallTrafficShaperLimitersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallTrafficShaperLimitersEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallTrafficShaperLimitersEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallTrafficShaperLimitersEndpointResponseDataItem struct {
	// The unique name for this limiter.<br>
	Name *string `json:"name,omitempty"`
	// A unique number auto-assigned to this limiter. This is only used internally by the system and cannot be manually set or changed.<br>
	Number *int `json:"number,omitempty"`
	// Enables or disables this limiter and its child queues.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet.<br>
	Mask *TrafficShaperLimiterMask `json:"mask,omitempty"`
	// The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbits *int `json:"maskbits,omitempty"`
	// The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.<br><br>This field is only available when the following conditions are met:<br>- `mask` must be one of [ srcaddress, dstaddress ]<br>
	Maskbitsv6 *int `json:"maskbitsv6,omitempty"`
	// The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be one of [ codel, pie, red, gred ]<br>- `sched` must be one of [ fq_codel, fq_pie ]<br>
	Ecn *bool `json:"ecn,omitempty"`
	// The verbose description for this limiter.<br>
	Description *string `json:"description,omitempty"`
	// The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion.<br>
	Aqm *TrafficShaperLimiterAqm `json:"aqm,omitempty"`
	// The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue.<br>
	Sched *TrafficShaperLimiterSched `json:"sched,omitempty"`
	// The value for the CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelTarget *int `json:"param_codel_target,omitempty"`
	// The value for the CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'codel'`<br>
	ParamCodelInterval *int `json:"param_codel_interval,omitempty"`
	// The value for the PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTarget *int `json:"param_pie_target,omitempty"`
	// The value for the PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieTupdate *int `json:"param_pie_tupdate,omitempty"`
	// The value for the PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieAlpha *int `json:"param_pie_alpha,omitempty"`
	// The value for the PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieBeta *int `json:"param_pie_beta,omitempty"`
	// The value for the PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxBurst *int `json:"param_pie_max_burst,omitempty"`
	// The value for the PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	ParamPieMaxEcnth *int `json:"param_pie_max_ecnth,omitempty"`
	// Enable or disable turning PIE on and off depending on queue load.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieOnoff *bool `json:"pie_onoff,omitempty"`
	// Enable or disable cap drop adjustment.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieCapdrop *bool `json:"pie_capdrop,omitempty"`
	// Set queue delay type to timestamps (true) or departure rate estimation (false).<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PieQdelay *bool `json:"pie_qdelay,omitempty"`
	// Enable or disable drop probability de-randomisation.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'pie'`<br>
	PiePderand *bool `json:"pie_pderand,omitempty"`
	// The value for the RED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedWQ *int `json:"param_red_w_q,omitempty"`
	// The value for the RED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMinTh *int `json:"param_red_min_th,omitempty"`
	// The value for the RED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxTh *int `json:"param_red_max_th,omitempty"`
	// The value for the RED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'red'`<br>
	ParamRedMaxP *int `json:"param_red_max_p,omitempty"`
	// The value for the GRED w_q parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredWQ *int `json:"param_gred_w_q,omitempty"`
	// The value for the GRED min_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMinTh *int `json:"param_gred_min_th,omitempty"`
	// The value for the GRED max_th parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxTh *int `json:"param_gred_max_th,omitempty"`
	// The value for the GRED max_p parameter.<br><br>This field is only available when the following conditions are met:<br>- `aqm` must be equal to `'gred'`<br>
	ParamGredMaxP *int `json:"param_gred_max_p,omitempty"`
	// The value for the FQ CoDel target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelTarget *int `json:"param_fq_codel_target,omitempty"`
	// The value for the FQ CoDel interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelInterval *int `json:"param_fq_codel_interval,omitempty"`
	// The value for the FQ CoDel quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelQuantum *int `json:"param_fq_codel_quantum,omitempty"`
	// The value for the FQ CoDel limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelLimit *int `json:"param_fq_codel_limit,omitempty"`
	// The value for the FQ CoDel flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_codel'`<br>
	ParamFqCodelFlows *int `json:"param_fq_codel_flows,omitempty"`
	// The value for the FQ PIE target parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTarget *int `json:"param_fq_pie_target,omitempty"`
	// The value for the FQ PIE tupdate parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieTupdate *int `json:"param_fq_pie_tupdate,omitempty"`
	// The value for the FQ PIE alpha parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieAlpha *int `json:"param_fq_pie_alpha,omitempty"`
	// The value for the FQ PIE beta parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieBeta *int `json:"param_fq_pie_beta,omitempty"`
	// The value for the FQ PIE max_burst parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxBurst *int `json:"param_fq_pie_max_burst,omitempty"`
	// The value for the FQ PIE ecnth parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieMaxEcnth *int `json:"param_fq_pie_max_ecnth,omitempty"`
	// The value for the FQ PIE quantum parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieQuantum *int `json:"param_fq_pie_quantum,omitempty"`
	// The value for the FQ PIE limit parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieLimit *int `json:"param_fq_pie_limit,omitempty"`
	// The value for the FQ PIE flows parameter.<br><br>This field is only available when the following conditions are met:<br>- `sched` must be equal to `'fq_pie'`<br>
	ParamFqPieFlows *int `json:"param_fq_pie_flows,omitempty"`
	// The amount of delay (in milliseconds) added to traffic passing through this limiter.<br>
	Delay *int `json:"delay,omitempty"`
	// The amount of packet loss (in percentage) added to traffic passing through the limiter.<br>
	Plr *float64 `json:"plr,omitempty"`
	// The limiter's bucket size (slots).<br>
	Buckets *int `json:"buckets,omitempty"`
	// The bandwidth profiles for this limiter.<br>
	Bandwidth []*TrafficShaperLimiterBandwidthItem `json:"bandwidth,omitempty"`
	// The child queues for this limiter.<br>
	Queue []*TrafficShaperLimiterQueueItem `json:"queue,omitempty"`
	ID    *int                             `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallTrafficShaperLimitersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallTrafficShaperLimitersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallTrafficShaperLimitersEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallTrafficShaperLimitersEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallTrafficShapersEndpointRequestItem struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallTrafficShapersEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallTrafficShapersEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallTrafficShapersEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallTrafficShapersEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallTrafficShapersEndpointResponse struct {
	Data []*PutFirewallTrafficShapersEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallTrafficShapersEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallTrafficShapersEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallTrafficShapersEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallTrafficShapersEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutFirewallTrafficShapersEndpointResponseDataItem struct {
	// Enables or disables this traffic shaper.<br>
	Enabled *bool `json:"enabled,omitempty"`
	// The interface this traffic shaper will be applied to.<br>
	Interface *string `json:"interface,omitempty"`
	// The name of this traffic shaper. This value is automatically set by the system and cannot be changed.<br>
	Name *string `json:"name,omitempty"`
	// The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper.<br>
	Scheduler *TrafficShaperScheduler `json:"scheduler,omitempty"`
	// The scale type of the `bandwidth` field's value.<br>
	Bandwidthtype *TrafficShaperBandwidthtype `json:"bandwidthtype,omitempty"`
	// The total bandwidth amount allowed by this traffic shaper.<br>
	Bandwidth *int `json:"bandwidth,omitempty"`
	// The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br><br>This field is only available when the following conditions are met:<br>- `scheduler` must not be one of [ CODELQ ]<br>
	Qlimit *int `json:"qlimit,omitempty"`
	// The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.<br>
	Tbrconfig *int `json:"tbrconfig,omitempty"`
	// The child queues assigned to this traffic shaper.<br>
	Queue []*TrafficShaperQueueItem `json:"queue,omitempty"`
	ID    *int                      `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutFirewallTrafficShapersEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutFirewallTrafficShapersEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutFirewallTrafficShapersEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutFirewallTrafficShapersEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
