// This file was auto-generated by Fern from our API Definition.

package pfclientapi

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/danielmichaels/go-pfrest/pkg/client/core"
)

type DeleteInterfaceBridgeEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteInterfaceGreEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteInterfaceGrEsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteInterfaceGroupEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteInterfaceGroupsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteInterfaceLaggEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteInterfaceLagGsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteInterfaceVlanEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type DeleteInterfaceVlaNsEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type DeleteNetworkInterfaceEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
	// Apply this deletion immediately.
	Apply *bool `json:"-"`
}

type DeleteNetworkInterfacesEndpointRequest struct {
	// The maximum number of objects to delete at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetInterfaceAvailableInterfacesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetInterfaceAvailableInterfacesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetInterfaceAvailableInterfacesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetInterfaceBridgeEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetInterfaceBridgesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetInterfaceBridgesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetInterfaceBridgesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetInterfaceGreEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetInterfaceGrEsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetInterfaceGrEsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetInterfaceGrEsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetInterfaceGroupEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetInterfaceGroupsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetInterfaceGroupsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetInterfaceGroupsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetInterfaceLaggEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetInterfaceLagGsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetInterfaceLagGsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetInterfaceLagGsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetInterfaceVlanEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetInterfaceVlaNsEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetInterfaceVlaNsEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetInterfaceVlaNsEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type GetNetworkInterfaceEndpointRequest struct {
	// The ID of the object to target.
	ID *string `json:"-"`
}

type GetNetworkInterfacesEndpointRequest struct {
	// The number of objects to obtain at once. Set to 0 for no limit.
	Limit *int `json:"-"`
	// The starting point in the dataset to begin fetching objects.
	Offset *int `json:"-"`
	// The fields to sort response data by.
	SortBy *string `json:"-"`
	// The order to sort response data by.
	SortOrder *GetNetworkInterfacesEndpointRequestSortOrder `json:"-"`
	// The sort flag to use to customize the behavior of the sort.
	SortFlags *GetNetworkInterfacesEndpointRequestSortFlags `json:"-"`
	// The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
	Query *string `json:"-"`
}

type PatchInterfaceBridgeEndpointRequest struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchInterfaceGreEndpointRequest struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchInterfaceGroupEndpointRequest struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchInterfaceLaggEndpointRequest struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchInterfaceVlanEndpointRequest struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PatchNetworkInterfaceEndpointRequest struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
	// The ID of the object or resource to interact with.
	ID int `json:"id"`
}

type PostInterfaceApplyEndpointRequest struct {
	// Displays `true` when all interfaces are applied and there are no pending changes left.Displays `false` when there are pending interface changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
	// Displays a list of interfaces that have pending changes waiting to be applied.<br>
	PendingInterfaces []string `json:"pending_interfaces,omitempty"`
}

type PostInterfaceBridgeEndpointRequest struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`
}

type PostInterfaceGreEndpointRequest struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
}

type PostInterfaceGroupEndpointRequest struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
}

type PostInterfaceLaggEndpointRequest struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
}

type PostInterfaceVlanEndpointRequest struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
}

type PostNetworkInterfaceEndpointRequest struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
}

type AvailableInterface struct {
	// The name of the interface.<br>
	If *string `json:"if,omitempty"`
	// The MAC address of the interface.<br>
	Mac *string `json:"mac,omitempty"`
	// The description of the interface.<br>
	Dmesg *string `json:"dmesg,omitempty"`
	// The pfSense interface ID that is using this interface.<br>
	InUseBy *string `json:"in_use_by,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AvailableInterface) UnmarshalJSON(data []byte) error {
	type unmarshaler AvailableInterface
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AvailableInterface(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AvailableInterface) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type InterfaceApply struct {
	// Displays `true` when all interfaces are applied and there are no pending changes left.Displays `false` when there are pending interface changes that have not been applied.<br>
	Applied *bool `json:"applied,omitempty"`
	// Displays a list of interfaces that have pending changes waiting to be applied.<br>
	PendingInterfaces []string `json:"pending_interfaces,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InterfaceApply) UnmarshalJSON(data []byte) error {
	type unmarshaler InterfaceApply
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterfaceApply(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterfaceApply) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InterfaceBridge struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InterfaceBridge) UnmarshalJSON(data []byte) error {
	type unmarshaler InterfaceBridge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterfaceBridge(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterfaceBridge) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InterfaceGre struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InterfaceGre) UnmarshalJSON(data []byte) error {
	type unmarshaler InterfaceGre
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterfaceGre(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterfaceGre) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InterfaceGroup struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InterfaceGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler InterfaceGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterfaceGroup(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterfaceGroup) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InterfaceLagg struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InterfaceLagg) UnmarshalJSON(data []byte) error {
	type unmarshaler InterfaceLagg
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterfaceLagg(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterfaceLagg) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
type InterfaceLaggLacptimeout string

const (
	InterfaceLaggLacptimeoutSlow InterfaceLaggLacptimeout = "slow"
	InterfaceLaggLacptimeoutFast InterfaceLaggLacptimeout = "fast"
)

func NewInterfaceLaggLacptimeoutFromString(s string) (InterfaceLaggLacptimeout, error) {
	switch s {
	case "slow":
		return InterfaceLaggLacptimeoutSlow, nil
	case "fast":
		return InterfaceLaggLacptimeoutFast, nil
	}
	var t InterfaceLaggLacptimeout
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InterfaceLaggLacptimeout) Ptr() *InterfaceLaggLacptimeout {
	return &i
}

// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
type InterfaceLaggLagghash string

const (
	InterfaceLaggLagghashL2     InterfaceLaggLagghash = "l2"
	InterfaceLaggLagghashL3     InterfaceLaggLagghash = "l3"
	InterfaceLaggLagghashL4     InterfaceLaggLagghash = "l4"
	InterfaceLaggLagghashL2L3   InterfaceLaggLagghash = "l2,l3"
	InterfaceLaggLagghashL2L4   InterfaceLaggLagghash = "l2,l4"
	InterfaceLaggLagghashL3L4   InterfaceLaggLagghash = "l3,l4"
	InterfaceLaggLagghashL2L3L4 InterfaceLaggLagghash = "l2,l3,l4"
)

func NewInterfaceLaggLagghashFromString(s string) (InterfaceLaggLagghash, error) {
	switch s {
	case "l2":
		return InterfaceLaggLagghashL2, nil
	case "l3":
		return InterfaceLaggLagghashL3, nil
	case "l4":
		return InterfaceLaggLagghashL4, nil
	case "l2,l3":
		return InterfaceLaggLagghashL2L3, nil
	case "l2,l4":
		return InterfaceLaggLagghashL2L4, nil
	case "l3,l4":
		return InterfaceLaggLagghashL3L4, nil
	case "l2,l3,l4":
		return InterfaceLaggLagghashL2L3L4, nil
	}
	var t InterfaceLaggLagghash
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InterfaceLaggLagghash) Ptr() *InterfaceLaggLagghash {
	return &i
}

// The LAGG protocol to use.<br>
type InterfaceLaggProto string

const (
	InterfaceLaggProtoLacp        InterfaceLaggProto = "lacp"
	InterfaceLaggProtoFailover    InterfaceLaggProto = "failover"
	InterfaceLaggProtoLoadbalance InterfaceLaggProto = "loadbalance"
	InterfaceLaggProtoRoundrobin  InterfaceLaggProto = "roundrobin"
	InterfaceLaggProtoNone        InterfaceLaggProto = "none"
)

func NewInterfaceLaggProtoFromString(s string) (InterfaceLaggProto, error) {
	switch s {
	case "lacp":
		return InterfaceLaggProtoLacp, nil
	case "failover":
		return InterfaceLaggProtoFailover, nil
	case "loadbalance":
		return InterfaceLaggProtoLoadbalance, nil
	case "roundrobin":
		return InterfaceLaggProtoRoundrobin, nil
	case "none":
		return InterfaceLaggProtoNone, nil
	}
	var t InterfaceLaggProto
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InterfaceLaggProto) Ptr() *InterfaceLaggProto {
	return &i
}

type InterfaceVlan struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InterfaceVlan) UnmarshalJSON(data []byte) error {
	type unmarshaler InterfaceVlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterfaceVlan(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterfaceVlan) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type NetworkInterface struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NetworkInterface) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkInterface
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkInterface(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NetworkInterface) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
type NetworkInterfaceAdvDhcpPtValues string

const (
	NetworkInterfaceAdvDhcpPtValuesSavedCfg NetworkInterfaceAdvDhcpPtValues = "SavedCfg"
)

func NewNetworkInterfaceAdvDhcpPtValuesFromString(s string) (NetworkInterfaceAdvDhcpPtValues, error) {
	switch s {
	case "SavedCfg":
		return NetworkInterfaceAdvDhcpPtValuesSavedCfg, nil
	}
	var t NetworkInterfaceAdvDhcpPtValues
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkInterfaceAdvDhcpPtValues) Ptr() *NetworkInterfaceAdvDhcpPtValues {
	return &n
}

// Selects the IPv4 address type to assign this interface.<br>
type NetworkInterfaceTypev4 string

const (
	NetworkInterfaceTypev4Static NetworkInterfaceTypev4 = "static"
	NetworkInterfaceTypev4Dhcp   NetworkInterfaceTypev4 = "dhcp"
	NetworkInterfaceTypev4None   NetworkInterfaceTypev4 = "none"
)

func NewNetworkInterfaceTypev4FromString(s string) (NetworkInterfaceTypev4, error) {
	switch s {
	case "static":
		return NetworkInterfaceTypev4Static, nil
	case "dhcp":
		return NetworkInterfaceTypev4Dhcp, nil
	case "none":
		return NetworkInterfaceTypev4None, nil
	}
	var t NetworkInterfaceTypev4
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkInterfaceTypev4) Ptr() *NetworkInterfaceTypev4 {
	return &n
}

// Selects the IPv6 address type to assign this interface.<br>
type NetworkInterfaceTypev6 string

const (
	NetworkInterfaceTypev6Staticv6  NetworkInterfaceTypev6 = "staticv6"
	NetworkInterfaceTypev6Dhcp6     NetworkInterfaceTypev6 = "dhcp6"
	NetworkInterfaceTypev6Slaac     NetworkInterfaceTypev6 = "slaac"
	NetworkInterfaceTypev6Value6Rd  NetworkInterfaceTypev6 = "value_6rd"
	NetworkInterfaceTypev6Track6    NetworkInterfaceTypev6 = "track6"
	NetworkInterfaceTypev6Value6To4 NetworkInterfaceTypev6 = "value_6to4"
	NetworkInterfaceTypev6None      NetworkInterfaceTypev6 = "none"
)

func NewNetworkInterfaceTypev6FromString(s string) (NetworkInterfaceTypev6, error) {
	switch s {
	case "staticv6":
		return NetworkInterfaceTypev6Staticv6, nil
	case "dhcp6":
		return NetworkInterfaceTypev6Dhcp6, nil
	case "slaac":
		return NetworkInterfaceTypev6Slaac, nil
	case "value_6rd":
		return NetworkInterfaceTypev6Value6Rd, nil
	case "track6":
		return NetworkInterfaceTypev6Track6, nil
	case "value_6to4":
		return NetworkInterfaceTypev6Value6To4, nil
	case "none":
		return NetworkInterfaceTypev6None, nil
	}
	var t NetworkInterfaceTypev6
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkInterfaceTypev6) Ptr() *NetworkInterfaceTypev6 {
	return &n
}

type DeleteInterfaceBridgeEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteInterfaceBridgeEndpointRequestIDFromInteger(value int) *DeleteInterfaceBridgeEndpointRequestID {
	return &DeleteInterfaceBridgeEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteInterfaceBridgeEndpointRequestIDFromString(value string) *DeleteInterfaceBridgeEndpointRequestID {
	return &DeleteInterfaceBridgeEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteInterfaceBridgeEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteInterfaceBridgeEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteInterfaceBridgeEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteInterfaceBridgeEndpointRequestID) Accept(visitor DeleteInterfaceBridgeEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteInterfaceBridgeEndpointResponse struct {
	Data *DeleteInterfaceBridgeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceBridgeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceBridgeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceBridgeEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceBridgeEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceBridgeEndpointResponseData struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceBridgeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceBridgeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceBridgeEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceBridgeEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGrEsEndpointResponse struct {
	Data []*DeleteInterfaceGrEsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGrEsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGrEsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGrEsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGrEsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGrEsEndpointResponseDataItem struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
	ID               *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGrEsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGrEsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGrEsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGrEsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGreEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteInterfaceGreEndpointRequestIDFromInteger(value int) *DeleteInterfaceGreEndpointRequestID {
	return &DeleteInterfaceGreEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteInterfaceGreEndpointRequestIDFromString(value string) *DeleteInterfaceGreEndpointRequestID {
	return &DeleteInterfaceGreEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteInterfaceGreEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteInterfaceGreEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteInterfaceGreEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteInterfaceGreEndpointRequestID) Accept(visitor DeleteInterfaceGreEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteInterfaceGreEndpointResponse struct {
	Data *DeleteInterfaceGreEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGreEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGreEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGreEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGreEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGreEndpointResponseData struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
	ID               *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGreEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGreEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGreEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGreEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGroupEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteInterfaceGroupEndpointRequestIDFromInteger(value int) *DeleteInterfaceGroupEndpointRequestID {
	return &DeleteInterfaceGroupEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteInterfaceGroupEndpointRequestIDFromString(value string) *DeleteInterfaceGroupEndpointRequestID {
	return &DeleteInterfaceGroupEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteInterfaceGroupEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteInterfaceGroupEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteInterfaceGroupEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteInterfaceGroupEndpointRequestID) Accept(visitor DeleteInterfaceGroupEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteInterfaceGroupEndpointResponse struct {
	Data *DeleteInterfaceGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGroupEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGroupEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGroupEndpointResponseData struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGroupEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGroupEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGroupsEndpointResponse struct {
	Data []*DeleteInterfaceGroupsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGroupsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGroupsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGroupsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGroupsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceGroupsEndpointResponseDataItem struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceGroupsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceGroupsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceGroupsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceGroupsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceLagGsEndpointResponse struct {
	Data []*DeleteInterfaceLagGsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceLagGsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceLagGsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceLagGsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceLagGsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceLagGsEndpointResponseDataItem struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceLagGsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceLagGsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceLagGsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceLagGsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceLaggEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteInterfaceLaggEndpointRequestIDFromInteger(value int) *DeleteInterfaceLaggEndpointRequestID {
	return &DeleteInterfaceLaggEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteInterfaceLaggEndpointRequestIDFromString(value string) *DeleteInterfaceLaggEndpointRequestID {
	return &DeleteInterfaceLaggEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteInterfaceLaggEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteInterfaceLaggEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteInterfaceLaggEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteInterfaceLaggEndpointRequestID) Accept(visitor DeleteInterfaceLaggEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteInterfaceLaggEndpointResponse struct {
	Data *DeleteInterfaceLaggEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceLaggEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceLaggEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceLaggEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceLaggEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceLaggEndpointResponseData struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceLaggEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceLaggEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceLaggEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceLaggEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceVlaNsEndpointResponse struct {
	Data []*DeleteInterfaceVlaNsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceVlaNsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceVlaNsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceVlaNsEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceVlaNsEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceVlaNsEndpointResponseDataItem struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceVlaNsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceVlaNsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceVlaNsEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceVlaNsEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceVlanEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteInterfaceVlanEndpointRequestIDFromInteger(value int) *DeleteInterfaceVlanEndpointRequestID {
	return &DeleteInterfaceVlanEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteInterfaceVlanEndpointRequestIDFromString(value string) *DeleteInterfaceVlanEndpointRequestID {
	return &DeleteInterfaceVlanEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteInterfaceVlanEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteInterfaceVlanEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteInterfaceVlanEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteInterfaceVlanEndpointRequestID) Accept(visitor DeleteInterfaceVlanEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteInterfaceVlanEndpointResponse struct {
	Data *DeleteInterfaceVlanEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceVlanEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceVlanEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceVlanEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceVlanEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteInterfaceVlanEndpointResponseData struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteInterfaceVlanEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInterfaceVlanEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInterfaceVlanEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInterfaceVlanEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteNetworkInterfaceEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewDeleteNetworkInterfaceEndpointRequestIDFromInteger(value int) *DeleteNetworkInterfaceEndpointRequestID {
	return &DeleteNetworkInterfaceEndpointRequestID{typeName: "integer", Integer: value}
}

func NewDeleteNetworkInterfaceEndpointRequestIDFromString(value string) *DeleteNetworkInterfaceEndpointRequestID {
	return &DeleteNetworkInterfaceEndpointRequestID{typeName: "string", String: value}
}

func (d *DeleteNetworkInterfaceEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		d.typeName = "integer"
		d.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typeName = "string"
		d.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DeleteNetworkInterfaceEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch d.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return json.Marshal(d.Integer)
	case "string":
		return json.Marshal(d.String)
	}
}

type DeleteNetworkInterfaceEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (d *DeleteNetworkInterfaceEndpointRequestID) Accept(visitor DeleteNetworkInterfaceEndpointRequestIDVisitor) error {
	switch d.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", d.typeName, d)
	case "integer":
		return visitor.VisitInteger(d.Integer)
	case "string":
		return visitor.VisitString(d.String)
	}
}

type DeleteNetworkInterfaceEndpointResponse struct {
	Data *DeleteNetworkInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteNetworkInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteNetworkInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteNetworkInterfaceEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteNetworkInterfaceEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteNetworkInterfaceEndpointResponseData struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
	ID                *string `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteNetworkInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteNetworkInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteNetworkInterfaceEndpointResponseData(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteNetworkInterfaceEndpointResponseData) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteNetworkInterfacesEndpointResponse struct {
	Data []*DeleteNetworkInterfacesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteNetworkInterfacesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteNetworkInterfacesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteNetworkInterfacesEndpointResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteNetworkInterfacesEndpointResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteNetworkInterfacesEndpointResponseDataItem struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
	ID                *string `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteNetworkInterfacesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteNetworkInterfacesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteNetworkInterfacesEndpointResponseDataItem(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteNetworkInterfacesEndpointResponseDataItem) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GetInterfaceApplyEndpointResponse struct {
	Data *InterfaceApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceApplyEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceApplyEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceAvailableInterfacesEndpointRequestSortFlags string

const (
	GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortRegular      GetInterfaceAvailableInterfacesEndpointRequestSortFlags = "SORT_REGULAR"
	GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortNumeric      GetInterfaceAvailableInterfacesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortString       GetInterfaceAvailableInterfacesEndpointRequestSortFlags = "SORT_STRING"
	GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortLocaleString GetInterfaceAvailableInterfacesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortNatural      GetInterfaceAvailableInterfacesEndpointRequestSortFlags = "SORT_NATURAL"
	GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortFlagCase     GetInterfaceAvailableInterfacesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetInterfaceAvailableInterfacesEndpointRequestSortFlagsFromString(s string) (GetInterfaceAvailableInterfacesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetInterfaceAvailableInterfacesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetInterfaceAvailableInterfacesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceAvailableInterfacesEndpointRequestSortFlags) Ptr() *GetInterfaceAvailableInterfacesEndpointRequestSortFlags {
	return &g
}

type GetInterfaceAvailableInterfacesEndpointRequestSortOrder string

const (
	GetInterfaceAvailableInterfacesEndpointRequestSortOrderSortAsc  GetInterfaceAvailableInterfacesEndpointRequestSortOrder = "SORT_ASC"
	GetInterfaceAvailableInterfacesEndpointRequestSortOrderSortDesc GetInterfaceAvailableInterfacesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetInterfaceAvailableInterfacesEndpointRequestSortOrderFromString(s string) (GetInterfaceAvailableInterfacesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetInterfaceAvailableInterfacesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetInterfaceAvailableInterfacesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetInterfaceAvailableInterfacesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceAvailableInterfacesEndpointRequestSortOrder) Ptr() *GetInterfaceAvailableInterfacesEndpointRequestSortOrder {
	return &g
}

type GetInterfaceAvailableInterfacesEndpointResponse struct {
	Data []*GetInterfaceAvailableInterfacesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceAvailableInterfacesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceAvailableInterfacesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceAvailableInterfacesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceAvailableInterfacesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceAvailableInterfacesEndpointResponseDataItem struct {
	// The name of the interface.<br>
	If *string `json:"if,omitempty"`
	// The MAC address of the interface.<br>
	Mac *string `json:"mac,omitempty"`
	// The description of the interface.<br>
	Dmesg *string `json:"dmesg,omitempty"`
	// The pfSense interface ID that is using this interface.<br>
	InUseBy *string `json:"in_use_by,omitempty"`
	ID      *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceAvailableInterfacesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceAvailableInterfacesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceAvailableInterfacesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceAvailableInterfacesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceBridgeEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetInterfaceBridgeEndpointRequestIDFromInteger(value int) *GetInterfaceBridgeEndpointRequestID {
	return &GetInterfaceBridgeEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetInterfaceBridgeEndpointRequestIDFromString(value string) *GetInterfaceBridgeEndpointRequestID {
	return &GetInterfaceBridgeEndpointRequestID{typeName: "string", String: value}
}

func (g *GetInterfaceBridgeEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetInterfaceBridgeEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetInterfaceBridgeEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetInterfaceBridgeEndpointRequestID) Accept(visitor GetInterfaceBridgeEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetInterfaceBridgeEndpointResponse struct {
	Data *GetInterfaceBridgeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceBridgeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceBridgeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceBridgeEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceBridgeEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceBridgeEndpointResponseData struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceBridgeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceBridgeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceBridgeEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceBridgeEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceBridgesEndpointRequestSortFlags string

const (
	GetInterfaceBridgesEndpointRequestSortFlagsSortRegular      GetInterfaceBridgesEndpointRequestSortFlags = "SORT_REGULAR"
	GetInterfaceBridgesEndpointRequestSortFlagsSortNumeric      GetInterfaceBridgesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetInterfaceBridgesEndpointRequestSortFlagsSortString       GetInterfaceBridgesEndpointRequestSortFlags = "SORT_STRING"
	GetInterfaceBridgesEndpointRequestSortFlagsSortLocaleString GetInterfaceBridgesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetInterfaceBridgesEndpointRequestSortFlagsSortNatural      GetInterfaceBridgesEndpointRequestSortFlags = "SORT_NATURAL"
	GetInterfaceBridgesEndpointRequestSortFlagsSortFlagCase     GetInterfaceBridgesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetInterfaceBridgesEndpointRequestSortFlagsFromString(s string) (GetInterfaceBridgesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetInterfaceBridgesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetInterfaceBridgesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetInterfaceBridgesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetInterfaceBridgesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetInterfaceBridgesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetInterfaceBridgesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetInterfaceBridgesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceBridgesEndpointRequestSortFlags) Ptr() *GetInterfaceBridgesEndpointRequestSortFlags {
	return &g
}

type GetInterfaceBridgesEndpointRequestSortOrder string

const (
	GetInterfaceBridgesEndpointRequestSortOrderSortAsc  GetInterfaceBridgesEndpointRequestSortOrder = "SORT_ASC"
	GetInterfaceBridgesEndpointRequestSortOrderSortDesc GetInterfaceBridgesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetInterfaceBridgesEndpointRequestSortOrderFromString(s string) (GetInterfaceBridgesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetInterfaceBridgesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetInterfaceBridgesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetInterfaceBridgesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceBridgesEndpointRequestSortOrder) Ptr() *GetInterfaceBridgesEndpointRequestSortOrder {
	return &g
}

type GetInterfaceBridgesEndpointResponse struct {
	Data []*GetInterfaceBridgesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceBridgesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceBridgesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceBridgesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceBridgesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceBridgesEndpointResponseDataItem struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceBridgesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceBridgesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceBridgesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceBridgesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGrEsEndpointRequestSortFlags string

const (
	GetInterfaceGrEsEndpointRequestSortFlagsSortRegular      GetInterfaceGrEsEndpointRequestSortFlags = "SORT_REGULAR"
	GetInterfaceGrEsEndpointRequestSortFlagsSortNumeric      GetInterfaceGrEsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetInterfaceGrEsEndpointRequestSortFlagsSortString       GetInterfaceGrEsEndpointRequestSortFlags = "SORT_STRING"
	GetInterfaceGrEsEndpointRequestSortFlagsSortLocaleString GetInterfaceGrEsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetInterfaceGrEsEndpointRequestSortFlagsSortNatural      GetInterfaceGrEsEndpointRequestSortFlags = "SORT_NATURAL"
	GetInterfaceGrEsEndpointRequestSortFlagsSortFlagCase     GetInterfaceGrEsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetInterfaceGrEsEndpointRequestSortFlagsFromString(s string) (GetInterfaceGrEsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetInterfaceGrEsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetInterfaceGrEsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetInterfaceGrEsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetInterfaceGrEsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetInterfaceGrEsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetInterfaceGrEsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetInterfaceGrEsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceGrEsEndpointRequestSortFlags) Ptr() *GetInterfaceGrEsEndpointRequestSortFlags {
	return &g
}

type GetInterfaceGrEsEndpointRequestSortOrder string

const (
	GetInterfaceGrEsEndpointRequestSortOrderSortAsc  GetInterfaceGrEsEndpointRequestSortOrder = "SORT_ASC"
	GetInterfaceGrEsEndpointRequestSortOrderSortDesc GetInterfaceGrEsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetInterfaceGrEsEndpointRequestSortOrderFromString(s string) (GetInterfaceGrEsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetInterfaceGrEsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetInterfaceGrEsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetInterfaceGrEsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceGrEsEndpointRequestSortOrder) Ptr() *GetInterfaceGrEsEndpointRequestSortOrder {
	return &g
}

type GetInterfaceGrEsEndpointResponse struct {
	Data []*GetInterfaceGrEsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGrEsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGrEsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGrEsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGrEsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGrEsEndpointResponseDataItem struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
	ID               *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGrEsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGrEsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGrEsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGrEsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGreEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetInterfaceGreEndpointRequestIDFromInteger(value int) *GetInterfaceGreEndpointRequestID {
	return &GetInterfaceGreEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetInterfaceGreEndpointRequestIDFromString(value string) *GetInterfaceGreEndpointRequestID {
	return &GetInterfaceGreEndpointRequestID{typeName: "string", String: value}
}

func (g *GetInterfaceGreEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetInterfaceGreEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetInterfaceGreEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetInterfaceGreEndpointRequestID) Accept(visitor GetInterfaceGreEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetInterfaceGreEndpointResponse struct {
	Data *GetInterfaceGreEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGreEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGreEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGreEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGreEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGreEndpointResponseData struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
	ID               *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGreEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGreEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGreEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGreEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGroupEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetInterfaceGroupEndpointRequestIDFromInteger(value int) *GetInterfaceGroupEndpointRequestID {
	return &GetInterfaceGroupEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetInterfaceGroupEndpointRequestIDFromString(value string) *GetInterfaceGroupEndpointRequestID {
	return &GetInterfaceGroupEndpointRequestID{typeName: "string", String: value}
}

func (g *GetInterfaceGroupEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetInterfaceGroupEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetInterfaceGroupEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetInterfaceGroupEndpointRequestID) Accept(visitor GetInterfaceGroupEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetInterfaceGroupEndpointResponse struct {
	Data *GetInterfaceGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGroupEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGroupEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGroupEndpointResponseData struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGroupEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGroupEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGroupsEndpointRequestSortFlags string

const (
	GetInterfaceGroupsEndpointRequestSortFlagsSortRegular      GetInterfaceGroupsEndpointRequestSortFlags = "SORT_REGULAR"
	GetInterfaceGroupsEndpointRequestSortFlagsSortNumeric      GetInterfaceGroupsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetInterfaceGroupsEndpointRequestSortFlagsSortString       GetInterfaceGroupsEndpointRequestSortFlags = "SORT_STRING"
	GetInterfaceGroupsEndpointRequestSortFlagsSortLocaleString GetInterfaceGroupsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetInterfaceGroupsEndpointRequestSortFlagsSortNatural      GetInterfaceGroupsEndpointRequestSortFlags = "SORT_NATURAL"
	GetInterfaceGroupsEndpointRequestSortFlagsSortFlagCase     GetInterfaceGroupsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetInterfaceGroupsEndpointRequestSortFlagsFromString(s string) (GetInterfaceGroupsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetInterfaceGroupsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetInterfaceGroupsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetInterfaceGroupsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetInterfaceGroupsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetInterfaceGroupsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetInterfaceGroupsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetInterfaceGroupsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceGroupsEndpointRequestSortFlags) Ptr() *GetInterfaceGroupsEndpointRequestSortFlags {
	return &g
}

type GetInterfaceGroupsEndpointRequestSortOrder string

const (
	GetInterfaceGroupsEndpointRequestSortOrderSortAsc  GetInterfaceGroupsEndpointRequestSortOrder = "SORT_ASC"
	GetInterfaceGroupsEndpointRequestSortOrderSortDesc GetInterfaceGroupsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetInterfaceGroupsEndpointRequestSortOrderFromString(s string) (GetInterfaceGroupsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetInterfaceGroupsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetInterfaceGroupsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetInterfaceGroupsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceGroupsEndpointRequestSortOrder) Ptr() *GetInterfaceGroupsEndpointRequestSortOrder {
	return &g
}

type GetInterfaceGroupsEndpointResponse struct {
	Data []*GetInterfaceGroupsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGroupsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGroupsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGroupsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGroupsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceGroupsEndpointResponseDataItem struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceGroupsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceGroupsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceGroupsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceGroupsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceLagGsEndpointRequestSortFlags string

const (
	GetInterfaceLagGsEndpointRequestSortFlagsSortRegular      GetInterfaceLagGsEndpointRequestSortFlags = "SORT_REGULAR"
	GetInterfaceLagGsEndpointRequestSortFlagsSortNumeric      GetInterfaceLagGsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetInterfaceLagGsEndpointRequestSortFlagsSortString       GetInterfaceLagGsEndpointRequestSortFlags = "SORT_STRING"
	GetInterfaceLagGsEndpointRequestSortFlagsSortLocaleString GetInterfaceLagGsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetInterfaceLagGsEndpointRequestSortFlagsSortNatural      GetInterfaceLagGsEndpointRequestSortFlags = "SORT_NATURAL"
	GetInterfaceLagGsEndpointRequestSortFlagsSortFlagCase     GetInterfaceLagGsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetInterfaceLagGsEndpointRequestSortFlagsFromString(s string) (GetInterfaceLagGsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetInterfaceLagGsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetInterfaceLagGsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetInterfaceLagGsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetInterfaceLagGsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetInterfaceLagGsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetInterfaceLagGsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetInterfaceLagGsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceLagGsEndpointRequestSortFlags) Ptr() *GetInterfaceLagGsEndpointRequestSortFlags {
	return &g
}

type GetInterfaceLagGsEndpointRequestSortOrder string

const (
	GetInterfaceLagGsEndpointRequestSortOrderSortAsc  GetInterfaceLagGsEndpointRequestSortOrder = "SORT_ASC"
	GetInterfaceLagGsEndpointRequestSortOrderSortDesc GetInterfaceLagGsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetInterfaceLagGsEndpointRequestSortOrderFromString(s string) (GetInterfaceLagGsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetInterfaceLagGsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetInterfaceLagGsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetInterfaceLagGsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceLagGsEndpointRequestSortOrder) Ptr() *GetInterfaceLagGsEndpointRequestSortOrder {
	return &g
}

type GetInterfaceLagGsEndpointResponse struct {
	Data []*GetInterfaceLagGsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceLagGsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceLagGsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceLagGsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceLagGsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceLagGsEndpointResponseDataItem struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceLagGsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceLagGsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceLagGsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceLagGsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceLaggEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetInterfaceLaggEndpointRequestIDFromInteger(value int) *GetInterfaceLaggEndpointRequestID {
	return &GetInterfaceLaggEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetInterfaceLaggEndpointRequestIDFromString(value string) *GetInterfaceLaggEndpointRequestID {
	return &GetInterfaceLaggEndpointRequestID{typeName: "string", String: value}
}

func (g *GetInterfaceLaggEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetInterfaceLaggEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetInterfaceLaggEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetInterfaceLaggEndpointRequestID) Accept(visitor GetInterfaceLaggEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetInterfaceLaggEndpointResponse struct {
	Data *GetInterfaceLaggEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceLaggEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceLaggEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceLaggEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceLaggEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceLaggEndpointResponseData struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceLaggEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceLaggEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceLaggEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceLaggEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceVlaNsEndpointRequestSortFlags string

const (
	GetInterfaceVlaNsEndpointRequestSortFlagsSortRegular      GetInterfaceVlaNsEndpointRequestSortFlags = "SORT_REGULAR"
	GetInterfaceVlaNsEndpointRequestSortFlagsSortNumeric      GetInterfaceVlaNsEndpointRequestSortFlags = "SORT_NUMERIC"
	GetInterfaceVlaNsEndpointRequestSortFlagsSortString       GetInterfaceVlaNsEndpointRequestSortFlags = "SORT_STRING"
	GetInterfaceVlaNsEndpointRequestSortFlagsSortLocaleString GetInterfaceVlaNsEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetInterfaceVlaNsEndpointRequestSortFlagsSortNatural      GetInterfaceVlaNsEndpointRequestSortFlags = "SORT_NATURAL"
	GetInterfaceVlaNsEndpointRequestSortFlagsSortFlagCase     GetInterfaceVlaNsEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetInterfaceVlaNsEndpointRequestSortFlagsFromString(s string) (GetInterfaceVlaNsEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetInterfaceVlaNsEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetInterfaceVlaNsEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetInterfaceVlaNsEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetInterfaceVlaNsEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetInterfaceVlaNsEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetInterfaceVlaNsEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetInterfaceVlaNsEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceVlaNsEndpointRequestSortFlags) Ptr() *GetInterfaceVlaNsEndpointRequestSortFlags {
	return &g
}

type GetInterfaceVlaNsEndpointRequestSortOrder string

const (
	GetInterfaceVlaNsEndpointRequestSortOrderSortAsc  GetInterfaceVlaNsEndpointRequestSortOrder = "SORT_ASC"
	GetInterfaceVlaNsEndpointRequestSortOrderSortDesc GetInterfaceVlaNsEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetInterfaceVlaNsEndpointRequestSortOrderFromString(s string) (GetInterfaceVlaNsEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetInterfaceVlaNsEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetInterfaceVlaNsEndpointRequestSortOrderSortDesc, nil
	}
	var t GetInterfaceVlaNsEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetInterfaceVlaNsEndpointRequestSortOrder) Ptr() *GetInterfaceVlaNsEndpointRequestSortOrder {
	return &g
}

type GetInterfaceVlaNsEndpointResponse struct {
	Data []*GetInterfaceVlaNsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceVlaNsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceVlaNsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceVlaNsEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceVlaNsEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceVlaNsEndpointResponseDataItem struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceVlaNsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceVlaNsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceVlaNsEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceVlaNsEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceVlanEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetInterfaceVlanEndpointRequestIDFromInteger(value int) *GetInterfaceVlanEndpointRequestID {
	return &GetInterfaceVlanEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetInterfaceVlanEndpointRequestIDFromString(value string) *GetInterfaceVlanEndpointRequestID {
	return &GetInterfaceVlanEndpointRequestID{typeName: "string", String: value}
}

func (g *GetInterfaceVlanEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetInterfaceVlanEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetInterfaceVlanEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetInterfaceVlanEndpointRequestID) Accept(visitor GetInterfaceVlanEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetInterfaceVlanEndpointResponse struct {
	Data *GetInterfaceVlanEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceVlanEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceVlanEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceVlanEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceVlanEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInterfaceVlanEndpointResponseData struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetInterfaceVlanEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInterfaceVlanEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInterfaceVlanEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInterfaceVlanEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetNetworkInterfaceEndpointRequestID struct {
	typeName string
	Integer  int
	String   string
}

func NewGetNetworkInterfaceEndpointRequestIDFromInteger(value int) *GetNetworkInterfaceEndpointRequestID {
	return &GetNetworkInterfaceEndpointRequestID{typeName: "integer", Integer: value}
}

func NewGetNetworkInterfaceEndpointRequestIDFromString(value string) *GetNetworkInterfaceEndpointRequestID {
	return &GetNetworkInterfaceEndpointRequestID{typeName: "string", String: value}
}

func (g *GetNetworkInterfaceEndpointRequestID) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		g.typeName = "integer"
		g.Integer = valueInteger
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		g.typeName = "string"
		g.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, g)
}

func (g GetNetworkInterfaceEndpointRequestID) MarshalJSON() ([]byte, error) {
	switch g.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return json.Marshal(g.Integer)
	case "string":
		return json.Marshal(g.String)
	}
}

type GetNetworkInterfaceEndpointRequestIDVisitor interface {
	VisitInteger(int) error
	VisitString(string) error
}

func (g *GetNetworkInterfaceEndpointRequestID) Accept(visitor GetNetworkInterfaceEndpointRequestIDVisitor) error {
	switch g.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", g.typeName, g)
	case "integer":
		return visitor.VisitInteger(g.Integer)
	case "string":
		return visitor.VisitString(g.String)
	}
}

type GetNetworkInterfaceEndpointResponse struct {
	Data *GetNetworkInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetNetworkInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetNetworkInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetNetworkInterfaceEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetNetworkInterfaceEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetNetworkInterfaceEndpointResponseData struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
	ID                *string `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetNetworkInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler GetNetworkInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetNetworkInterfaceEndpointResponseData(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetNetworkInterfaceEndpointResponseData) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetNetworkInterfacesEndpointRequestSortFlags string

const (
	GetNetworkInterfacesEndpointRequestSortFlagsSortRegular      GetNetworkInterfacesEndpointRequestSortFlags = "SORT_REGULAR"
	GetNetworkInterfacesEndpointRequestSortFlagsSortNumeric      GetNetworkInterfacesEndpointRequestSortFlags = "SORT_NUMERIC"
	GetNetworkInterfacesEndpointRequestSortFlagsSortString       GetNetworkInterfacesEndpointRequestSortFlags = "SORT_STRING"
	GetNetworkInterfacesEndpointRequestSortFlagsSortLocaleString GetNetworkInterfacesEndpointRequestSortFlags = "SORT_LOCALE_STRING"
	GetNetworkInterfacesEndpointRequestSortFlagsSortNatural      GetNetworkInterfacesEndpointRequestSortFlags = "SORT_NATURAL"
	GetNetworkInterfacesEndpointRequestSortFlagsSortFlagCase     GetNetworkInterfacesEndpointRequestSortFlags = "SORT_FLAG_CASE"
)

func NewGetNetworkInterfacesEndpointRequestSortFlagsFromString(s string) (GetNetworkInterfacesEndpointRequestSortFlags, error) {
	switch s {
	case "SORT_REGULAR":
		return GetNetworkInterfacesEndpointRequestSortFlagsSortRegular, nil
	case "SORT_NUMERIC":
		return GetNetworkInterfacesEndpointRequestSortFlagsSortNumeric, nil
	case "SORT_STRING":
		return GetNetworkInterfacesEndpointRequestSortFlagsSortString, nil
	case "SORT_LOCALE_STRING":
		return GetNetworkInterfacesEndpointRequestSortFlagsSortLocaleString, nil
	case "SORT_NATURAL":
		return GetNetworkInterfacesEndpointRequestSortFlagsSortNatural, nil
	case "SORT_FLAG_CASE":
		return GetNetworkInterfacesEndpointRequestSortFlagsSortFlagCase, nil
	}
	var t GetNetworkInterfacesEndpointRequestSortFlags
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetNetworkInterfacesEndpointRequestSortFlags) Ptr() *GetNetworkInterfacesEndpointRequestSortFlags {
	return &g
}

type GetNetworkInterfacesEndpointRequestSortOrder string

const (
	GetNetworkInterfacesEndpointRequestSortOrderSortAsc  GetNetworkInterfacesEndpointRequestSortOrder = "SORT_ASC"
	GetNetworkInterfacesEndpointRequestSortOrderSortDesc GetNetworkInterfacesEndpointRequestSortOrder = "SORT_DESC"
)

func NewGetNetworkInterfacesEndpointRequestSortOrderFromString(s string) (GetNetworkInterfacesEndpointRequestSortOrder, error) {
	switch s {
	case "SORT_ASC":
		return GetNetworkInterfacesEndpointRequestSortOrderSortAsc, nil
	case "SORT_DESC":
		return GetNetworkInterfacesEndpointRequestSortOrderSortDesc, nil
	}
	var t GetNetworkInterfacesEndpointRequestSortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GetNetworkInterfacesEndpointRequestSortOrder) Ptr() *GetNetworkInterfacesEndpointRequestSortOrder {
	return &g
}

type GetNetworkInterfacesEndpointResponse struct {
	Data []*GetNetworkInterfacesEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetNetworkInterfacesEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetNetworkInterfacesEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetNetworkInterfacesEndpointResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetNetworkInterfacesEndpointResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetNetworkInterfacesEndpointResponseDataItem struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
	ID                *string `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetNetworkInterfacesEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GetNetworkInterfacesEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetNetworkInterfacesEndpointResponseDataItem(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetNetworkInterfacesEndpointResponseDataItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type PatchInterfaceBridgeEndpointResponse struct {
	Data *PatchInterfaceBridgeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceBridgeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceBridgeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceBridgeEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceBridgeEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceBridgeEndpointResponseData struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceBridgeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceBridgeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceBridgeEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceBridgeEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceGreEndpointResponse struct {
	Data *PatchInterfaceGreEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceGreEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceGreEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceGreEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceGreEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceGreEndpointResponseData struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
	ID               *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceGreEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceGreEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceGreEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceGreEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceGroupEndpointResponse struct {
	Data *PatchInterfaceGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceGroupEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceGroupEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceGroupEndpointResponseData struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceGroupEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceGroupEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceLaggEndpointResponse struct {
	Data *PatchInterfaceLaggEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceLaggEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceLaggEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceLaggEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceLaggEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceLaggEndpointResponseData struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceLaggEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceLaggEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceLaggEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceLaggEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceVlanEndpointResponse struct {
	Data *PatchInterfaceVlanEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceVlanEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceVlanEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceVlanEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceVlanEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchInterfaceVlanEndpointResponseData struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchInterfaceVlanEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchInterfaceVlanEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchInterfaceVlanEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchInterfaceVlanEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchNetworkInterfaceEndpointResponse struct {
	Data *PatchNetworkInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchNetworkInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchNetworkInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchNetworkInterfaceEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchNetworkInterfaceEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PatchNetworkInterfaceEndpointResponseData struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
	ID                *string `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PatchNetworkInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchNetworkInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchNetworkInterfaceEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchNetworkInterfaceEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceApplyEndpointResponse struct {
	Data *InterfaceApply `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceApplyEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceApplyEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceApplyEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceApplyEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceBridgeEndpointResponse struct {
	Data *PostInterfaceBridgeEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceBridgeEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceBridgeEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceBridgeEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceBridgeEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceBridgeEndpointResponseData struct {
	// The member interfaces to include in this bridge.<br>
	Members []string `json:"members,omitempty"`
	// A description for this interface bridge.<br>
	Descr *string `json:"descr,omitempty"`
	// The real interface name for this bridge interface.<br>
	Bridgeif *string `json:"bridgeif,omitempty"`
	ID       *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceBridgeEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceBridgeEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceBridgeEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceBridgeEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceGreEndpointResponse struct {
	Data *PostInterfaceGreEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceGreEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceGreEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceGreEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceGreEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceGreEndpointResponseData struct {
	// The pfSense interface interface serving as the local address to be used for the GRE tunnel.<br>
	If *string `json:"if,omitempty"`
	// The real interface name for this GRE interface.<br>
	Greif *string `json:"greif,omitempty"`
	// A description for this GRE interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.<br>
	AddStaticRoute *bool `json:"add_static_route,omitempty"`
	// The remote address to use for the GRE tunnel.<br>
	RemoteAddr *string `json:"remote_addr,omitempty"`
	// The local IPv4 address to use for the GRE tunnel.<br>
	TunnelLocalAddr *string `json:"tunnel_local_addr,omitempty"`
	// The remote IPv4 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteAddr *string `json:"tunnel_remote_addr,omitempty"`
	// The remote IPv4 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr` must not be equal to `NULL`<br>
	TunnelRemoteNet *int `json:"tunnel_remote_net,omitempty"`
	// The local IPv6 address to use for the GRE tunnel.<br>
	TunnelLocalAddr6 *string `json:"tunnel_local_addr6,omitempty"`
	// The remote IPv6 address to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteAddr6 *string `json:"tunnel_remote_addr6,omitempty"`
	// The remote IPv6 subnet bitmask to use for the GRE tunnel.<br><br>This field is only available when the following conditions are met:<br>- `tunnel_local_addr6` must not be equal to `NULL`<br>
	TunnelRemoteNet6 *int `json:"tunnel_remote_net6,omitempty"`
	ID               *int `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceGreEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceGreEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceGreEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceGreEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceGroupEndpointResponse struct {
	Data *PostInterfaceGroupEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceGroupEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceGroupEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceGroupEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceGroupEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceGroupEndpointResponseData struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceGroupEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceGroupEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceGroupEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceGroupEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceLaggEndpointResponse struct {
	Data *PostInterfaceLaggEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceLaggEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceLaggEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceLaggEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceLaggEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceLaggEndpointResponseData struct {
	// The real name of the LAGG interface.<br>
	Laggif *string `json:"laggif,omitempty"`
	// A description to help document the purpose of this LAGG interface.<br>
	Descr *string `json:"descr,omitempty"`
	// A list of member interfaces to include in the LAGG.<br>
	Members []string `json:"members,omitempty"`
	// The LAGG protocol to use.<br>
	Proto *InterfaceLaggProto `json:"proto,omitempty"`
	// The LACP timeout mode to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'lacp'`<br>
	Lacptimeout *InterfaceLaggLacptimeout `json:"lacptimeout,omitempty"`
	// The LAGG hash algorithm to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be one of [ lacp, loadbalance ]<br>
	Lagghash *InterfaceLaggLagghash `json:"lagghash,omitempty"`
	// The failover master interface to use.<br><br>This field is only available when the following conditions are met:<br>- `proto` must be equal to `'failover'`<br>
	Failovermaster *string `json:"failovermaster,omitempty"`
	ID             *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceLaggEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceLaggEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceLaggEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceLaggEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceVlanEndpointResponse struct {
	Data *PostInterfaceVlanEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceVlanEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceVlanEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceVlanEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceVlanEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostInterfaceVlanEndpointResponseData struct {
	// The real parent interface this VLAN will be applied to.<br>
	If *string `json:"if,omitempty"`
	// The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.<br>
	Tag *int `json:"tag,omitempty"`
	// Displays the full interface VLAN. This value is automatically populated and cannot be set.<br>
	Vlanif *string `json:"vlanif,omitempty"`
	// The 802.1p VLAN priority code point (PCP) to assign to this VLAN.<br>
	Pcp *int `json:"pcp,omitempty"`
	// A description to help document the purpose of this VLAN.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostInterfaceVlanEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostInterfaceVlanEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostInterfaceVlanEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostInterfaceVlanEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostNetworkInterfaceEndpointResponse struct {
	Data *PostNetworkInterfaceEndpointResponseData `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostNetworkInterfaceEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PostNetworkInterfaceEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostNetworkInterfaceEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostNetworkInterfaceEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostNetworkInterfaceEndpointResponseData struct {
	// The real interface this configuration will be applied to.<br>
	If *string `json:"if,omitempty"`
	// Enable or disable this interface.<br>
	Enable *bool `json:"enable,omitempty"`
	// The descriptive name for this interface.<br>
	Descr *string `json:"descr,omitempty"`
	// Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.<br>
	Spoofmac *string `json:"spoofmac,omitempty"`
	// Sets the MTU for this interface. Assumes default MTU if value is `null`.<br>
	Mtu *int `json:"mtu,omitempty"`
	// Sets the MSS for this interface. Assumes default MSS if value is `null`.<br>
	Mss *int `json:"mss,omitempty"`
	// Sets the link speed for this interface. In most situations this can be left as the default.<br>
	Media *string `json:"media,omitempty"`
	// Sets the link duplex for this interface. In most situations this can be left as the default.<br>
	Mediaopt *string `json:"mediaopt,omitempty"`
	// Enable or disable automatically blocking RFC 1918 private networks on this interface.<br>
	Blockpriv *bool `json:"blockpriv,omitempty"`
	// Enable or disable automatically blocking bogon networks on this interface.<br>
	Blockbogons *bool `json:"blockbogons,omitempty"`
	// Selects the IPv4 address type to assign this interface.<br>
	Typev4 *NetworkInterfaceTypev4 `json:"typev4,omitempty"`
	// Sets the IPv4 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be one of [ static, dhcp ]<br>
	Ipaddr *string `json:"ipaddr,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Subnet *int `json:"subnet,omitempty"`
	// Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'static'`<br>
	Gateway *string `json:"gateway,omitempty"`
	// Sets the DHCP hostname this interface will advertise via DHCP.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcphostname *string `json:"dhcphostname,omitempty"`
	// Sets the value used as a fixed alias IPv4 address by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasAddress *string `json:"alias_address,omitempty"`
	// Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AliasSubnet *int `json:"alias_subnet,omitempty"`
	// Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	Dhcprejectfrom []string `json:"dhcprejectfrom,omitempty"`
	// Enables or disables the advanced DHCP settings on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigAdvanced *bool `json:"adv_dhcp_config_advanced,omitempty"`
	// Selects the advanced DHCP timing preset.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtValues *NetworkInterfaceAdvDhcpPtValues `json:"adv_dhcp_pt_values,omitempty"`
	// Manually sets the timeout timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtTimeout *int `json:"adv_dhcp_pt_timeout,omitempty"`
	// Manually sets the retry timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtRetry *int `json:"adv_dhcp_pt_retry,omitempty"`
	// Manually sets the select timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtSelectTimeout *int `json:"adv_dhcp_pt_select_timeout,omitempty"`
	// Manually sets the reboot timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtReboot *int `json:"adv_dhcp_pt_reboot,omitempty"`
	// Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtBackoffCutoff *int `json:"adv_dhcp_pt_backoff_cutoff,omitempty"`
	// Manually sets the initial interval timing value used when requested DHCP leases on this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpPtInitialInterval *int `json:"adv_dhcp_pt_initial_interval,omitempty"`
	// Sets DHCP options to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpSendOptions *string `json:"adv_dhcp_send_options,omitempty"`
	// Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequestOptions *string `json:"adv_dhcp_request_options,omitempty"`
	// Sets DHCP options required by the client when requesting a DHCP lease for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpRequiredOptions *string `json:"adv_dhcp_required_options,omitempty"`
	// Sets DHCP option modifiers applied to the obtained DHCP lease.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_advanced` must be equal to `true`<br>
	AdvDhcpOptionModifiers *string `json:"adv_dhcp_option_modifiers,omitempty"`
	// Enables or disables overriding the entire DHCP configuration file for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>
	AdvDhcpConfigFileOverride *bool `json:"adv_dhcp_config_file_override,omitempty"`
	// Sets the local file path of the custom DHCP configuration file.<br><br>This field is only available when the following conditions are met:<br>- `typev4` must be equal to `'dhcp'`<br>- `adv_dhcp_config_file_override` must be equal to `true`<br>
	AdvDhcpConfigFileOverridePath *string `json:"adv_dhcp_config_file_override_path,omitempty"`
	// Selects the IPv6 address type to assign this interface.<br>
	Typev6 *NetworkInterfaceTypev6 `json:"typev6,omitempty"`
	// Sets the IPv6 address to assign to this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]<br>
	Ipaddrv6 *string `json:"ipaddrv6,omitempty"`
	// Sets the subnet bit count to assign this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Subnetv6 *int `json:"subnetv6,omitempty"`
	// Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Gatewayv6 *string `json:"gatewayv6,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'staticv6'`<br>
	Ipv6Usev4Iface *bool `json:"ipv6usev4iface,omitempty"`
	// Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'slaac'`<br>
	Slaacusev4Iface *bool `json:"slaacusev4iface,omitempty"`
	// Sets the 6RD IPv6 prefix assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6Rd *string `json:"prefix_6rd,omitempty"`
	// Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Gateway6Rd *string `json:"gateway_6rd,omitempty"`
	// Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'6rd'`<br>
	Prefix6RdV4Plen *int `json:"prefix_6rd_v4plen,omitempty"`
	// Sets the dynamic IPv6 WAN interface to track for configuration.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6Interface *string `json:"track6_interface,omitempty"`
	// Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.<br><br>This field is only available when the following conditions are met:<br>- `typev6` must be equal to `'track6'`<br>
	Track6PrefixIDHex *string `json:"track6_prefix_id_hex,omitempty"`
	ID                *string `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PostNetworkInterfaceEndpointResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler PostNetworkInterfaceEndpointResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PostNetworkInterfaceEndpointResponseData(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostNetworkInterfaceEndpointResponseData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutInterfaceGroupsEndpointRequestItem struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutInterfaceGroupsEndpointRequestItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutInterfaceGroupsEndpointRequestItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutInterfaceGroupsEndpointRequestItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutInterfaceGroupsEndpointRequestItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutInterfaceGroupsEndpointResponse struct {
	Data []*PutInterfaceGroupsEndpointResponseDataItem `json:"data,omitempty"`
	// The HTTP status code that corresponds with the API response.
	Code *int `json:"code,omitempty"`
	// The HTTP status message that corresponds with the HTTP status code.
	Status *string `json:"status,omitempty"`
	// The unique response ID that corresponds with the result of the APIcall. In most situations, this will contain an error code.
	ResponseID *string `json:"response_id,omitempty"`
	// The descriptive message detailing the results of the API call.
	Message *string `json:"message,omitempty"`
	// An array of links to resources that are related to this API response.
	Links map[string]interface{} `json:"_links,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutInterfaceGroupsEndpointResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PutInterfaceGroupsEndpointResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutInterfaceGroupsEndpointResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutInterfaceGroupsEndpointResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PutInterfaceGroupsEndpointResponseDataItem struct {
	// The name of this interface group.<br>
	Ifname *string `json:"ifname,omitempty"`
	// The member interfaces to assign to this interface group.<br>
	Members []string `json:"members,omitempty"`
	// The description for this interface group.<br>
	Descr *string `json:"descr,omitempty"`
	ID    *int    `json:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PutInterfaceGroupsEndpointResponseDataItem) UnmarshalJSON(data []byte) error {
	type unmarshaler PutInterfaceGroupsEndpointResponseDataItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PutInterfaceGroupsEndpointResponseDataItem(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PutInterfaceGroupsEndpointResponseDataItem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
